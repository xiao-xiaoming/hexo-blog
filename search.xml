<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>24.回溯算法</title>
      <link href="//post/24.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html"/>
      <url>//post/24.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>[TOC]</p><p>深度优先搜索算法利用的是回溯算法思想，它还用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。</p><h2 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h2><p>在人的一生中，会遇到很多重要的岔路口。在岔路口上，每个选择都会影响我们今后的人生。有的人在每个岔路口都能做出最正确的选择，最后生活、事业都达到了一个很高的高度；而有的人一路选错，最后碌碌无为。如果人生可以量化，那如何才能在岔路口做出最正确的选择，让自己的人生“最优”呢？</p><p>借助贪心算法，在每次面对岔路口的时候，都做出看起来最优的选择，期望这一组选择可以使得我们的人生达到“最优”。但贪心算法并不一定能得到最优解。</p><p>回溯的处理思想，有点类似枚举搜索。枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><h2 id="回溯算法的应用"><a href="#回溯算法的应用" class="headerlink" title="回溯算法的应用"></a>回溯算法的应用</h2><h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p><p>下图中左图是满足条件的一种方法，又图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式：</p><p><img src="imgs/2/1570503806038.png" alt="1570503806038"></p><p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前的方法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种方法，继续尝试。</p><p>回溯算法非常适合用递归代码实现，下面是八皇后问题的java实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cal8queens</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 调用方式：cal8queens(0);</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 8 个棋子都放置好了，打印结果</span>    <span class="token function">printQueens</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> column <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> column <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>column<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 每一行都有 8 中放法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isOk</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 有些放法不满足要求</span>      result<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> column<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第 row 行的棋子放到了 column 列</span>      <span class="token function">cal8queens</span><span class="token punctuation">(</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 考察下一行</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isOk</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> column<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 判断 row 行 column 列放置是否合适</span>  <span class="token keyword">int</span> leftup <span class="token operator">=</span> column <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> rightup <span class="token operator">=</span> column <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 逐行往上考察每一行</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> column<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第 i 行的 column 列有棋子吗？</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftup <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 考察左上对角线：第 i 行 leftup 列有棋子吗？</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> leftup<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>rightup <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 考察右上对角线：第 i 行 rightup 列有棋子吗？</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> rightup<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">--</span>leftup<span class="token punctuation">;</span> <span class="token operator">++</span>rightup<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 打印出一个二维矩阵</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> row <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>row<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> column <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> column <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>column<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">==</span> column<span class="token punctuation">)</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Q "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"* "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">8</span>  <span class="token comment" spellcheck="true"># 角标代表皇后所在的行数，值存储皇后所在的列</span>n <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 第n个满足条件的情况</span><span class="token keyword">def</span> <span class="token function">print_eight_queen</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"----------{n}----------"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> column <span class="token keyword">in</span> result<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">==</span> column<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>end<span class="token operator">=</span><span class="token string">"Q  "</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>end<span class="token operator">=</span><span class="token string">"*  "</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">cal8queen</span><span class="token punctuation">(</span>row<span class="token punctuation">:</span> int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> n    <span class="token keyword">if</span> row <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">:</span>        print_eight_queen<span class="token punctuation">(</span>result<span class="token punctuation">)</span>        n <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> column <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 只有在第row行column列放置不与之前已经放置的冲突时才进行放置</span>        <span class="token keyword">if</span> is_ok<span class="token punctuation">(</span>row<span class="token punctuation">,</span> column<span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> column            cal8queen<span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">is_ok</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> column<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    校验在第row行将皇后放置在第column列是否满足条件    通过校验的条件是第row行前面所有行，都没有与当前列相同的列数，也不在当前列的对角线上    """</span>    leftup<span class="token punctuation">,</span> rightup <span class="token operator">=</span> column <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> column <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> column <span class="token operator">==</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">or</span> leftup <span class="token operator">==</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">or</span> rightup <span class="token operator">==</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        leftup <span class="token operator">-=</span> <span class="token number">1</span>        rightup <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token boolean">True</span>cal8queen<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有一种简单但没有那么高效的解法，那就是回溯算法。</p><p>0-1 背包问题有很多变体，介绍一种比较基础的。</p><p>有一个背包总的承载重量是 $Wkg$。现在有 n 个重量不等的物品，不可分割。选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>这个背包问题，物品是不可分割的，要么装要么不装，所以叫 0-1 背包问题。显然，这个问题已经无法通过贪心算法来解决了。</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 $2^n$ 种，去掉总重量超过 $Wkg$ 的，从剩下的装法中选择总重量最接近 $Wkg$的。</p><p>把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品，发现已经选择的物品的重量超过 ​之后，就停止继续探测剩下的物品。</p><p>java代码：</p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 $Wkg$之后，我们就停止继续探测剩下的物品。你可以看我写的具体的代码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> maxW <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存储背包中物品总重量的最大值</span><span class="token comment" spellcheck="true">// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；</span><span class="token comment" spellcheck="true">// w 背包重量；items 表示每个物品的重量；n 表示物品个数</span><span class="token comment" spellcheck="true">// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span><span class="token comment" spellcheck="true">// f(0, 0, a, 10, 100)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> cw<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cw <span class="token operator">==</span> w <span class="token operator">||</span> i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cw <span class="token operator">></span> maxW<span class="token punctuation">)</span> maxW <span class="token operator">=</span> cw<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> cw<span class="token punctuation">,</span> items<span class="token punctuation">,</span> n<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cw <span class="token operator">+</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 已经超过可以背包承受的重量的时候，就不要再装了</span>    <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>cw <span class="token operator">+</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> items<span class="token punctuation">,</span> n<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python">max_value <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 存储背包中物品总重量的最大值</span><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> cw<span class="token punctuation">:</span> int<span class="token punctuation">,</span> items<span class="token punctuation">:</span> list<span class="token punctuation">,</span> w<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    假设背包可承受重量 100，物品重量存储在数组 a 中，那可以这样调用函数：    bag(0, 0, a, 100)    :param i: 当前物品的索引    :param cw: 当前已经装进去的物品的重量和    :param items: 每个物品的重量    :param w: 背包容量    :return:    """</span>    <span class="token keyword">global</span> max_value    <span class="token keyword">if</span> cw <span class="token operator">==</span> w <span class="token operator">or</span> i <span class="token operator">==</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span>        <span class="token keyword">if</span> cw <span class="token operator">></span> max_w<span class="token punctuation">:</span> max_w <span class="token operator">=</span> cw        <span class="token keyword">return</span>    f<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cw<span class="token punctuation">,</span> items<span class="token punctuation">,</span> w<span class="token punctuation">)</span>    <span class="token keyword">if</span> cw <span class="token operator">+</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> w<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 已经超过可以背包承受的重量的时候，就不要再装了</span>        f<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cw <span class="token operator">+</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> items<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可获取选择的重量列表的python实现：</p><pre class="line-numbers language-python"><code class="language-python">max_value <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 存储背包中物品总重量的最大值</span><span class="token comment" spellcheck="true"># 背包选取的物品列表</span>picks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>picks_with_max_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">bag</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> cw<span class="token punctuation">:</span> int<span class="token punctuation">,</span> items<span class="token punctuation">:</span> list<span class="token punctuation">,</span> w<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    假设背包可承受重量 100，物品重量存储在数组 a 中，那可以这样调用函数：    bag(0, 0, a, 100)    :param i: 当前物品的索引    :param cw: 当前已经装进去的物品的重量和    :param items: 每个物品的重量    :param w: 背包容量    :return:    """</span>    <span class="token keyword">global</span> max_value    <span class="token keyword">if</span> cw <span class="token operator">==</span> w <span class="token operator">or</span> i <span class="token operator">==</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span>        <span class="token keyword">if</span> cw <span class="token operator">></span> max_w<span class="token punctuation">:</span>            <span class="token keyword">global</span> picks_with_max_value            max_w <span class="token operator">=</span> cw            picks_with_max_value <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> picks <span class="token keyword">if</span> x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 不选第i个物品</span>    bag<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cw<span class="token punctuation">,</span> items<span class="token punctuation">,</span> w<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 选第i个物品</span>    ncw <span class="token operator">=</span> cw <span class="token operator">+</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> ncw <span class="token operator">&lt;=</span> w<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 已经超过可以背包承受的重量的时候，就不要再装了</span>        picks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        bag<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ncw<span class="token punctuation">,</span> items<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    items_info <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>    picks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>items_info<span class="token punctuation">)</span>    w <span class="token operator">=</span> <span class="token number">23</span>    bag<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> items_info<span class="token punctuation">,</span> w<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>picks_with_max_value<span class="token punctuation">,</span> max_value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式里最重要的一种算法思想就是回溯。</p><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。先假设正则表达式中只包含“*”和“?”这两种通配符，“*”表示匹配大于等于 0 个任意字符，“?”表示匹配零个或者一个任意字符。</p><p>基于以上假设下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>依次考察正则表达式中的每个字符，非通配符时就直接跟文本的字符进行匹配，相同则继续往下处理；不同则回溯。</p><p>如果遇到特殊字符，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><p>java代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pattern</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">boolean</span> matched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正则表达式</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> plen<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正则表达式长度</span>  <span class="token keyword">public</span> <span class="token function">Pattern</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">,</span> <span class="token keyword">int</span> plen<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>pattern <span class="token operator">=</span> pattern<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>plen <span class="token operator">=</span> plen<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> tlen<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 文本串及长度</span>    matched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token function">rmatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> matched<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rmatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> ti<span class="token punctuation">,</span> <span class="token keyword">int</span> pj<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> tlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>matched<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果已经匹配了，就不要继续递归了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pj <span class="token operator">==</span> plen<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 正则表达式到结尾了</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>ti <span class="token operator">==</span> tlen<span class="token punctuation">)</span> matched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 文本串也到结尾了</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>pj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// * 匹配任意个字符</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> tlen<span class="token operator">-</span>ti<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rmatch</span><span class="token punctuation">(</span>ti<span class="token operator">+</span>k<span class="token punctuation">,</span> pj<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>pj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ? 匹配 0 个或者 1 个字符</span>      <span class="token function">rmatch</span><span class="token punctuation">(</span>ti<span class="token punctuation">,</span> pj<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">rmatch</span><span class="token punctuation">(</span>ti<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pj<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ti <span class="token operator">&lt;</span> tlen <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">[</span>pj<span class="token punctuation">]</span> <span class="token operator">==</span> text<span class="token punctuation">[</span>ti<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 纯字符匹配才行</span>      <span class="token function">rmatch</span><span class="token punctuation">(</span>ti<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pj<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> text<span class="token punctuation">,</span> tlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Pattern</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> regex<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>regex <span class="token operator">=</span> regex  <span class="token comment" spellcheck="true"># 正则表达式</span>        self<span class="token punctuation">.</span>matched <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">rmatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> r_idx<span class="token punctuation">:</span> int<span class="token punctuation">,</span> m_idx<span class="token punctuation">:</span> int<span class="token punctuation">,</span> main<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>matched<span class="token punctuation">:</span> <span class="token keyword">return</span>  <span class="token comment" spellcheck="true"># 如果已经匹配了，就不要继续递归了</span>        <span class="token keyword">if</span> r_idx <span class="token operator">==</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 正则表达式到结尾了</span>            <span class="token keyword">if</span> m_idx <span class="token operator">==</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>matched <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment" spellcheck="true"># 文本串也到结尾了</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>regex<span class="token punctuation">[</span>r_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># * 匹配任意个字符</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m_idx<span class="token punctuation">,</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>rmatch<span class="token punctuation">(</span>r_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span>        <span class="token keyword">elif</span> self<span class="token punctuation">.</span>regex<span class="token punctuation">[</span>r_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'?'</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># ? 匹配0个或者1个字符</span>            self<span class="token punctuation">.</span>rmatch<span class="token punctuation">(</span>r_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m_idx<span class="token punctuation">,</span> main<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>rmatch<span class="token punctuation">(</span>r_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span>        <span class="token keyword">elif</span> m_idx <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>regex<span class="token punctuation">[</span>r_idx<span class="token punctuation">]</span> <span class="token operator">==</span> main<span class="token punctuation">[</span>m_idx<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 非特殊字符需要精确匹配</span>            self<span class="token punctuation">.</span>rmatch<span class="token punctuation">(</span>r_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> m_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> main<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>matched <span class="token operator">=</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>rmatch<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> main<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>matched<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="0-1背包问题升级版"><a href="#0-1背包问题升级版" class="headerlink" title="0-1背包问题升级版"></a>0-1背包问题升级版</h3><p>如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 背包选取的物品列表</span>picks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>picks_with_max_value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">bag</span><span class="token punctuation">(</span>i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> cw<span class="token punctuation">:</span> int<span class="token punctuation">,</span> items_info<span class="token punctuation">:</span> list<span class="token punctuation">,</span> w<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param i: 当前物品的索引    :param cw: 背包当前重量    :param items_info: 物品的重量和价值信息    :param w: 背包容量    :return:    """</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>items_info<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 考察完所有物品，或中途已经装满</span>    <span class="token keyword">if</span> cw <span class="token operator">==</span> w <span class="token operator">or</span> i <span class="token operator">==</span> n<span class="token punctuation">:</span>        <span class="token keyword">global</span> picks_with_max_value        <span class="token keyword">if</span> get_value<span class="token punctuation">(</span>items_info<span class="token punctuation">,</span> picks<span class="token punctuation">)</span> <span class="token operator">></span> get_value<span class="token punctuation">(</span>items_info<span class="token punctuation">,</span> picks_with_max_value<span class="token punctuation">)</span><span class="token punctuation">:</span>            picks_with_max_value <span class="token operator">=</span> picks<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 不选第i个物品</span>    picks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    bag<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cw<span class="token punctuation">,</span> items_info<span class="token punctuation">,</span> w<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 选第i个物品</span>    ncw <span class="token operator">=</span> cw <span class="token operator">+</span> items_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> ncw <span class="token operator">&lt;=</span> w<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 已经超过可以背包承受的重量的时候，就不要再装了</span>        picks<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        bag<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ncw<span class="token punctuation">,</span> items_info<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">get_value</span><span class="token punctuation">(</span>items_info<span class="token punctuation">:</span> list<span class="token punctuation">,</span> items_picks<span class="token punctuation">:</span> list<span class="token punctuation">)</span><span class="token punctuation">:</span>    values <span class="token operator">=</span> <span class="token punctuation">[</span>_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> items_info<span class="token punctuation">]</span>    <span class="token keyword">return</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>a <span class="token operator">*</span> b <span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> zip<span class="token punctuation">(</span>values<span class="token punctuation">,</span> items_picks<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># [(weight, value), ...]</span>    items_info <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    w <span class="token operator">=</span> <span class="token number">8</span>    picks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>items_info<span class="token punctuation">)</span>    bag<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> items_info<span class="token punctuation">,</span> w<span class="token punctuation">)</span>    max_value_select_list <span class="token operator">=</span> <span class="token punctuation">[</span>items_info<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>items_info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> picks_with_max_value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>max_value_select_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>23.分治算法</title>
      <link href="//post/23.%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html"/>
      <url>//post/23.%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>[TOC]</p><p>分治算法用四个字概括就是“分而治之”，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治算法的典型的两种应用场景，一个是用来指导编码，降低问题求解的时间复杂度；另一个是解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。</p><h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p>分治算法（divide and conquer）的核心思想就是分而治之 ，将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治算法一般都比较适合用递归来实现，<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。</p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ul><h1 id="分治算法应用举例"><a href="#分治算法应用举例" class="headerlink" title="分治算法应用举例"></a>分治算法应用举例</h1><h2 id="求数组的逆序对个数"><a href="#求数组的逆序对个数" class="headerlink" title="求数组的逆序对个数"></a>求数组的逆序对个数</h2><p>在排序算法里，我们用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p><p>假设有 n 个数据，数据从小到大排列后，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；</p><p>相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。</p><p>其他情况通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。<br>$$<br>\begin{array}{l}2,4,3,1,5,6 \quad 逆序对个数:4 \\ {(2,1)(4,3)(4,1)(3,1)}\end{array}<br>$$<br>计算逆序对个数最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的，把比它小的数字个数记作 k。把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。这样操作的时间复杂度是 $O(n^2)$。</p><p><strong>用分治的思想来求数组 A 的逆序对个数:</strong></p><p>将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p>使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。</p><p>计算两个子问题 A1 与 A2 之间的逆序对个数，可借助归并排序算法的归并思想。</p><p>在两个子数组合并的过程中，就可以计算两个子数组的逆序对个数了：</p><p><img src="imgs/2/1570503357732.png" alt="1570503357732"></p><p>java代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 全局变量或者成员变量</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">mergeSortCounting</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">mergeSortCounting</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token function">mergeSortCounting</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">mergeSortCounting</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> q<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">,</span> j <span class="token operator">=</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r<span class="token operator">-</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>q <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      num <span class="token operator">+=</span> <span class="token punctuation">(</span>q<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 统计 p-q 之间，比 a[j] 大的元素个数</span>      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的</span>    tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 处理剩下的</span>    tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token operator">-</span>p<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 从 tmp 拷贝回 a</span>    a<span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="求距离最近的两个点"><a href="#求距离最近的两个点" class="headerlink" title="求距离最近的两个点"></a>求距离最近的两个点</h2><p>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p><p>思路：</p><p>求n个点中距离最近的两个点，可以将n个点划分为两部分，分别求出n/2个点中最近的两个点，然后再从这4个点中求出距离最近的两个点。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token punctuation">,</span> math<span class="token keyword">from</span> typing <span class="token keyword">import</span> Tuple<span class="token keyword">def</span> <span class="token function">get_distance</span><span class="token punctuation">(</span>p1<span class="token punctuation">:</span> Tuple<span class="token punctuation">,</span> p2<span class="token punctuation">:</span> Tuple<span class="token punctuation">)</span><span class="token punctuation">:</span>    distance <span class="token operator">=</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>p1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># print(p1, p2, distance)</span>    <span class="token keyword">return</span> distance<span class="token keyword">def</span> <span class="token function">min_distance_point</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">:</span>    <span class="token keyword">if</span> r <span class="token operator">-</span> p <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">:</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>    pots <span class="token operator">=</span> min_distance_point<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> min_distance_point<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pots<span class="token punctuation">)</span>    min_distance <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize    pot1<span class="token punctuation">,</span> pot2 <span class="token operator">=</span> None<span class="token punctuation">,</span> None    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            distance <span class="token operator">=</span> get_distance<span class="token punctuation">(</span>pots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pots<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> distance <span class="token operator">&lt;</span> min_distance<span class="token punctuation">:</span>                min_distance <span class="token operator">=</span> distance                pot1<span class="token punctuation">,</span> pot2 <span class="token operator">=</span> pots<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pots<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>pot1<span class="token punctuation">,</span> pot2<span class="token punctuation">]</span>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>pot <span class="token operator">=</span> min_distance_point<span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>p1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> pot<span class="token keyword">print</span><span class="token punctuation">(</span>pot<span class="token punctuation">,</span> get_distance<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>比如，给 10GB 的订单文件按照金额排序，机器的内存可能只有 2GB，无法一次性加载到内存。</p><p>要解决这种数据量大到内存装不下的问题，可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。</p><p>先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起。不过，数据的存储与计算所在的机器必须是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><h2 id="为什么说-MapReduce-的本质就是分治思想？"><a href="#为什么说-MapReduce-的本质就是分治思想？" class="headerlink" title="为什么说 MapReduce 的本质就是分治思想？"></a>为什么说 MapReduce 的本质就是分治思想？</h2><p>如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>把任务拆分到多台机器上来处理，拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并，就是分治思想。</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>22.贪心算法</title>
      <link href="//post/22.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"/>
      <url>//post/22.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法：如何用贪心算法实现Huffman压缩编码？"><a href="#贪心算法：如何用贪心算法实现Huffman压缩编码？" class="headerlink" title="贪心算法：如何用贪心算法实现Huffman压缩编码？"></a>贪心算法：如何用贪心算法实现Huffman压缩编码？</h1><p>贪心算法（greedy algorithm），这种算法思想更多的是指导设计基础算法。贪心算法的经典应用有，霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、Dijkstra单源最短路径算法等。</p><p>贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h2><p>先看一个例子:</p><p>有一个可以容纳 100kg 物品的背包，可以装以下 5 种豆子，每种豆子装多少能够让背包中所装物品的总价值最大？</p><table><thead><tr><th>物品</th><th>重量(kg)</th><th>总价值(元)</th></tr></thead><tbody><tr><td>黄豆</td><td>100</td><td>100</td></tr><tr><td>绿豆</td><td>30</td><td>90</td></tr><tr><td>红豆</td><td>60</td><td>120</td></tr><tr><td>黑豆</td><td>20</td><td>80</td></tr><tr><td>青豆</td><td>50</td><td>75</td></tr></tbody></table><p>先计算每周豆子的单价，分别是黄豆1元/kg，绿豆3元/kg，红豆2元/kg，黑豆4元/kg，青豆1.5元/kg，单价从高到低排序依次是：黑豆、绿豆、红豆、青豆、黄豆。所以先从单价最高的装，20kg 黑豆、30kg 绿豆、50kg 红豆。</p><p>这个问题的解决思路本质上就是贪心算法。</p><p>贪心算法适合解决的问题：</p><p><strong>1.定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</strong></p><p>类比到刚刚的例子，限制值就是重量不能超过 100kg，期望值就是物品的总价值。这组数据就是 5 种豆子。我们从中选出一部分，满足重量不超过 100kg，并且总价值最大。</p><p><strong>2.每次都可以选择当前情况下在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</strong></p><p>类比到刚刚的例子，每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。</p><p><strong>3.举几个例子判断贪心算法产生的结果是否最优</strong></p><p>严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p><p>贪心算法解决问题的思路，并不总能给出最优解：</p><p>比如在一个有权图中，从顶点 S 开始，找一条到顶点 T 的最短路径（路径中边的权值和最小）。贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点 T。按照这种思路，求出的最短路径是 S-&gt;A-&gt;E-&gt;T，路径长度是 1+4+4=9。但路径 S-&gt;B-&gt;D-&gt;T 才是最短路径，路径长度是2+2+2=6。</p><p><img src="imgs/2/1570501134514.png" alt="1570501134514"></p><p>在这个问题上，贪心算法不工作的主要原因是，前面的选择，会影响后面的选择。如果第一步从顶点 S 走到顶点 A，那接下来面对的顶点和边，跟第一步从顶点 S 走到顶点 B，是完全不同的。所以，即便我们第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。</p><h1 id="贪心算法实例分析"><a href="#贪心算法实例分析" class="headerlink" title="贪心算法实例分析"></a>贪心算法实例分析</h1><h2 id="1-分糖果"><a href="#1-分糖果" class="headerlink" title="1. 分糖果"></a>1. 分糖果</h2><p>有 m 个糖果和 n 个孩子，但是m&lt;n。</p><p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。</p><p>每个孩子对糖果大小的需求不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p><p><strong>如何分配糖果，能尽可能满足最多数量的孩子？</strong></p><p>这个问题可抽象成，从 n 个孩子中，抽取一部分孩子分配m个糖果，让满足的孩子的个数（期望值）是最大的。</p><p><strong>限制值</strong>是糖果个数 m，<strong>期望</strong>是满足的孩子个数最大。</p><p>贪心算法解决思路：</p><p>对于一个孩子来说，如果小的糖果可以满足，就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。</p><p>另一方面，对糖果大小需求小的孩子更容易被满足。</p><p>因为满足一个需求大的孩子跟满足一个需求小的孩子，对期望值的贡献是一样的。</p><p>所以从需求小的孩子开始分配糖果。</p><p>故每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><h2 id="2-钱币找零"><a href="#2-钱币找零" class="headerlink" title="2. 钱币找零"></a>2. 钱币找零</h2><p>假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p><p><strong>贪心算法的解决思路：</strong></p><p>希望在相同纸币数目的情况下，多贡献点金额，这样就可以让纸币数更少。</p><p>即先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p><h2 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3. 区间覆盖"></a>3. 区间覆盖</h2><p>假设有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？<br>$$<br>\begin{array}{l}{\text { 区间: }[6,8][2,4][3,5][1,5][1,9][8,10]} \\ {\text { 不相交区间: }[2,4][6,8][8,10]}\end{array}<br>$$<br>贪心算法的解决思路：假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。</p><p>这个问题就抽象为选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上。</p><p>先按照起始端点从小到大的顺序对这 n 个区间排序。</p><p>每次选择左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的区间：</p><p> <img src="imgs/2/1570501292623.png" alt="1570501292623"></p><h1 id="如何用贪心算法实现霍夫曼编码？"><a href="#如何用贪心算法实现霍夫曼编码？" class="headerlink" title="如何用贪心算法实现霍夫曼编码？"></a>如何用贪心算法实现霍夫曼编码？</h1><p>假设有一个包含1000个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits。</p><p>假设通过统计分析发现，这 1000 个字符中只包含 6 种不同字符分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间每个字符只用 3 个二进制位来表示。那存储这 1000 个字符就减少到 3000bits ：</p><pre><code>a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</code></pre><p>而霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。</p><p>根据贪心的思想，把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p>对于等长的编码来说，每次读取 固定二进制码，然后翻译成对应的字符。但霍夫曼编码是不等长的，它要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</p><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。</p><p>把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀：</p><p><img src="imgs/2/1570501375909.png" alt="1570501375909"></p><p>在解压缩的时候，每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><p><strong>如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？</strong></p><p>把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><img src="imgs/2/1570501407500.png" alt="1570501407500"></p><p>然后给每一条边加上一个权值，指向左子节点的边统统标记为 0，指向右子节点的边统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="imgs/2/1570501425196.png" alt="1570501425196"></p><p>再以原始集合的值是[2,3,4,4,5,7]为例：</p><p> <img src="imgs/Huffman_algorithm.gif" alt="img"></p><p> 第一步：从原始集合中取出最小的两个值并将这两个值从原始集合中剔除，这两个最小的值相加得到一个新的值并加入原始集合，这一步执行之后原始集合就变成：[⑤,4,4,5,7]</p><p>第二步：从更新后的集合中再取最小的两个值并剔除，同样相加得到新值加入到集合。这一步执行之后集合就变成：[⑤,⑧,5,7]</p><p>第三步，重复以上步骤，结果是：[⑩,⑧,7]<br>第四步，结果是：[⑩,(15)]<br>最后一步，结果是： [(25)]</p><p>编码结果：</p><p> <img src="imgs/TABLE8.JPG" alt="img"> </p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1.在一个非负整数 a 中，希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？</p><p>答：</p><p>由最高位开始，比较低一位数字，若高位比低位大，则移除高位，否则指针右移一位继续比较两个数字，直到高位大于低位则移除高位。移除后重新从最高为开始比较，共循环k次移除k个数字，如：<br>4556847594546移除5位-》455647594546-》45547594546-》4547594546-》4447594546-》444594546</p><p>2.假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？</p><p>答：</p><p>每次从剩下的人中选择等待时间最短的人服务， 直到n个人都被服务完， n 个人总的等待时间就是最短。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>21.AC自动机</title>
      <link href="//post/21.AC%E8%87%AA%E5%8A%A8%E6%9C%BA.html"/>
      <url>//post/21.AC%E8%87%AA%E5%8A%A8%E6%9C%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>很多支持用户发表文本内容的网站，比如 BBS，大都会有敏感词过滤功能，用来过滤掉用户输入的一些淫秽、反动、谩骂等内容。</p><p>实际上，这些功能最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果有，就用“<em>*</em>”把它替代掉。</p><p>对于访问量巨大的网站来说，比如淘宝，用户每天的评论数有几亿、甚至几十亿。对敏感词过滤系统的性能要求就要很高。<strong>那如何才能实现一个高性能的敏感词过滤系统呢</strong>？AC自动机这种<strong>多模式串匹配算法</strong>是这个系统的原型。</p><h2 id="基于单模式串和Trie树实现的敏感词过滤"><a href="#基于单模式串和Trie树实现的敏感词过滤" class="headerlink" title="基于单模式串和Trie树实现的敏感词过滤"></a>基于单模式串和Trie树实现的敏感词过滤</h2><p><strong>单模式串匹配算法</strong>有 BF 算法、RK 算法、BM 算法、KMP 算法。</p><p><strong>多模式串匹配算法</strong>有 Trie 树。</p><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是，在一个主串中查找<strong>一个</strong>模式串。</p><p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是，在一个主串中查找<strong>多个</strong>模式串。</p><p>与单模式匹配算法相比，多模式匹配算法只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p><p>Trie 树就是一种多模式串匹配算法，用 Trie 树即可实现敏感词过滤功能：</p><p>对敏感词字典进行预处理，构建成 Trie 树结构，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，对多模式串 Trie 树进行改进的算法就是 AC 自动机。</p><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><p>AC 自动机算法，全称是 Aho-Corasick 算法。</p><p><strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong>。如果代码表示，就是下面这个样子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AcNode</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span>   <span class="token keyword">public</span> AcNode<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AcNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 字符集只包含 a~z 这 26 个字符</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 结尾字符为 true</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当 isEndingChar=true 时，记录模式串长度</span>  <span class="token keyword">public</span> AcNode fail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 失败指针</span>  <span class="token keyword">public</span> <span class="token function">AcNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ACNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>  <span class="token comment" spellcheck="true"># 字符集只包含 a~z 这 26 个字符</span>        self<span class="token punctuation">.</span>is_ending_char <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment" spellcheck="true"># 结尾字符为 true</span>        self<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment" spellcheck="true"># 当 isEndingChar=true 时，记录模式串长度</span>        self<span class="token punctuation">.</span>fail <span class="token operator">=</span> None  <span class="token comment" spellcheck="true"># 失败指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AC 自动机的构建，包含两个操作：</p><ul><li>将多个模式串构建成 Trie 树；</li><li>在Trie树上构建失败指针（相当于KMP中的失效函数 next 数组）。</li></ul><p><strong>构建好 Trie 树之后，如何在它之上构建失败指针？</strong></p><p>有 4 个模式串 c，bc，bcd，abcd；主串是 abcd。</p><p> <img src="imgs/2/1570500742068.png" alt="1570500742068"></p><p>Trie 树中的每一个节点都有一个失败指针，它的作用和构建过程，跟 KMP 算法中的 next 数组极其相似。</p><p>例如下图中abc的c节点的失败指针指向abc的最长可匹配后缀子串bc的最后一个节点c。</p><p> <img src="imgs/2/1570500755759.png" alt="1570500755759"></p><p>树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</p><p>求某个节点的失败指针，可以通过已经求得的、深度更小的那些节点的失败指针来推导。失败指针的构建过程，是一个按层遍历树的过程。</p><p>首先 root 的失败指针为 NULL，也就是指向自己。</p><p>假设节点 p 的失败指针指向节点 q，然后看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果 pc和qc对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><p><img src="imgs/2/1570500769943.png" alt="1570500769943"></p><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p><p><img src="imgs/2/1570500782819.png" alt="1570500782819"></p><p>构建失败指针的java描述代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildFailurePointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Queue<span class="token operator">&lt;</span>AcNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  root<span class="token punctuation">.</span>fail <span class="token operator">=</span> null<span class="token punctuation">;</span>  queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    AcNode p <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      AcNode pc <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pc <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> root<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        AcNode q <span class="token operator">=</span> p<span class="token punctuation">.</span>fail<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          AcNode qc <span class="token operator">=</span> q<span class="token punctuation">.</span>children<span class="token punctuation">[</span>pc<span class="token punctuation">.</span>data <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>qc <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> qc<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          q <span class="token operator">=</span> q<span class="token punctuation">.</span>fail<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">build_failure_pointer</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>root<span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            p<span class="token punctuation">:</span> ACNode <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> pc <span class="token keyword">in</span> p<span class="token punctuation">.</span>children<span class="token punctuation">:</span>                <span class="token keyword">if</span> pc <span class="token keyword">is</span> None<span class="token punctuation">:</span>                    <span class="token keyword">continue</span>                <span class="token keyword">if</span> p <span class="token operator">==</span> self<span class="token punctuation">.</span>root<span class="token punctuation">:</span>                    pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> self<span class="token punctuation">.</span>root                <span class="token keyword">else</span><span class="token punctuation">:</span>                    q <span class="token operator">=</span> p<span class="token punctuation">.</span>fail                    <span class="token keyword">while</span> q<span class="token punctuation">:</span>                        qc <span class="token operator">=</span> q<span class="token punctuation">.</span>children<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>pc<span class="token punctuation">.</span>_data<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                        <span class="token keyword">if</span> qc<span class="token punctuation">:</span>                            pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> qc                            <span class="token keyword">break</span>                        q <span class="token operator">=</span> q<span class="token punctuation">.</span>fail                    <span class="token keyword">if</span> q <span class="token keyword">is</span> None<span class="token punctuation">:</span>                        pc<span class="token punctuation">.</span>fail <span class="token operator">=</span> self<span class="token punctuation">.</span>root                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过层级遍历来计算每个节点的子节点的失效指针，上面的例子，最后构建完成之后的 AC 自动机就是下面这个样子：</p><p><img src="imgs/2/1570500806433.png" alt="1570500806433"></p><p><strong>在 AC 自动机上匹配主串的过程：</strong></p><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p><ul><li>如果 p 指向的节点有一个等于 b[i] 的子节点 x，就更新 p 指向 x，然后通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。</li><li>如果 p 指向的节点没有等于 b[i] 的子节点，那让p指向p的失败指针p=p-&gt;fail，继续这 2 个过程。</li></ul><p>java代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// text 是主串</span>  <span class="token keyword">int</span> n <span class="token operator">=</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  AcNode p <span class="token operator">=</span> root<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>fail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 失败指针发挥作用的地方</span>    <span class="token punctuation">}</span>    p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 如果没有匹配的，从 root 开始重新匹配</span>    AcNode tmp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 打印出可以匹配的模式串</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>isEndingChar <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pos <span class="token operator">=</span> i<span class="token operator">-</span>tmp<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 匹配起始下标 "</span> <span class="token operator">+</span> pos <span class="token operator">+</span> <span class="token string">"; 长度 "</span> <span class="token operator">+</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>fail<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">match</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""返回该字符串所有匹配的起始角标和字符串长度"""</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> i<span class="token punctuation">,</span> char <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>            idx <span class="token operator">=</span> ord<span class="token punctuation">(</span>char<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token keyword">is</span> None <span class="token operator">and</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>root<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>fail            p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>            <span class="token keyword">if</span> p <span class="token keyword">is</span> None<span class="token punctuation">:</span> p <span class="token operator">=</span> self<span class="token punctuation">.</span>root            tmp <span class="token operator">=</span> p            <span class="token keyword">while</span> tmp <span class="token operator">!=</span> self<span class="token punctuation">.</span>root<span class="token punctuation">:</span>                <span class="token keyword">if</span> tmp<span class="token punctuation">.</span>is_ending_char<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># print(f"匹配起始下标{i - tmp.length + 1}，长度{tmp.length}")</span>                    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> tmp<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>                tmp <span class="token operator">=</span> tmp<span class="token punctuation">.</span>fail        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="AC自动机实现敏感词过滤系统"><a href="#AC自动机实现敏感词过滤系统" class="headerlink" title="AC自动机实现敏感词过滤系统"></a>AC自动机实现敏感词过滤系统</h2><p>在上述代码基础上再遍历一遍文本内容（主串），就可以将文本中的所有敏感词替换成“<em>*</em>”：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">sensitive_word_filtered</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        filter_range_list <span class="token operator">=</span> self<span class="token punctuation">.</span>match<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        str_list <span class="token operator">=</span> list<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        <span class="token keyword">for</span> start<span class="token punctuation">,</span> length <span class="token keyword">in</span> filter_range_list<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> start <span class="token operator">+</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>                str_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"*"</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>str_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将敏感词构建成 AC 自动机，包括构建 Trie 树以及构建失败指针。 </p><p>Trie 树构建的时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。</p><p>构建失败指针的时间复杂度是O(k*len)，其中k表示Trie 树中总的节点个数。每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。</p><p><strong>用 AC 自动机做匹配的时间复杂度：</strong></p><p>for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)。</p><p>只有在极端情况下，AC 自动机的性能才会退化的跟 Trie 树一样：</p><p><img src="imgs/2/1570500850207.png" alt="1570500850207"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20.Trie树</title>
      <link href="//post/20.Trie%E6%A0%91.html"/>
      <url>//post/20.Trie%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="“Trie-树”的介绍"><a href="#“Trie-树”的介绍" class="headerlink" title="“Trie 树”的介绍"></a>“Trie 树”的介绍</h2><p>Trie 树也叫“字典树”，是一种专门处理字符串匹配的树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>Trie 树特有的优点，决定它特别适合做搜索引擎的搜索关键词提示功能：在搜索引擎的搜索框中，输入要搜索的文字的某一部分的时候，搜索引擎就会自动弹出下拉框，里面是各种关键词提示。可以直接从下拉框中选择你要搜索的东西，而不用把所有内容都输入进去，一定程度上节省了我们的搜索时间。</p><p>Trie 树到底长什么样子：</p><p>假设有 6 个字符串分别是：how，hi，her，hello，so，see，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p><p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。最后构造出来的就是下面这个图中的样子：</p><p><img src="imgs/2/1570500434769.png" alt="1570500434769"></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（红色节点并不都是叶子节点）。</p><p>Trie 树构造的过程：</p><p> <img src="imgs/2/1570500456458.png" alt="1570500456458"></p><p>在 Trie 树中查找字符串的时候，比如查找字符串“her”，先将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。下图中绿色的路径就是在 Trie 树中匹配的路径。</p><p><img src="imgs/2/1570500470544.png" alt="1570500470544"></p><p>要查找字符串“he”，先将要查找的字符串分割成单个的字符 h，e。然后从根节点开始沿着某条路径来匹配，下图绿色的路径就是“he”匹配的路径，但路径最后一个节点“e”并不是红色的（“he”是某个字符串的前缀子串），说明未匹配。</p><p><img src="imgs/2/1570500495719.png" alt="1570500495719"></p><h2 id="实现Trie-树"><a href="#实现Trie-树" class="headerlink" title="实现Trie 树"></a>实现Trie 树</h2><p>Trie 树主要有两个操作：</p><ol><li>将字符串插入到 Trie 树中</li><li>在 Trie 树中查询一个字符串</li></ol><p>Trie 树是一个多叉树，经典的存储方式是通过一个下标与字符一一映射的数组，来存储子节点的指针。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> data<span class="token punctuation">;</span>  BinaryTreeNode left<span class="token punctuation">;</span>  BinaryTreeNode right<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设字符串中只有从 a 到 z 这 26 个小写字母，可以设置一个固定大小为26的数组，下标 0 位置存储指向子节点 a 的指针，下标1位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置，存储指向的子节点 z 的指针。不存在的字符对应下标的位置存储 null。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> data<span class="token punctuation">;</span>  TrieNode children<span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> isEndingChar<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Trie 树中查找字符串的时候，就可以通过字符的ASCII码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。比如，d的ASCII码减去a的ASCII码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> TrieNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 存储无意义字符</span>  <span class="token comment" spellcheck="true">// 往 Trie 树中插入一个字符串</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> text<span class="token punctuation">)</span> <span class="token punctuation">{</span>    TrieNode p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> text<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> index <span class="token operator">=</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TrieNode newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span>isEndingChar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 在 Trie 树中查找一个字符串</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">)</span> <span class="token punctuation">{</span>    TrieNode p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> index <span class="token operator">=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不存在 pattern</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>isEndingChar<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">char</span> data<span class="token punctuation">;</span>    <span class="token keyword">public</span> TrieNode<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> isEndingChar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TrieNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        self<span class="token punctuation">.</span>is_ending_char <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> index<span class="token punctuation">,</span> char <span class="token keyword">in</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span>char<span class="token punctuation">)</span>            node <span class="token operator">=</span> node<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span>        node<span class="token punctuation">.</span>is_ending_char <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> index <span class="token keyword">in</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> ord<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>index<span class="token punctuation">]</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span>is_ending_char<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。</p><p>假设字符串长度是 k，Trie树查找某个字符串只需要比对大约 k 个节点，所以在Trie树查找某个字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p><h2 id="Trie-树的内存消耗"><a href="#Trie-树的内存消耗" class="headerlink" title="Trie 树的内存消耗"></a>Trie 树的内存消耗</h2><p>上面 Trie 树的实现，如果字符串中包含从 a 到 z 这 26 个字符，每个节点要维护一个长度为 26 的数组，每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。那每个节点就会额外需要 26*8=208 个字节。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。</p><p>针对这个问题可以稍微牺牲一点查询的效率，将每个节点中的数组换成有序数组、跳表、散列表、红黑树等数据结构，来存储一个节点的子节点指针。</p><p>将数组替换为有序数组的python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> c        <span class="token comment" spellcheck="true"># 使用有序数组，降低空间消耗，支持更多字符</span>        self<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>is_ending_char <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">insert_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""插入一个子节点"""</span>        node <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        idx <span class="token operator">=</span> self<span class="token punctuation">.</span>binary_search<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">if</span> idx <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>children<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>idx<span class="token punctuation">,</span> node<span class="token punctuation">)</span>        <span class="token keyword">return</span> node    <span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""二分查找，找到有序数组的插入位置"""</span>        start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        v <span class="token operator">=</span> ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>            <span class="token keyword">if</span> v <span class="token operator">==</span> ord<span class="token punctuation">(</span>self<span class="token punctuation">.</span>children<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">elif</span> v <span class="token operator">&lt;</span> ord<span class="token punctuation">(</span>self<span class="token punctuation">.</span>children<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>                end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 找不到返回-插入点-1</span>    <span class="token keyword">def</span> <span class="token function">has_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>get_child<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token operator">not</span> None    <span class="token keyword">def</span> <span class="token function">get_child</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""搜索子节点并返回"""</span>        idx <span class="token operator">=</span> self<span class="token punctuation">.</span>binary_search<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">if</span> idx <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> None  <span class="token comment" spellcheck="true"># 找不到返回None</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">'node value: %s'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">'\n'</span> \               <span class="token operator">+</span> <span class="token string">'children:%s'</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>children<span class="token keyword">class</span> <span class="token class-name">Trie</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text_list<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> text_list <span class="token keyword">is</span> None<span class="token punctuation">:</span>            text_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>root <span class="token operator">=</span> TrieNode<span class="token punctuation">(</span>None<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>insert_list<span class="token punctuation">(</span>text_list<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">insert_list</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text_list<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""批量插入节点"""</span>        <span class="token keyword">for</span> text <span class="token keyword">in</span> text_list<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>text<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> char <span class="token keyword">in</span> text<span class="token punctuation">:</span>            tmp <span class="token operator">=</span> node<span class="token punctuation">.</span>get_child<span class="token punctuation">(</span>char<span class="token punctuation">)</span>            <span class="token keyword">if</span> tmp <span class="token keyword">is</span> None<span class="token punctuation">:</span> tmp <span class="token operator">=</span> node<span class="token punctuation">.</span>insert_child<span class="token punctuation">(</span>char<span class="token punctuation">)</span>            node <span class="token operator">=</span> tmp        node<span class="token punctuation">.</span>is_ending_char <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>root        <span class="token keyword">for</span> char <span class="token keyword">in</span> pattern<span class="token punctuation">:</span>            child <span class="token operator">=</span> p<span class="token punctuation">.</span>get_child<span class="token punctuation">(</span>char<span class="token punctuation">)</span>            <span class="token keyword">if</span> child <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            p <span class="token operator">=</span> child        <span class="token keyword">return</span> p<span class="token punctuation">.</span>is_ending_char<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还同时可以使用<strong>缩点优化</strong>，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并：</p><p><img src="imgs/2/1570500591632.png" alt="1570500591632"></p><h2 id="Trie树的适用场景"><a href="#Trie树的适用场景" class="headerlink" title="Trie树的适用场景"></a>Trie树的适用场景</h2><p>关于字符串的匹配问题，对于精确匹配查找，这种问题更适合用散列表或者红黑树来解决。</p><p>对于查找前缀匹配的字符串，使用Trie树效率会更高。例如自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p><p>例如实现搜索关键词的提示功能：</p><p>假设关键词库由用户的热门搜索关键词组成，将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。</p><p>假设词库里只有 hello、her、hi、how、so、see 这 6 个关键词。当用户输入了字母 h 的时候，就把以 h 为前缀的 hello、her、hi、how 展示在搜索提示框内。当用户继续键入字母 e 的时候，就把以 he 为前缀的 hello、her 展示在搜索提示框内。</p><p><img src="imgs/2/1570500612306.png" alt="1570500612306"></p><p>其他问题：</p><ul><li>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？</li><li>像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>19.字符串匹配基础</title>
      <link href="//post/19.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80.html"/>
      <url>//post/19.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串匹配基础"><a href="#字符串匹配基础" class="headerlink" title="字符串匹配基础"></a>字符串匹配基础</h1><h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><p>编程语言提供的字符串查找函数，比如 Java 中的 indexOf()，Python 中的 find() 函数等，它们底层就是依赖接下来要讲的字符串匹配算法。</p><p>单模式字符串匹配算法有简单的BF 算法和 RK 算法，难懂的BM 算法和 KMP 算法。</p><p>多模式字符串匹配算法，就是在一个串中同时查找多个串，有 Trie 树和 AC 自动机。</p><p>BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p>RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。</p><h1 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h1><p>BF （Brute Force）算法，中文叫作暴力匹配算法，也叫朴素匹配算法。这种算法的字符串匹配方式很“暴力”，比较简单、好懂，但相应的性能也不高。</p><p><strong>主串</strong>和<strong>模式串</strong>的概念:比如在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。</p><p>设主串的长度为n，模式串的长度为m，因为在主串中查找模式串，所以 n&gt;m。</p><p>BF 算法的思想就是，穷举主串中起始位置分别是 0、1、2…、n-m 且长度为 m 的 n-m+1 个子串，看有没有跟长度为m的模式串匹配的：</p><p><img src="imgs/2/1570498286430.png" alt="1570498286430"></p><p>BF 算法每次都比对 m 个字符，最坏情况下要比对 n-m+1 次，所以最坏情况时间复杂度是 O(n*m)。</p><p>BF 算法虽然相对其他字符串匹配算法，时间复杂度高，但却是一个最常用的字符串匹配算法，因为大部分情况下，模式串和主串的长度都不会太长。另外BF算法思想简单，代码实现简单不容易出错，即使有 bug 也容易暴露和修复。</p><p>在工程中，在满足性能要求的前提下，简单是首选。这也是<a href="https://zh.wikipedia.org/wiki/KISS原则" target="_blank" rel="noopener">KISS（Keep it Simple and Stupid）设计原则</a>。</p><p>所以，绝大部分情况下，BF 朴素的字符串匹配算法就够用了。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bf</span><span class="token punctuation">(</span>main<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""bf暴搜    :param main: 主串    :param pattern: 模式串    :return:    """</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> pattern <span class="token operator">==</span> main <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> main<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">break</span>            <span class="token keyword">if</span> j <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> i    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h1><p>RK(Rabin-Karp) 算法由它的两位发明者 Rabin 和 Karp 的名字来命名。它算是BF算法的升级版。</p><p>RK 算法的思路：</p><p>先通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就再对比一下子串和模式串本身。如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的。</p><p>因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><p><img src="imgs/2/1570498355108.png" alt="1570498355108"></p><p>哈希算法的设计的非常有技巧，假设要处理的字符串只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p><p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那就用二十六进制来表示一个字符串，把 a～z 这 26 个字符映射到 0～25 这 26 个数字中：<br>$$<br>\begin{aligned}<br>‘cba’&amp;=’c’<em>26</em>26+’b’<em>26+’a’</em>1 \<br> &amp;=2<em>26</em>26+1<em>26+0</em>1 \<br> &amp;=1353<br>\end{aligned}<br>$$<br><img src="imgs/2/1570498417310.png" alt="1570498417310"></p><p>相邻两个子串 s[i-1] 和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，可以使用 s[i-1] 的哈希值计算出 s[i] 的哈希值：</p><p><img src="imgs/2/1570498447098.png" alt="1570498447098"></p><p>$26^{m-1}$ 这部分的计算可以通过查表的方法来提高效率，事先计算好 $26^0、26^1、26^2、\dots、26^{m-1}$，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p><p><img src="imgs/2/1570498470428.png" alt="1570498470428"></p><p>整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。</p><p>计算子串哈希值可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。</p><p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。</p><p>RK 算法整体的时间复杂度就是 O(n)。</p><p>如果模式串很长，上面的哈希算法计算得到的哈希值可能超过计算机中整型数据的表示范围，这时就必须允许哈希冲突。</p><p>哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。</p><p>可以将每一个字母从小到大对应一个素数，然后将这些素数求和作为哈希值，这样数据范围就会相对上面的方法小很多，哈希冲突的概率也比较小。</p><p>简易python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">simple_hash</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">:</span>    ret <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ret <span class="token operator">+=</span> ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ret<span class="token keyword">def</span> <span class="token function">rk</span><span class="token punctuation">(</span>main<span class="token punctuation">,</span> pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""rk搜索算法    :param main: 主串    :param pattern: 模式串    :return:    """</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> pattern <span class="token operator">==</span> main <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 子串哈希值表</span>    h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    h<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> simple_hash<span class="token punctuation">(</span>main<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        h<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span>main<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> ord<span class="token punctuation">(</span>main<span class="token punctuation">[</span>i <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 模式串哈希值</span>    hash_p <span class="token operator">=</span> simple_hash<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> h <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 可能存在哈希冲突</span>        <span class="token keyword">if</span> h <span class="token operator">==</span> hash_p<span class="token punctuation">:</span>            <span class="token keyword">if</span> pattern <span class="token operator">==</span> main<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i <span class="token operator">+</span> m<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> i    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二维字符串查找"><a href="#二维字符串查找" class="headerlink" title="二维字符串查找"></a>二维字符串查找</h1><p><strong>如何在一个二维字符串矩阵中查找另一个二维字符串矩阵（图中的模式串）呢？</strong></p><p><img src="imgs/2/1570498502925.png" alt="1570498502925"></p><p>假设二维主串和模式串的维度分别是 $m<em>n$ 和 $i</em>j$，横向在[0, m-i]，纵向在[0, n-j]取起始点，然后取同样大小的子串窗口对比，共有(m-i+1)*(n-j+1)个子串，再用BM或RK算法进行逐个比较即可。</p><h1 id="BM-算法"><a href="#BM-算法" class="headerlink" title="BM 算法"></a>BM 算法</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>BM（Boyer-Moore）算法，是一种非常高效的字符串匹配算法，原理很复杂，有实验统计它的性能是著名的<a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">KMP 算法</a>的 3 到 4 倍。</p><p>模式串和主串的匹配过程可以看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，</p><p>BF 算法和 RK 算法的做法是模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配：</p><p><img src="imgs/2/1570498760377.png" alt="1570498760377"></p><p>而BM算法则是根据规则，跳过一些肯定不会匹配的情况，一次性把模式串往后多滑动几位:</p><p><img src="imgs/2/1570498774667.png" alt="1570498774667"></p><p>BF和RK算法按模式串的下标从小到大的顺序，依次与主串中的字符进行匹配的。</p><p>而 BM 算法是按照模式串下标从大到小的顺序，倒着匹配的：</p><p><img src="imgs/2/1570498799523.png" alt="1570498799523"></p><p>BM 算法包含<strong>坏字符规则</strong>（bad character rule）和<strong>好后缀规则</strong>（good suffix shift）。</p><p>模式串的末尾最后一个字符如果无法匹配，这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符），此时使用<strong>坏字符规则</strong>进行滑动。</p><p>模式串的末尾最后一个字符可以匹配，末尾最大可匹配字符串称为好后缀，此时使用<strong>好后缀规则</strong>进行滑动。</p><h2 id="1-坏字符规则"><a href="#1-坏字符规则" class="headerlink" title="1. 坏字符规则"></a>1. 坏字符规则</h2><p>如下图，发现模式串末尾字符d跟主串末尾字符c无法匹配，则主串末尾字符c是坏字符。</p><p>拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，这时可以将模式串直接往后滑动到坏字符c 后面的位置，继续匹配：</p><p><img src="imgs/2/1570498845772.png" alt="1570498845772"></p><p>这时坏字符 a 在模式串中是存在的，则将模式串滑动到让两个 a 上下对齐，如果坏字符在模式串出现多次，则将模式串最后出现的坏字符与主串中的坏字符对齐：</p><p><img src="imgs/2/1570498875778.png" alt="1570498875778"></p><p>假设模式串末尾角标si，坏字符最后一次在模式串出现的位置是xi（未出现记为-1）</p><p>则模式串往后移动的位数等于 si-xi。</p><p><img src="imgs/2/1570498905387.png" alt="1570498905387"></p><p>BM 算法单纯使用坏字符规则，在最好情况下的时间复杂度是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位。</p><h2 id="2-好后缀规则"><a href="#2-好后缀规则" class="headerlink" title="2. 好后缀规则"></a>2. 好后缀规则</h2><p>如果模式串和主串末尾的字符可以匹配，则最大可匹配字符bc是好后缀：</p><p><img src="imgs/2/1570498935264.png" alt="1570498935264"></p><p>将好后缀bc记作{u}。如果在模式串中可以找到其他匹配{u}的子串，将最后一个匹配的子串记为{u*}。</p><p>将模式串滑动到{u*}与主串的{u}对齐的位置：</p><p><img src="imgs/2/1570498956983.png" alt="1570498956983"></p><p>如果在模式串中找不到另一个可以匹配{u}的子串，此时还需要根据主串{u}的后缀子串和模式串的前缀子串是否匹配分两种情况。比如 abc 的后缀子串有c和bc，前缀子串有 a和ab。</p><p>如果主串{u}的后缀子串和模式串的前缀子串能够匹配，则将最长的能够匹配的部分记为{v}。然后可以将模式串滑动到如下图所示的位置：</p><p><img src="imgs/2/1570499030429.png" alt="1570499030429"></p><p>1.模式串的任何前缀子串也无法与{u}的任何后缀子串匹配，则可以将模式串滑动到{u}后面的位置：</p><p><img src="imgs/2/1570498975996.png" alt="1570498975996"></p><p>2.模式串的前缀子串{v}与{u}的后缀子串匹配，则可以将模式串滑动到模式串的前缀子串与主串{u}的后缀子串对齐的位置：</p><p><img src="imgs/2/1570498996673.png" alt="1570498996673"></p><h2 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h2><p>为了快速查找坏字符在模式串中出现的位置，可以将每个坏字符对应的角标位置存储在散列表中，键为字符，值为坏字符在模式串最后一次出现的位置。</p><p>假设字符串的字符集是 ASCII 码值，可以用大小为 256 的数组实现散列表，用数组的下标来代表字符的ASCII 码值，具体存储坏字符在模式串中最后一次出现的位置。如果字符串的字符集范围非常大，就使用常规方法实现散列表。</p><p><img src="imgs/2/1570499071780.png" alt="1570499071780"></p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">generate_bc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""生成坏字符位置表"""</span>    bc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">256</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>        bc<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">return</span> bc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面先用python实现坏字符规则：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bm</span><span class="token punctuation">(</span>main<span class="token punctuation">:</span> str<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> main <span class="token operator">==</span> pattern <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># bc为坏字符位置表</span>    bc <span class="token operator">=</span> generate_bc<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># i表示在主串中的角标</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> m<span class="token punctuation">:</span>        j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># j表示在模式串中的角标</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> main<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># j此时表示坏字符首次出现的位置</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 坏字符出现在模式串尾部，使用坏字符规则</span>            i <span class="token operator">+=</span> j <span class="token operator">-</span> bc<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>main<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">elif</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#已经匹配成功</span>            <span class="token keyword">return</span> i        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 尾部是好后缀，使用好后缀规则</span>            <span class="token keyword">pass</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了快速查找跟好后缀{u}最后一个相匹配的后缀子串{u*}，将后缀子串的长度和相匹配的{u*}位置保存起来。</p><p>用suffix 数组来保存，下标表示后缀子串的长度，值存储在模式串中跟好后缀{u}最后一个相匹配的子串{u*}的起始下标值。</p><p>另外用boolean类型的prefix 数组存储该长度的后缀是否与前缀匹配。</p><p><img src="imgs/2/1570499164110.png" alt="1570499164110"></p><p>计算过程：拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。</p><p>如果公共后缀子串的长度是 k，就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，公共后缀子串也是模式串的前缀子串，就记录 prefix[k]=true。</p><p><img src="imgs/2/1570499179335.png" alt="1570499179335"></p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">generate_gs</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> List<span class="token punctuation">[</span>bool<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    suffix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    prefix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># pattern[:i+1]和pattern的公共后缀长度</span>        j <span class="token operator">=</span> i        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>m <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>            suffix<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> j            k <span class="token operator">+=</span> <span class="token number">1</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> prefix<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> suffix<span class="token punctuation">,</span> prefix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设好后缀的长度是 k。</p><p>如果 suffix[k] 不等于 -1，就将模式串往后滑动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。</p><p><img src="imgs/2/1570499211481.png" alt="1570499211481"></p><p>如果 suffix[k] 等于 -1，并且在prefix数组[k,1]的范围中查找到prefix[r]=true(第一个找到的)，此时将模式串滑动m-r位即可。未找到时r=0:</p><p><img src="imgs/2/1570499239474.png" alt="1570499239474"></p><p>BM算法的python完整版代码实现:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">bm</span><span class="token punctuation">(</span>main<span class="token punctuation">:</span> str<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> main <span class="token operator">==</span> pattern <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># bc为坏字符位置表</span>    bc <span class="token operator">=</span> generate_bc<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># suffix为好后缀匹配的{u*}位置表,prefix为前缀匹配表</span>    suffix<span class="token punctuation">,</span> prefix <span class="token operator">=</span> generate_gs<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    i <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># i表示在主串中的角标</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> n <span class="token operator">-</span> m<span class="token punctuation">:</span>        j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># j表示在模式串中的角标</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> main<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># j此时表示坏字符首次出现的位置</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 坏字符出现在模式串尾部，使用坏字符规则</span>            i <span class="token operator">+=</span> j <span class="token operator">-</span> bc<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>main<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">elif</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 已经匹配成功</span>            <span class="token keyword">return</span> i        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 尾部是好后缀，使用好后缀规则</span>            k <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> j  <span class="token comment" spellcheck="true"># 好后缀的长度</span>            <span class="token keyword">if</span> suffix<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 整个好后缀在pattern剩余字符中仍有出现</span>                i <span class="token operator">+=</span> j <span class="token operator">-</span> suffix<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                r <span class="token operator">=</span> k                <span class="token keyword">while</span> r <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> <span class="token operator">not</span> prefix<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">:</span>                    r <span class="token operator">-=</span> <span class="token number">1</span>                i <span class="token operator">+=</span> m <span class="token operator">-</span> r    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">def</span> <span class="token function">generate_bc</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""生成坏字符位置表"""</span>    bc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">256</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>        bc<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">return</span> bc<span class="token keyword">def</span> <span class="token function">generate_gs</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> List<span class="token punctuation">[</span>bool<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    suffix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    prefix <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        k <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># pattern[:i+1]和pattern的公共后缀长度</span>        j <span class="token operator">=</span> i        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>m <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">:</span>            suffix<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> j            k <span class="token operator">+=</span> <span class="token number">1</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> prefix<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> suffix<span class="token punctuation">,</span> prefix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p><strong>K</strong>nuth-<strong>M</strong>orris-<strong>P</strong>ratt 字符串查找算法，简称为 <strong>KMP算法</strong>，用于在一个主串S内查找一个模式串P的出现位置。</p><p>这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。</p><p>KMP 算法的核心思想是在模式串和主串匹配的过程中，每当遇到坏字符后，对于已经比对过的好前缀，根据某种规律将模式串一次性滑动很多位。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong>。</p><p><img src="imgs/2/1570499479897.png" alt="1570499479897"></p><p>在好前缀本身的所有后缀子串中，查找最长的可以跟好前缀的前缀子串匹配的。假设最长的可匹配的前缀子串是{v}，长度是 k。每次遇到坏字符的时候就把 j 更新为 k，i 不变，然后继续比较。相当于把模式串一次性往后滑动 j-k 位。</p><p><img src="imgs/2/1570499526476.png" alt="1570499526476"></p><p><strong>前缀</strong> 指除了最后一个字符以外，一个字符串的全部头部组合；<strong>后缀</strong> 指除了第一个字符以外，一个字符串的全部尾部组合。 </p><p>为了表述起来方便，将好前缀的所有后缀子串中，最长的前缀子串匹配的后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p><p><img src="imgs/2/1570499540559.png" alt="1570499540559"></p><p>以模式串abaabcac为例，列出模式串 P 的所有子串：</p><p>a<br>ab<br>aba<br>abaa<br>abaab<br>abaabc<br>abaabca<br>abaabcac</p><p>求得模式串 P 的每一个子串对应的各个前缀后缀的公共元素的 <strong>最大长度表</strong> :</p><p> <img src="imgs/1572778109574.png" alt="1572778109574"></p><p>很多教材称next 数组叫<strong>失效函数</strong>（failure function），但每本教材对next函数定义的细节都有差别。</p><p>根据<strong>最大长度表</strong> 去求 <strong>next 数组</strong>：<strong>next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</strong>。</p><p> <img src="imgs/1572782164334.png" alt="1572782164334"></p><p>操作流程：</p><ul><li>假设现在主串 M 匹配到 i 位置，模式串 P 匹配到 j 位置</li><li>如果 j = -1，或者当前字符匹配成功（即 M[i] == P[j] ），都令 i++，j++，继续匹配下一个字符；</li><li>如果 j != -1，且当前字符匹配失败（即 M[i] != P[j] ），则令 i 不变，j = next[j]。<br> 匹配失败时，模式串 P相对于主串 M 向右移动了 j - next [j] 位</li><li>换言之，将模式串 P 失配位置的 next 数组的值对应的模式串 P 的索引位置移动到失配处</li></ul><p>假设 next 数组已经计算好了，KMP 算法的python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">kmp</span><span class="token punctuation">(</span>main<span class="token punctuation">:</span> str<span class="token punctuation">,</span> pattern<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""kmp字符串匹配"""</span>    n<span class="token punctuation">,</span> m <span class="token operator">=</span> len<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span> <span class="token keyword">if</span> main <span class="token operator">==</span> pattern <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token comment" spellcheck="true"># 求解next数组</span>    next <span class="token operator">=</span> get_next<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> n <span class="token operator">and</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> main<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># j!=-1 and main[i]!=pattern[j]</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">if</span> j <span class="token operator">==</span> m<span class="token punctuation">:</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速求出next-数组的方法"><a href="#快速求出next-数组的方法" class="headerlink" title="快速求出next 数组的方法"></a>快速求出next 数组的方法</h2><p>假设已经求得abaa这一列的<strong>最大公共前后缀</strong>的<strong>长度</strong>为1，在它后面添加一个与前缀匹配的字符即可使最大公共前后缀变长。</p><p>即下一列添加的字符与当前列的<strong>最大公共前后缀</strong>的<strong>长度</strong>后面的字符一样，则<strong>最大公共前后缀长度</strong>的<strong>长度</strong>加1。</p><p>但如果下一列添加的字符与当前列的<strong>最大公共前后缀</strong>的<strong>长度</strong>后面的字符不一样，则<strong>最大公共前后缀长度</strong>的<strong>长度</strong>置为0，重新开始判断：</p><p> <img src="imgs/1572834037956.png" alt="1572834037956"></p><p> python 语言描述为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_maxL</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    maxL <span class="token operator">=</span> <span class="token number">0</span>    max_l_arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>maxL<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            maxL <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>maxL<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            maxL <span class="token operator">+=</span> <span class="token number">1</span>        max_l_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxL    <span class="token keyword">return</span> max_l_arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再将max_l_arr数组整体右移一位，并将头部初始化为-1，将以上代码修改为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_next_arr</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    maxL <span class="token operator">=</span> <span class="token number">0</span>    next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>maxL<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            maxL <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">if</span> pattern<span class="token punctuation">[</span>maxL<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            maxL <span class="token operator">+=</span> <span class="token number">1</span>        next<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> maxL    <span class="token keyword">return</span> next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种求解思路是<strong>将求next数组的过程看成字符串匹配的过程</strong>：以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。</p><p>从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值：</p><p><img src="imgs/1572834957032.png" alt="1572834957032"></p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_next</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""next数组生成"""</span>    m <span class="token operator">=</span> len<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>    next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> m    i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            i <span class="token operator">+=</span> <span class="token number">1</span>            j <span class="token operator">+=</span> <span class="token number">1</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j        <span class="token keyword">else</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h2><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。</p><p>KMP 算法包含两部分，第一部分是构建 next 数组，第二部分是借助 next 数组进行匹配。</p><p>构建 next 数组，仅一层循环，循环次数跟模式串长度m有关，所以构建 next 数组的时间复杂度是 O(m)。借助 next 数组进行匹配，while循环代码如下：</p><pre class="line-numbers language-python"><code class="language-python">i<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token keyword">while</span> i <span class="token operator">&lt;</span> n <span class="token operator">and</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">:</span>    <span class="token keyword">if</span> j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">or</span> main<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>        i <span class="token operator">+=</span> <span class="token number">1</span>        j <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># j!=-1 and main[i]!=pattern[j]</span>        j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>i 从 0 循环增长到 n-1，j 的总增长量与 i一致也为n。j = next[j]让 j 的值减少，但总减少量不会超过总增长量n。所以 while 循环的循环次数小于2n，借助 next 数组进行匹配的时间复杂度是 O(n)。</p><p>故综合两部分的时间复杂度，KMP 算法的时间复杂度是 O(m+n)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>18.深度和广度优先搜索</title>
      <link href="//post/18.%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html"/>
      <url>//post/18.%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><h1 id="“搜索”算法"><a href="#“搜索”算法" class="headerlink" title="“搜索”算法"></a>“搜索”算法</h1><p>深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构。</p><p>图上的搜索算法就是，在图中找出从一个顶点出发，到另一个顶点的路径。图上的搜索算法有深度优先、广度优先搜索算法，和$A<em>$、$IDA</em>$ 等启发式搜索算法。</p><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，仅适用于状态空间不大的搜索。它们比$A<em>$、$IDA</em>$ 等启发式搜索算法要简单粗暴，没有什么优化，所以也叫作暴力搜索算法。</p><p>广度优先搜索，采用地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是起始顶点到终止顶点的最短路径。</p><p>深度优先搜索，采用回溯思想，适合用递归或栈来实现。遍历得到的路径并不是最短路径。</p><p>深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度都是 O(V)。其中E代表边，O代表顶点。</p><p>下面java语言实现用邻接表来存储无向图：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 无向图</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 顶点的个数</span>  <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> adj<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 邻接表</span>  <span class="token keyword">public</span> <span class="token function">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>    adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 无向图一条边存两次</span>    adj<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    adj<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），简称 BFS。它是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索：</p><p><img src="imgs/2/1570497713857.png" alt="1570497713857"></p><p>下面的java代码实现基于上面Graph的定义：</p><p>bfs() 函数用于搜索一条从 s 到 t 的最短路径，其中 s 表示起始顶点，t 表示终止顶点。</p><p><strong>visited</strong>是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q] 会被设置为 true。</p><p><strong>queue</strong>是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。</p><p><strong>prev</strong>用来记录搜索路径。prev[w] 存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，通过顶点 2 的邻接表访问到顶点 3，那 prev[3] 就等于 2。为了正向打印出路径需要递归地来打印。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>  visited<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>  Queue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prev <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> w <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> q <span class="token operator">=</span> adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        prev<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">print</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        visited<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prev<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 递归打印 s->t 的路径</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> s<span class="token punctuation">,</span> prev<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>广度优先搜索过程分解图：</p><p><img src="imgs/2/1570497928999.png" alt="1570497928999"></p><p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次。</p><p>假设顶点的个数为V，边的个数为E，那么广度优先搜索的时间复杂度是 O(V+E)。对于连通图（所有顶点都是连通的）来说，E &gt;= V-1，所以，广度优先搜索的时间复杂度可以简写为 O(E)。</p><p>广度优先搜索的空间消耗主要在辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称 DFS。</p><p>最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>下图中，搜索的起始顶点是 s，终止顶点是 t，希望在图中寻找一条从顶点 s 到顶点 t 的路径。如果映射到迷宫那个例子，s 就是你起始所在的位置，t 就是出口。</p><p>下图标记了递归算法的搜索的过程，里面实线箭头表示遍历，虚线箭头表示回退。但深度优先搜索最先找出来的路径，并不是顶点 s 到顶点 t 的最短路径。</p><p><img src="imgs/2/1570497975150.png" alt="1570497975150"></p><p>深度优先搜索用的是回溯思想，回溯思想非常适合用递归来实现。</p><p>下面是java代码实现，其中的 prev、visited 变量跟广度优先搜索的作用一样，变量found的作用是已经找到终止顶点 t 之后，就不再递归地继续查找了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 全局变量或者类成员变量</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>  found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prev <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> v<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">recurDfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">print</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">recurDfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>found <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      prev<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> w<span class="token punctuation">;</span>      <span class="token function">recurDfs</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> t<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> prev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。因为每条边最多会被访问两次，一次是遍历，一次是回退。</p><p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度是 O(V)。</p><h1 id="如何找出社交网络中的三度好友关系？"><a href="#如何找出社交网络中的三度好友关系？" class="headerlink" title="如何找出社交网络中的三度好友关系？"></a>如何找出社交网络中的三度好友关系？</h1><p><a href="https://zh.wikipedia.org/wiki/六度分隔理论" target="_blank" rel="noopener">六度分割理论</a>说你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p><p>一个用户的一度连接用户就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。</p><p><strong>如何找出一个用户的所有三度（其中包含一度、二度和三度）好友关系？</strong></p><p>答：</p><p>社交网络可以用图来表示。用图的广度优先搜索算法遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系。用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系。</p><p>也可以用深度优先搜索来解决这个问题，将递归的终止条件改为距离大于3.</p><h1 id="如何将迷宫抽象成图并存储在计算机中？"><a href="#如何将迷宫抽象成图并存储在计算机中？" class="headerlink" title="如何将迷宫抽象成图并存储在计算机中？"></a>如何将迷宫抽象成图并存储在计算机中？</h1><p>答：</p><p>为迷宫建立二维坐标系，这样每个 分叉路口都会在这个2维坐标系上有一个唯一的坐标。</p><p>将所有的分叉路口的坐标作为顶点， 相邻顶点之间连成边，构成一张无向图。</p><p>使用散列表来存储，键为所有顶点， 值为该顶点的相邻顶点链表（可将链表替换为有序数组、红黑树或跳表）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>17.图的表示</title>
      <link href="//post/17.%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.html"/>
      <url>//post/17.%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h1 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h1><p><strong>图</strong>（Graph）和树比起来，是一种更加复杂的非线性表结构。</p><h2 id="顶点-amp-边"><a href="#顶点-amp-边" class="headerlink" title="顶点&amp;边"></a>顶点&amp;边</h2><p>树中的元素称为节点，图中的元素叫作<strong>顶点</strong>（vertex）。图一个顶点可以与任意其他顶点建立连接关系，这种建立的关系叫<strong>边</strong>（edge）。</p><p><img src="imgs/2/1570497121476.png" alt="1570497121476"></p><p>在微信中，可以把每个用户看作一个顶点，两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度</strong>（degree），就是跟顶点相连接的边的条数。</p><h2 id="有向图-amp-无向图"><a href="#有向图-amp-无向图" class="headerlink" title="有向图&amp;无向图"></a>有向图&amp;无向图</h2><p>微博允许单向关注，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。如果用户 A 关注了用户 B，就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。</p><p>这种边有方向的图叫作<strong>“有向图”</strong>。边没有方向的图就叫作<strong>“无向图”</strong>。</p><p><img src="imgs/2/1570497151653.png" alt="1570497151653"></p><p>无向图中的“度”表示一个顶点有多少条边，在有向图中度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。</p><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。</p><p>对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><h2 id="带权图"><a href="#带权图" class="headerlink" title="带权图"></a>带权图</h2><p>QQ还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。在<strong>带权图</strong>（weighted graph）中，每条边都有一个权重（weight），可以通过这个权重来表示 QQ 好友间的亲密度。</p><p><img src="imgs/2/1570497174693.png" alt="1570497174693"></p><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h2><p><strong>邻接矩阵</strong>（Adjacency Matrix）的底层依赖一个二维数组。</p><p>对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将$A[i][j]$和$A[j][i]$标记为 1；</p><p>对于有向图来说，如果顶点 i 指向顶点 j 就将$A[i][j]$标记为1。同理，如果顶点 j 指向顶点 i 就将$A[j][i]$标记为 1。对于带权图，数组中就存储相应的权重。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 $A[i][j]$ 和 $A[j][i]$ 标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 $A[i][j]$ 标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 $A[j][i]$ 标记为 1。对于带权图，数组中就存储相应的权重。</p><p><img src="imgs/2/1570497255139.png" alt="1570497255139"></p><p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。为什么这么说呢？</p><p>对于无向图来说，如果 $A[i][j]$ 等于 1，那 $A[j][i]$ 也肯定等于 1，只需要存储上三角矩阵或下三角矩阵可以节省一半的空间。</p><p><strong>稀疏图</strong>（Sparse Matrix）是指每个顶点的边不多的图，用邻接矩阵的存储方法会非常浪费空间。</p><p>比如微信有好几亿的用户，对应到图上有好几亿的顶点，但每个用户的好友一般也就三五百个。如果用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p><p>但邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径的<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall算法" target="_blank" rel="noopener">Floyd-Warshall 算法</a>，就是利用矩阵循环相乘若干次得到结果。</p><h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><p><strong>邻接表</strong>（Adjacency List）的每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p><p>无向图可以看作每条边都是双方向的有向图。</p><p><img src="imgs/2/1570497334285.png" alt="1570497334285"></p><p>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。这是时间、空间复杂度互换的设计思想，前者是空间换时间，后者是时间换空间。</p><p>上图邻接表的例子中，如果要确定是否存在一条从顶点 2 到顶点 4 的边，就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。当然如果链过长，可以将链表换成红黑树、跳表、散列表等来提高查找效率，还可以将链表改成有序动态数组，通过二分查找的方法来快速定位两个顶点之间否存在边。</p><h2 id="如何存储微博、微信等社交网络中的好友关系？"><a href="#如何存储微博、微信等社交网络中的好友关系？" class="headerlink" title="如何存储微博、微信等社交网络中的好友关系？"></a>如何存储微博、微信等社交网络中的好友关系？</h2><p>假设需要支持下面这几个操作：</p><ul><li>判断用户 A 是否关注了用户 B；</li><li>判断用户 A 是否是用户 B 的粉丝；</li><li>用户 A 关注用户 B；</li><li>用户 A 取消关注用户 B；</li><li>根据用户名称的首字母排序，分页获取用户的粉丝列表；</li><li>根据用户名称的首字母排序，分页获取用户的关注列表。</li></ul><p>用两个邻接表来存储，一个邻接表存储某个用户关注了哪些用户，即用户的关注关系；另一个邻接表称为逆邻接表存储某个用户被哪些用户关注，即用户的粉丝列表。</p><p>如果要查找某个用户关注了哪些用户，在邻接表中查找即可；如果要查找某个用户被哪些用户关注了，从逆邻接表中查找即可。</p><p><img src="imgs/2/1570497356895.png" alt="1570497356895"></p><p>因为需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表替换邻接表中的链表比较合适。</p><p>跳表插入、删除、查找时间复杂度都是O(logn)，空间复杂度上是 O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。</p><p>如果对于小规模的数据，可以将整个社交关系存储在内存中。</p><p>如果对于大规模的数据，可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。</p><p>例如：</p><p><img src="imgs/2/1570497374244.png" alt="1570497374244"></p><p>当要查询顶点与顶点关系的时候，就利用同样的哈希算法，先定位顶点所在的机器再在相应的机器上查找。</p><p>另外一种解决思路，就是利用外部存储（比如硬盘），数据库是经常用来持久化存储关系数据的</p><p>用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，可以在表上建立这两列都建立索引。</p><table><thead><tr><th align="center">user_id</th><th align="center">follower_id</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>4</strong></td></tr><tr><td align="center"><strong>2</strong></td><td align="center"><strong>1</strong></td></tr><tr><td align="center"><strong>2</strong></td><td align="center"><strong>4</strong></td></tr><tr><td align="center"><strong>3</strong></td><td align="center"><strong>2</strong></td></tr><tr><td align="center"><strong>3</strong></td><td align="center"><strong>5</strong></td></tr><tr><td align="center"><strong>4</strong></td><td align="center"><strong>2</strong></td></tr><tr><td align="center"><strong>4</strong></td><td align="center"><strong>5</strong></td></tr><tr><td align="center"><strong>5</strong></td><td align="center"><strong>2</strong></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>16.堆</title>
      <link href="//post/16.%E5%A0%86.html"/>
      <url>//post/16.%E5%A0%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h1 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h1><p>堆是一种特殊的树:</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><p>堆必须是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆叫“大顶堆”。</p><p>对于每个节点的值都小于等于子树中每个节点值的堆叫“小顶堆”。</p><p>对于同一组数据可以构建多种不同形态的堆。</p><p>堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>下图中1、2是大顶堆，3是小顶堆，4不是堆。</p><p><img src="imgs/2/1570493298643.png" alt="1570493298643"></p><h2 id="存储一个堆"><a href="#存储一个堆" class="headerlink" title="存储一个堆"></a>存储一个堆</h2><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树，不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><p><img src="imgs/2/1570493443825.png" alt="1570493443825"></p><p>上图中i=1存储根节点，下标为 $i$ 的节点的左子节点就是下标为 $i∗2$ 的节点，右子节点就是下标为 $i∗2+1$的节点，父节点就是下标为 $\frac{i}{2}$ 的节点。</p><p>如果i=0存储根节点，下标为 $i$ 的节点的左子节点就是下标为 $i∗2+1$ 的节点，右子节点就是下标为 $i∗2+2$的节点，但父节点的下标为$\frac{i-1}{2}$</p><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="1-插入一个元素"><a href="#1-插入一个元素" class="headerlink" title="1. 插入一个元素"></a>1. 插入一个元素</h3><p>往堆中插入一个元素后需要继续满足堆的两个特性。</p><p>把新插入的元素直接放到堆的最后，之前的堆就不再符合堆的特性。就需要进行调整，让其重新满足堆的特性，这个过程叫作<strong>堆化</strong>（heapify）。</p><p>堆化有从下往上和从上往下两种方法。</p><p><img src="imgs/2/1570493581004.png" alt="1570493581004"></p><p>堆化就是顺着节点所在的路径，向上或者向下进行对比，然后交换。从下往上堆化是让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到比对到根节点。</p><p><img src="imgs/2/1570493595417.png" alt="1570493595417"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 数组，从下标 1 开始存储数据</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 堆可以存储的最大数据个数</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 堆中已经存储的数据个数</span>  <span class="token keyword">public</span> <span class="token function">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">>=</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 堆满了</span>    <span class="token operator">++</span>count<span class="token punctuation">;</span>    a<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 自下往上堆化</span>      <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// swap() 函数作用：交换下标为 i 和 i/2 的两个元素</span>      i <span class="token operator">=</span> i<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 从下标 1 开始存储数据</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 堆中已经存储的数据个数</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> data        i <span class="token operator">=</span> self<span class="token punctuation">.</span>count        <span class="token keyword">while</span> i <span class="token operator">>></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 交换下标为 i 和 i/2 的两个元素</span>            i <span class="token operator">=</span> i <span class="token operator">>></span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-删除堆顶元素"><a href="#2-删除堆顶元素" class="headerlink" title="2. 删除堆顶元素"></a>2. 删除堆顶元素</h3><p>堆的任何节点的值都大于等于（或小于等于）子树节点的值，堆顶元素存储的就是堆中数据的最大值或者最小值。</p><p>大顶堆的堆顶元素就是最大的元素，删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>但这样操作完成后的堆不再满足完全二叉树的特性：</p><p><img src="imgs/2/1570493622909.png" alt="1570493622909"></p><p>可以先把最后一个节点放到堆顶，然后从上往下的堆化。这种方法堆化之后的结果，肯定满足完全二叉树的特性：</p><p><img src="imgs/2/1570493638378.png" alt="1570493638378"></p><p>java代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 堆中没有数据</span>  a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token operator">--</span>count<span class="token punctuation">;</span>  <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 自上往下堆化</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">remove_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>a<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>count <span class="token operator">-=</span> <span class="token number">1</span>        heapify<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">,</span> self<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> list<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> i<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 自上往下堆化</span>    max_pos <span class="token operator">=</span> i    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            max_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span>        <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">and</span> a<span class="token punctuation">[</span>max_pos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            max_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> max_pos <span class="token operator">==</span> i<span class="token punctuation">:</span>            <span class="token keyword">break</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>max_pos<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>max_pos<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        i <span class="token operator">=</span> max_pos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个包含 $n$ 个节点的完全二叉树高度小于 $log_{2}n$，堆化的时间复杂度跟树的高度成正比等于 $O(log\ n)$。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $O(log\ n)$。</p><h1 id="基于堆实现堆排序"><a href="#基于堆实现堆排序" class="headerlink" title="基于堆实现堆排序"></a>基于堆实现堆排序</h1><p>借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 $O(nlog\  n)$，并且它还是原地排序算法。</p><p>堆排序的过程可以大致分解成两个大的步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1. 建堆"></a>1. 建堆</h2><p>我们首先将数组原地建成一个堆。“原地”是指不借助另一个数组在原数组上操作。</p><p>建堆的两种思路：</p><p>1.假设起初堆中只包含一个数据，就是下标为 $1$ 的数据。然后调用插入操作，将下标从 $2$ 到 $n$ 的数据依次插入到堆中。整个过程都是从下到上的堆化。</p><p>2.从后往前处理数组，找到第一个第一个非叶子节点，然后依次从上往下堆化：</p><p><img src="imgs/2/1570493827984.png" alt="1570493827984"></p><p>java代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> maxPos <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>maxPos<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> maxPos <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxPos <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">,</span> maxPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    i <span class="token operator">=</span> maxPos<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中从下标 $\frac{n}{2}$ 开始到 $1$ 的数据进行堆化，下标是 $\frac{n}{2}+1$ 到 $n$ 的节点是叶子节点不需要堆化。</p><p>对于完全二叉树来说，下标从$\frac{n}{2}+1$到 $n$ 的节点都是叶子节点。</p><p>建堆操作的时间复杂度：</p><p>叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 $k$ 成正比。将每个节点的高度求和，就可以得到建堆的时间复杂度。</p><p><img src="imgs/2/1570494076865.png" alt="1570494076865"></p><p>将每个非叶子节点的高度求和：<br>$$<br>S_{1}=1 <em> h+2^{1} </em>(h-1)+2^{2} <em>(h-2)+\cdots+2^{k} </em>(h-k)+\cdots+2^{h-1} <em> 1<br>$$<br>把公式左右都乘以 $2$就得到公式 $S2$。将 $S2$ 错位对齐并减去 $S1$，可以得到 $S$：<br>$$<br>\begin{aligned}<br>S_{1}&amp;=1</em>h+&amp;2^{1}<em>(h-1)+&amp;2^{2}</em>(h-2)+\cdots+2^{k}<em>(h-k)+\cdots+2^{h-1} </em> 1 \<br>S_{2}&amp;=    &amp;2^{1}<em>h+    &amp;2^{2}</em>(h-1)+\cdots+2^{k}<em>(h-k+1)+\cdots+2^{h-1} </em> 2+2^h*1<br>\end{aligned}<br>$$</p><p>$$<br>\begin{aligned}<br>S&amp;=S_{2}-S_{1} \<br>&amp;=-h+2^{1}+2^{2}+2^{3}+\cdots+2^{k}+\cdots+2^{h-1}+2^{h} \\<br>&amp;=-h+\left(2^{h}-2\right)+2^{h}\<br>&amp;=2^{h+1}-h-2<br>\end{aligned}<br>$$</p><p>因为 $h=log_2 n$，代入公式 $S$，就能得到 $S=O(n)$，所以，建堆的时间复杂度就是 $O(n)$。</p><h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h2><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。把它跟最后一个元素交换，那最大元素就放到了下标为 $n$ 的位置。</p><p>当堆顶元素移除之后，把下标为 $n$的元素放到堆顶，然后再通过堆化的方法，将剩下的 $n−1$ 个元素重新构建成堆。堆化完成之后再取堆顶的元素，放到下标是 $n−1$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $1$ 的一个元素，排序工作就完成了。</p><p><img src="imgs/2/1570494449408.png" alt="1570494449408"></p><p>java代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">buildHeap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> k <span class="token operator">=</span> n<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span>k<span class="token punctuation">;</span>    <span class="token function">heapify</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们再来分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlog \  n)$，所以，堆排序整体的时间复杂度是 $O(nlog \  n)$。</p><p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>上述实现中，堆中的数据是从数组下标为 1 的位置开始存储。</p><p>如果从 $0$ 开始存储，计算子节点和父节点的下标的公式就改变了。此时对于下标为i的节点，左子节点的下标是 $2∗i+1$，右子节点的下标是 $2∗i+2$，父节点的下标就是 $\frac{i-1}{2}$。</p><h2 id="为什么快速排序要比堆排序性能好？"><a href="#为什么快速排序要比堆排序性能好？" class="headerlink" title="为什么快速排序要比堆排序性能好？"></a>为什么快速排序要比堆排序性能好？</h2><p><strong>第一点，堆排序跳跃访问方式对CPU缓存不友好</strong></p><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 $1，2，4，8$的元素，而不是像快速排序那样，局部顺序访问，这样对 CPU 缓存是不友好的。</p><p><img src="imgs/2/1570494627902.png" alt="1570494627902"></p><p><strong>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</strong></p><p>快速排序数据交换的次数不会比逆序度多，但堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p><p><img src="imgs/2/1570494651114.png" alt="1570494651114"></p><h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><p>堆这种数据结构的应用：优先级队列、求 Top K 和求中位数。</p><h2 id="一：优先级队列"><a href="#一：优先级队列" class="headerlink" title="一：优先级队列"></a>一：优先级队列</h2><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>用堆来实现一个优先级队列是最直接、最高效的。因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><p>优先级队列的应用场景非常多，很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。很多语言都提供了优先级队列的实现，比如，Java 的 PriorityQueue，C++ 的 priority_queue 等。</p><p>优先级队列具体用法：</p><h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1. 合并有序小文件"></a>1. 合并有序小文件</h3><p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p><p>整体思路类似于归并排序中的合并函数。从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，这个最小的字符串来自于 13.txt 这个小文件，就再从这个小文件取下一个字符串，并且放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，并且将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p><p>每次都从大小为100的数组中取最小字符串，都需要循环遍历整个数组，不是很高效。这里就可以用到优先级队列，也可以说是堆。</p><p>将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素就是最小的字符串，将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p><p>在<a href="07.排序.md#日志合并题">07.排序-日志合并题</a>中，我已经给出基本的顺序查找的实现，但现在本题从之前10个小文件增加到100个小文件，所以必须将数组改进为小根堆提高效率，下面是python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">sort_key</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> int<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">min_heapify</span><span class="token punctuation">(</span>heap_arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> i<span class="token punctuation">:</span> int<span class="token punctuation">,</span> sort_key<span class="token operator">=</span>sort_key<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 自上往下堆化</span>    min_pos <span class="token operator">=</span> i    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> n <span class="token operator">and</span> sort_key<span class="token punctuation">(</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> sort_key<span class="token punctuation">(</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            min_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span>        <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token operator">and</span> sort_key<span class="token punctuation">(</span>heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> sort_key<span class="token punctuation">(</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            min_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">if</span> min_pos <span class="token operator">==</span> i<span class="token punctuation">:</span>            <span class="token keyword">break</span>        heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span> <span class="token operator">=</span> heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span><span class="token punctuation">,</span> heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        i <span class="token operator">=</span> min_posfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>min_heap <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 堆从角标1开始存储数据</span>out <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"out.log"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> filename <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"../logs"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    fo <span class="token operator">=</span> open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"../logs"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">)</span>    fs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>fo<span class="token punctuation">)</span>    min_heap<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>fo<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>    j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">while</span> j <span class="token operator">>></span> <span class="token number">1</span> <span class="token operator">and</span> sort_key<span class="token punctuation">(</span>min_heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> sort_key<span class="token punctuation">(</span>min_heap<span class="token punctuation">[</span>j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min_heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> min_heap<span class="token punctuation">[</span>j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> min_heap<span class="token punctuation">[</span>j <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 交换下标为 j 和 j/2 的两个元素</span>        j <span class="token operator">=</span> j <span class="token operator">>></span> <span class="token number">1</span>count <span class="token operator">=</span> len<span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    data<span class="token punctuation">,</span> i <span class="token operator">=</span> min_heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    out<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    out<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>    line <span class="token operator">=</span> fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> line<span class="token punctuation">:</span>        min_heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> line    <span class="token keyword">else</span><span class="token punctuation">:</span>        min_heap<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> min_heap<span class="token punctuation">[</span>count<span class="token punctuation">]</span>        count <span class="token operator">-=</span> <span class="token number">1</span>        fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">break</span>    <span class="token comment" spellcheck="true"># 自上往下堆化</span>    min_heapify<span class="token punctuation">(</span>min_heap<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> sort_key<span class="token punctuation">)</span>out<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2. 高性能定时器"></a>2. 高性能定时器</h3><p>有一个定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。</p><table><thead><tr><th>2018.11.28.  17:30</th><th>Task A</th></tr></thead><tbody><tr><td>2018.11.28.  19:20</td><td>Task B</td></tr><tr><td>2018.11.28.  15:31</td><td>Task C</td></tr><tr><td>2018.11.28.  13:55</td><td>Task D</td></tr></tbody></table><p>按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</p><p>这样，定时器就不需要不断的去扫描任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。</p><p>这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</p><p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p><p>这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</p><h2 id="二：利用堆求-Top-K"><a href="#二：利用堆求-Top-K" class="headerlink" title="二：利用堆求 Top K"></a>二：利用堆求 Top K</h2><p>维护一个 K 大小的小顶堆，将要求Top K的数据逐个取出与堆顶的元素对比，如果元素比堆顶元素大就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。</p><p>用以上方法可以快速对动态数据计算出实时 Top K。</p><p>针对静态数据，只需要遍历静态数据逐个添加到小顶堆，静态数据都遍历完之后，堆中的数据就是前 K 大数据了。</p><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinHeap</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>heap_arr <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 从下标 1 开始存储数据</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> k        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 堆中已经存储的数据个数</span>    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> self<span class="token punctuation">.</span>n<span class="token punctuation">:</span>            <span class="token keyword">if</span> data <span class="token operator">></span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data                self<span class="token punctuation">.</span>heapify_up_to_down<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>self<span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> data        self<span class="token punctuation">.</span>heapify_down_to_top<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">heapify_down_to_top</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从下往上堆化</span>        <span class="token keyword">while</span> i <span class="token operator">>></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 交换下标为 i 和 i/2 的两个元素</span>            i <span class="token operator">=</span> i <span class="token operator">>></span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">heapify_up_to_down</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> i<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 自上往下堆化</span>        min_pos <span class="token operator">=</span> i        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>n <span class="token operator">and</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                min_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span>            <span class="token keyword">if</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>n <span class="token operator">and</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span> <span class="token operator">></span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                min_pos <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">if</span> min_pos <span class="token operator">==</span> i<span class="token punctuation">:</span>                <span class="token keyword">break</span>            self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>min_pos<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i <span class="token operator">=</span> min_pos<span class="token keyword">def</span> <span class="token function">topK</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> list<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">:</span>    heap <span class="token operator">=</span> MinHeap<span class="token punctuation">(</span>k<span class="token punctuation">)</span>    <span class="token keyword">for</span> e <span class="token keyword">in</span> a<span class="token punctuation">:</span>        heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>e<span class="token punctuation">)</span>    <span class="token keyword">return</span> heap<span class="token punctuation">.</span>heap_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>topK<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三：利用堆求中位数"><a href="#三：利用堆求中位数" class="headerlink" title="三：利用堆求中位数"></a>三：利用堆求中位数</h2><p>把数据从小到大排列：</p><p>如果数据的个数是奇数，那第 $\frac{n}{2}+1$ 个数据是中位数；</p><p>如果数据的个数是偶数，第 $\frac{n}{2}$ 个和第 $\frac{n}{2}+1$ 个数据是中位数，可以取两个数中靠前的那个，就是第 $\frac{n}{2}$ 个数据作为中位数。</p><p><img src="imgs/2/1570496431493.png" alt="1570496431493"></p><p>对于<strong>静态数据</strong>集合，中位数是固定的，先排序再直接返回这个固定的值就好了。</p><p>对于<strong>动态数据</strong>集合，中位数在不停地变动，如果每次询问中位数的时候，都要先进行排序代价很高。</p><p>借助堆这种数据结构，不用排序就可以快速求中位数：</p><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p><ul><li>如果n 是偶数，大顶堆存储前$\frac{n}{2}$ 个数据，小顶堆中存储后 $\frac{n}{2}$ 个数据。</li><li>如果 n 是奇数，大顶堆存储前$\frac{n}{2}+1$ 个数据，小顶堆中存储后 $\frac{n}{2}$ 个数据。</li></ul><p>其中大顶堆中的堆顶元素就是中位数：</p><p><img src="imgs/2/1570496493417.png" alt="1570496493417"></p><p>添加一个数据：</p><ul><li>如果新加入的数据小于等于大顶堆的堆顶元素，插入到大顶堆；</li><li>如果新加入的数据大于等于小顶堆的堆顶元素，插入到小顶堆。</li></ul><p>这时候可能出现两个堆中的数据个数不符合前面约定的情况，可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p><p><img src="imgs/2/1570496545408.png" alt="1570496545408"></p><p>插入数据因为需要涉及堆化时间复杂度为 $O(logn)$，求中位数只需要返回大顶堆的堆顶元素就可以时间复杂度是 $O(1)$。</p><p>利用两个堆求其他百分位的数据原理是类似的，中位数就是将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 50% 的数据，99 百分位数就是大于前面 99% 数据的那个数据。</p><p>假设有 100 个数据，分别是 1，2，3，……，100，那 99 百分位数就是 99，因为小于等于 99 的数占总个数的 99%。</p><p><img src="imgs/2/1570496832646.png" alt="1570496832646"></p><p>如果有 n 个数据，将数据从小到大排列之后，99 百分位数大约就是第 $n<em>99\%$ 个数据，同类，80 百分位数大约就是第 $n </em>80\%$ 个数据。</p><p>求 99 百分位数的思路：</p><p>维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 $n<em>99\%$ 个数据，小顶堆中保存 $n</em>1\%$ 个数据。大顶堆堆顶的数据就是要找的 99 百分位数。</p><p>每插入一个数据，要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中。如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆；如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。插入数据之后要重新计算，大顶堆和小顶堆中的数据个数是否还符合 99:1 这个比例。如果不符合，就将一个堆中的数据移动到另一个堆，直到满足这个比例。</p><p>每次插入数据会涉及几个数据的堆化操作，时间复杂度是 O(logn)。每次求 99 百分位数，直接返回大顶堆中的堆顶数据即可，时间复杂度是 O(1)。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">from</span> Heap <span class="token keyword">import</span> Heap<span class="token keyword">class</span> <span class="token class-name">PercentileNumber</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> percentile<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>min_heap <span class="token operator">=</span> Heap<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">"min"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>max_heap <span class="token operator">=</span> Heap<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">"max"</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>percentile <span class="token operator">=</span> percentile    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">return</span>        max_count <span class="token operator">=</span> math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">*</span> self<span class="token punctuation">.</span>percentile<span class="token punctuation">)</span>        <span class="token keyword">if</span> data <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>get_top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>min_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">if</span> max_count <span class="token operator">></span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_heap<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>self<span class="token punctuation">.</span>min_heap<span class="token punctuation">.</span>remove_top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> max_count <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_heap<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>min_heap<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>remove_top<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_percentile_number</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>max_heap<span class="token punctuation">.</span>get_top<span class="token punctuation">(</span><span class="token punctuation">)</span>number <span class="token operator">=</span> PercentileNumber<span class="token punctuation">(</span>percentile<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    number<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>number<span class="token punctuation">.</span>get_percentile_number<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Heap类完整代码见github。</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="1-获取Top-10搜索关键词"><a href="#1-获取Top-10搜索关键词" class="headerlink" title="1.获取Top 10搜索关键词"></a>1.获取Top 10搜索关键词</h2><p><strong>1.假设有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词？</strong></p><p>搜索引擎每天会接收大量的用户搜索请求，它会把这些用户输入的搜索关键词记录下来，然后再离线地统计分析，得到最热门的 Top 10 搜索关键词。处理的场景限定为单机，可以使用的内存为 1GB。如何解决这个问题？</p><p>答：</p><p>假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，那就先将 10 亿条搜索关键词通过哈希算法分片到 10 个文件中。</p><p>遍历这 10 亿个关键词，通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。</p><p>针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</p><p>利用散列表和堆分别求出 Top 10的具体步骤：</p><p>先顺序扫描当前文件的搜索关键词。当扫描到某个关键词时，去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。遍历完之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</p><p>再建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了。</p><h2 id="2-定期统计点击量排名-Top-10-的新闻摘要"><a href="#2-定期统计点击量排名-Top-10-的新闻摘要" class="headerlink" title="2.定期统计点击量排名 Top 10 的新闻摘要"></a><strong>2.定期统计点击量排名 Top 10 的新闻摘要</strong></h2><p>有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？</p><p>答：</p><p>以key为新闻id，value为点击量，建一个散列表，每当一个新闻被点击时，对应value+1，实时更新。</p><p>每隔1小时，重新建立一个大小为10的小顶堆（初始点击量为0）。遍历散列表，依次取出新闻id和点击量count，将取出的点击量count与堆顶元素的点击量count对比。如果取出的点击量count相对堆顶元素更大就删除堆顶的元素，并将从散列表取出新闻id和对应点击量加入到堆中。当遍历完整个散列表之后，堆中的新闻id就是出现次数最多的 Top 10 新闻id了。小顶堆创建完成后，即可将小顶堆里的10个新闻id覆盖写入到数据库中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>15.递归树</title>
      <link href="//post/15.%E9%80%92%E5%BD%92%E6%A0%91.html"/>
      <url>//post/15.%E9%80%92%E5%BD%92%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h2 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h2><p>有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。</p><p>一般递推公式都可以求解递归代码的时间复杂度，但是有些情况，比如快排的平均时间复杂度的分析，用递推公式会涉及非常复杂的数学推导，借助递归树来分析递归算法的时间复杂度就会比较简单。</p><p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p><p>如果把这个一层一层的分解过程画成图，它其实就是一棵树，这棵树就叫<strong>递归树</strong>。</p><p>下面是一棵斐波那契数列的递归树，节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。</p><p><img src="imgs/2/1570445651316.png" alt="1570445651316"></p><h2 id="递归树分析归并排序递归代码的时间复杂度"><a href="#递归树分析归并排序递归代码的时间复杂度" class="headerlink" title="递归树分析归并排序递归代码的时间复杂度"></a>递归树分析归并排序递归代码的时间复杂度</h2><p>归并排序每次会将数据规模一分为二，画成递归树，就是下面这个样子：</p><p><img src="imgs/2/1570445665505.png" alt="1570445665505"></p><p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 $1$。每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，我们把每一层归并操作消耗的时间记作 $n$。</p><p>假设这棵树的高度 $h$，那总的时间复杂度为$O(n∗h)$。</p><p>归并排序递归树是一棵满二叉树，满二叉树的高度大约是 $log_2n$，所以，归并排序递归实现的时间复杂度就是 $O(nlogn)$ 。</p><h2 id="分析快速排序的时间复杂度"><a href="#分析快速排序的时间复杂度" class="headerlink" title="分析快速排序的时间复杂度"></a>分析快速排序的时间复杂度</h2><p>用递推公式来求解平均时间复杂度：</p><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 $T(n)=2T(\frac{n}{2})+n$ ,很容易就能推导出时间复杂度是$ O(nlogn)$ 。</p><p>假设平均情况下，每次分区之后两个分区的大小比例为 $1:k$。当 $k=9$时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 $T(n)=T(\frac{n}{10})+T(\frac{9n}{10})+n$。</p><p>用这个递推公式推导时间复杂度，推导过程非常复杂。现在用递归树来分析这种情况下快速排序的平均情况时间复杂度：</p><p><img src="imgs/2/1570446242483.png" alt="1570446242483"></p><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 $n$。假设递归树的高度 $h$，时间复杂度就是 $O(h∗n)$。</p><p>每次分区并不是均匀地一分为二，递归树并不是满二叉树。快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。</p><p>从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 $\frac{1}{10}$，最长的一个路径每次都乘以 $\frac{9}{10}$。通过计算可以得到，从根节点到叶子节点的最短路径是 $log_{10}n$，最长的路径是 $log_{\frac{10}{9}}n$。</p><p><img src="imgs/2/1570446604211.png" alt="1570446604211"></p><p>遍历数据的个数总和介于 $n\ log_{10}n$ 和$n \ log_{\frac{10}{9}}n$之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，可以统一写成 $log\ n$，所以，当分区大小比例是 $1:9$时，快速排序的时间复杂度仍然是$O(nlog\ n)$。</p><p>如果 $k=99$，树的最短路径就是 $log_{100}n$，最长路径是 $log_{\frac{100}{99}}n$，所以总遍历数据个数介于 $nlog_{100}n$ 和 $nlog_{\frac{100}{99}}n$ 之间，时间复杂度也仍然是 $O(nlog\ n)$。</p><p>只要 $k$ 的值不随 $n$变化，是一个事先确定的常量，那快排的时间复杂度就是$O(nlog\ n)$。所以，从概率论的角度来说，快排的平均时间复杂度就是 $O(nlog\ n)$。</p><h2 id="分析斐波那契数列的时间复杂度"><a href="#分析斐波那契数列的时间复杂度" class="headerlink" title="分析斐波那契数列的时间复杂度"></a>分析斐波那契数列的时间复杂度</h2><p>斐波那契数列的递推实现代码实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把上面的递归代码画成递归树，就是下面这个样子：</p><p><img src="imgs/2/1570448039211.png" alt="1570448039211"></p><p>这棵递归树的高度是多少呢？</p><p>$f(n)$分解为 $f(n−1)$ 和 $f(n−2)$，每次数据规模都是 $−1$ 或者 $−2$，叶子节点的数据规模是 $1$ 或者 $2$。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 $−1$，那最长路径大约就是 $n$；如果每次都是 $−2$，那最短路径大约就是 $\frac{n}{2}$。</p><p>每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 $1$。所以，从上往下，第一层的总时间消耗是 $1$，第二层的总时间消耗是 $2$，第三层的总时间消耗就是 $2^2$。依次类推，第 $k$ 层的时间消耗就是 $2^k−1$，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 $n$，那这个总和就是 $2^n−1$。<br>$$<br>1+2+\cdots+2^{n-1}=2^{n}-1<br>$$<br>如果路径长度都是 $\frac{n}{2}$ ，那整个算法的总的时间消耗就是 $2^{\frac{n}{2}}−1$。<br>$$<br>1+2+\cdots+2^{\frac{n}{2}-1}=2^{\frac{n}{2}}-1<br>$$<br>所以，这个算法的时间复杂度就介于 $O(2^n)$ 和 $O(2^{\frac{n}{2}})$ 之间，算法的时间复杂度是指数级的。</p><h2 id="分析全排列的时间复杂度"><a href="#分析全排列的时间复杂度" class="headerlink" title="分析全排列的时间复杂度"></a>分析全排列的时间复杂度</h2><p>“如何把n 个数据的所有排列都找出来”，这就是全排列的问题。</p><p>比如$1，2，3 $这样 3 个数据，有下面这几种不同的排列：</p><pre><code>1, 2, 31, 3, 22, 1, 32, 3, 13, 1, 23, 2, 1</code></pre><p>全排列问题可以用递归来实现：</p><p>如果确定了第一位数据，就变成了求解剩下 $n−1$ 个数据的排列问题。而第一位数据可以是 $n$ 个数据中的任意一个，因此它的取值就有 $n$ 种情况。所以，“$n$ 个数据的排列”问题，就可以分解成 $n$ 个“$n−1$ 个数据的排列”的子问题。</p><p>递推公式：</p><pre><code>假设数组中存储的是 1，2， 3...n。f(1,2,...n) = {第一位是 1, f(n-1)} + {第一位是 2, f(n-1)} +...+{第一位是 n, f(n-1)}。</code></pre><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutation</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    :param chars: 字符串序列    :param k: 未处理的字符串的起始位置    :return:    """</span>    <span class="token keyword">if</span> k <span class="token operator">==</span> len<span class="token punctuation">(</span>chars<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>end<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">,</span> len<span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        permutation<span class="token punctuation">(</span>chars<span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>画出递归树：</p><p><img src="imgs/2/1570448501976.png" alt="1570448501976"></p><p>第一层分解有 $n$ 次交换操作，第二层有 $n$ 个节点，每个节点分解需要 $n−1$ 次交换，所以第二层总的交换次数是 $n∗(n−1)$。第三层有 $n∗(n−1)$ 个节点，每个节点分解需要 $n−2$ 次交换，所以第三层总的交换次数是 $n∗(n−1)∗(n−2)$。</p><p>以此类推，第 kk 层总的交换次数就是 $n∗(n−1)∗(n−2)∗…∗(n−k+1)$。最后一层的交换次数就是 $n∗(n−1)∗(n−2)∗…∗2∗1$。每一层的交换次数之和就是总的交换次数。</p><p>$$<br>n + n<em>(n-1) + n</em>(n-1)<em>(n-2) +… + n</em>(n-1)<em>(n-2)</em>…<em>2</em>1<br>$$<br>最后一个数$n∗(n−1)∗(n−2)∗…∗2∗1$ 等于 $n!$，而前面的 $n−1$ 个数都小于最后一个数，所以，总和肯定小于 $n∗n!$，全排列的递归算法的时间复杂度在 $O(n!)$到 $O(n∗n!)$之间，阶乘级。</p><h2 id="分析细胞分裂问题的时间复杂度"><a href="#分析细胞分裂问题的时间复杂度" class="headerlink" title="分析细胞分裂问题的时间复杂度"></a>分析细胞分裂问题的时间复杂度</h2><p>1个细胞的生命周期是3小时，1小时分裂一次。求n小时后，容器内有多少细胞？时间复杂度是多少？</p><p>细胞的生命周期是三个小时，一个小时后，第一个细胞分裂，此时细胞总数变成 2，这个时候其中一个细胞的生存时间变成了 1，另外一个刚分裂出来的是 0，下面简单表示一下分裂进程（-1 表示死亡）<br>时间 细胞状态 (生存时间) 细胞总数</p><pre><code>1 0                                                   count=22 0 1 0                                               count=4-1 0 1 0 2 0 1 0                                       count=71 0 2 0 1 0 -1 0 1 0 2 0 1 0 1 0                       count=13-1 -1 2 2 2 2 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 count=24</code></pre><p>即：<br>f0 = 1；f1 = 2；f2 = 4<br>f3 = 7；f4 =13；f5 = 24</p><p>第4个小时死亡的细胞是三小时前新出生的细胞$f(0)$，</p><p>当n&gt;=4时，第n个小时死亡的细胞是$f(n-4)$，</p><p>有递推式：<br>$$<br>f(n)=\begin{cases}<br>        1, &amp;  n&lt;=0 \<br>        2, &amp;  n=1 \<br>        4, &amp;  n=2 \<br>        7, &amp;  n=3 \<br>        2 * f(n - 1) - f(n - 4), &amp; n&gt;=4<br>     \end{cases}<br>$$</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cell_division</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">4</span>    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">7</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> cell_division<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> cell_division<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f(%s)=%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> cell_division<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归树:</p><p><img src="imgs/oOAlvULKOjzy.png" alt="mark"></p><p>$f(n)$分解为 $f(n−1)$ 和 $f(n−4)$，每次数据规模都是 ​−1​或者−4​，叶子节点的数据规模是 ​1、2、4或7。</p><p>最长路径大约是n，最短路径大约是 n/4。</p><p>每次分解之后的只需要一次乘法和一次加法运算，把这次运算的时间消耗记作 $1$。所以，从上往下，第一层的总时间消耗是 $1$，第二层的总时间消耗是 $2$，第三层的总时间消耗就是 $2^2$。依次类推，第 $k$ 层的时间消耗就是 $2^k−1$，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 $n$，那这个总和就是 $2^n−1$。<br>$$<br>1+2+\cdots+2^{n-1}=2^{n}-1<br>$$<br>如果路径长度都是 $\frac{n}{4}$ ，那整个算法的总的时间消耗就是 $2^{\frac{n}{4}}−1$。<br>$$<br>1+2+\cdots+2^{\frac{n}{4}-1}=2^{\frac{n}{4}}-1<br>$$<br>所以，这个算法的时间复杂度就介于 $O(2^n)$ 和 $O(2^{\frac{n}{4}})$ 之间，算法的时间复杂度是指数级的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>14.红黑树</title>
      <link href="//post/14.%E7%BA%A2%E9%BB%91%E6%A0%91.html"/>
      <url>//post/14.%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><h1 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h1><p>二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。但二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 $log_2n$ 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 $O(n)$。要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。</p><p>平衡二叉树的严格定义是任意一个节点的左右子树的高度相差不能大于 1。</p><p>完全二叉树、满二叉树都是平衡二叉树，非完全二叉树也有可能是平衡二叉树。</p><p><img src="imgs/2/1570444901543.png" alt="1570444901543"></p><p>最先被发明的平衡二叉查找树是<a href="https://zh.wikipedia.org/wiki/AVL树" target="_blank" rel="noopener">AVL 树</a>，它严格符合平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p><p>但是很多平衡二叉查找树并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</p><p>所以，<strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p><p>所以，只要树的高度不比 $log_2n$ 大很多（树的高度仍然是对数量级的），就仍然可以认为这是一个合格的平衡二叉查找树。</p><h2 id="各种平衡2叉树的对比"><a href="#各种平衡2叉树的对比" class="headerlink" title="各种平衡2叉树的对比"></a>各种平衡2叉树的对比</h2><p>绝大部分情况下Treap、Splay Tree操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。</p><p>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但AVL 树为了维持这种高度的平衡，每次插入、删除都要做调整比较复杂、耗时。对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高。</p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用更倾向于这种性能稳定的平衡二叉查找树。</p><h2 id="动态数据结构优劣势对比"><a href="#动态数据结构优劣势对比" class="headerlink" title="动态数据结构优劣势对比"></a>动态数据结构优劣势对比</h2><p>动态数据结构支持动态地数据插入、删除、查找操作</p><p>散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。</p><p>跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。</p><p>红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。 </p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>平衡二叉查找树有Splay Tree（伸展树）、Treap（树堆）等，但用的最多的平衡二叉查找树基本都是红黑树。有时候甚至默认平衡二叉查找树就是红黑树。</p><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，</p><p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。</p><h2 id="红黑树所需要满足的要求"><a href="#红黑树所需要满足的要求" class="headerlink" title="红黑树所需要满足的要求"></a>红黑树所需要满足的要求</h2><p>红黑树满足：</p><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点；</li></ul><p>下图将黑色的、空的叶子节点都省略掉了：</p><p><img src="imgs/2/1570444918651.png" alt="1570444918651"></p><h2 id="红黑树的“近似平衡”"><a href="#红黑树的“近似平衡”" class="headerlink" title="红黑树的“近似平衡”"></a>红黑树的“近似平衡”</h2><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重</strong>。</p><p>二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 $log_2n$，红黑树是否近似平衡就看红黑树的高度是否比较稳定地趋近$log_2n$ 。</p><p>红黑树的高度计算：</p><p>先计算单纯包含黑色节点的红黑树的高度，红色节点删除之后，失去父节点的节点拿自己的祖父节点（父节点的父节点）作为父节点。之前的二叉树就变成了四叉树。</p><p><img src="imgs/2/1570444949922.png" alt="1570444949922"></p><p>红黑树中，从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p><p>完全二叉树的高度近似$log_2n$，四叉“黑树”的高度低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过$log_2n$。</p><p>有一个红色节点就至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过$log_2n$，所以加入红色节点之后，最长路径不会超过$2log_2n$，也就是说，红黑树的高度近似 $2log_2n$。</p><p>所以，红黑树的高度能比较稳定地趋近$log_2n$， 是近似平衡的。</p><h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p><p>一棵合格的红黑树需要满足的要求：</p><ol><li>根节点是黑色的；</li><li>叶子节点都是黑色的空节点（NIL），不存储数据；</li><li>红色节点被黑色节点隔开的，不得出现两个连续的红色节点；</li><li>每个节点到达其可达叶子节点的所有路径包含黑色节点的个数要相等。</li></ol><p>在插入删除节点的过程中，第3、4后面两点要求可能会被破坏，“平衡调整”就是把被破坏的第3、4点恢复过来。</p><h2 id="如何比较轻松学会红黑树"><a href="#如何比较轻松学会红黑树" class="headerlink" title="如何比较轻松学会红黑树"></a>如何比较轻松学会红黑树</h2><p>第一点，<strong>把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性</strong>。只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p><p>第二点，<strong>找准关注节点，不要搞丢、搞错关注节点</strong>。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p><p>第三点，<strong>插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p><h2 id="平衡操作中两个非常重要的操作"><a href="#平衡操作中两个非常重要的操作" class="headerlink" title="平衡操作中两个非常重要的操作"></a>平衡操作中两个非常重要的操作</h2><p><strong>左旋（rotate left）</strong>全称叫<strong>围绕某个节点的左旋</strong>，</p><p><strong>右旋（rotate right）</strong>全称叫<strong>围绕某个节点的右旋</strong>。</p><p>下图中的 a，b，r 表示子树，可以为空：</p><p><img src="imgs/2/1570444992882.png" alt="1570444992882"></p><h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上</strong>。</p><p>插入操作的平衡调整，有这样两种特殊情况：</p><ul><li>如果插入节点的父节点是黑色的，无需任何调整。</li><li>如果插入的节点是根节点，那就直接把它改成黑色就可以了。</li></ul><p>其他情况都需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p><p>红黑树的平衡调整是一个迭代的过程。正在被处理的节点叫<strong>关注节点</strong>，关注节点会随着不停地迭代处理，而不断发生变化，最开始的关注节点就是新插入的节点。</p><p>新节点插入之后，如果红黑树的平衡被打破一般会有下面三种情况。只需要根据每种情况采取对应的策略去调整，然后不停的迭代，就可以让红黑树继续符合定义从而保持平衡。</p><p>下面把父节点的兄弟节点称为<strong>叔叔节点</strong>，父节点的父节点称为<strong>祖父节点</strong>。</p><h3 id="CASE-1：关注节点-a的叔叔节点-d-是红色"><a href="#CASE-1：关注节点-a的叔叔节点-d-是红色" class="headerlink" title="CASE 1：关注节点 a的叔叔节点 d 是红色"></a><strong>CASE 1：关注节点 a的叔叔节点 d 是红色</strong></h3><ul><li>将关注节点 a 的父节点 b、叔叔节点 d 都设置成黑色；</li><li>将关注节点 a 的祖父节点 c 设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 CASE 2 或者 CASE 3。</li></ul><p><img src="imgs/2/1570445009767.png" alt="1570445009767"></p><h3 id="CASE-2：关注节点-a的叔叔节点-d-是黑色，而且节点-a是其父节点的右子节点："><a href="#CASE-2：关注节点-a的叔叔节点-d-是黑色，而且节点-a是其父节点的右子节点：" class="headerlink" title="CASE 2：关注节点 a的叔叔节点 d 是黑色，而且节点 a是其父节点的右子节点："></a>CASE 2：关注节点 a的叔叔节点 d 是黑色，而且节点 a是其父节点的右子节点：</h3><ul><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点b 左旋；</li><li>跳到 CASE 3。</li></ul><p>如果关注节点 的叔叔节点是黑色而且是右子节点，就将关注节点设置为关注节点的父节点并左旋，最后跳到 CASE 3。</p><p><img src="imgs/2/1570445028474.png" alt="1570445028474"></p><h3 id="CASE-3：关注节点a的叔叔节点-d-是黑色，关注节点-a-是其父节点-b-的左子节点："><a href="#CASE-3：关注节点a的叔叔节点-d-是黑色，关注节点-a-是其父节点-b-的左子节点：" class="headerlink" title="CASE 3：关注节点a的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点："></a><strong>CASE 3：关注节点a的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</strong>：</h3><ul><li>围绕关注节点 a 的祖父节点 c 右旋；</li><li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li><li>调整结束。</li></ul><p>如果关注节点 的叔叔节点是黑色而且是左子节点，就围绕关注节点的祖父节点右旋，最后将关注节点的父节点 与关注节点的兄弟节点 颜色互换。</p><p><img src="imgs/2/1570445049617.png" alt="1570445049617"></p><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>删除操作的平衡调整分为两步，</p><p>初步调整：调整到每个节点到达其可达叶子节点的所有路径包含黑色节点的个数要相等</p><p>二次调整：调整到不存在相邻的两个红色节点</p><h3 id="1-初步调整"><a href="#1-初步调整" class="headerlink" title="1. 初步调整"></a>1. 初步调整</h3><p>经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p><p>图示说明：如果一个节点既可以是红色也可以是黑色，用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，用左上角的一个小黑点来表示额外的黑色。</p><p><strong>CASE 1：要删除的节点 a只有一个子节点 b</strong></p><p>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。</p><p>节点b替换到节点 a 的位置并把节点 a 删除，然后将节点b的颜色设置为黑色。</p><p><img src="imgs/2/1570445070428.png" alt="1570445070428"></p><p><strong>CASE 2：要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</strong></p><p>节点 a 的后继节点是右子节点 c表示右子节点 c没有左子树。</p><ul><li>将后继节点 c 替换到节点 a 的位置并把节点 a 删除；</li><li>节点 c 设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，就给节点 c 的右子节点 d 多加一个黑色，节点 d 就成了“红 - 黑”或者“黑 - 黑”；</li><li>关注节点设置为节点 d，准备进行二次调整。</li></ul><p><img src="imgs/2/1570445087285.png" alt="1570445087285"></p><p><strong>CASE 3：要删除的节点 a有两个非空子节点，并且节点 a 的后继节点不是右子节点</strong></p><p>节点 a 的后继节点不是右子节点表示右子节点存在左子树。</p><ul><li>将节点 a 的数据修改为后继节点 d的数据，然后按照CASE 1删除后继节点 d ；</li><li>如果节点a 是黑色，给节点 a 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</li><li>关注节点设置为节点 c，准备进行二次调整。</li></ul><p><img src="imgs/2/1570445105711.png" alt="1570445105711"></p><h3 id="2-二次调整"><a href="#2-二次调整" class="headerlink" title="2. 二次调整"></a>2. 二次调整</h3><p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，需要再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><strong>CASE 1：关注节点 a的兄弟节点 c 是红色</strong></p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变，继续从四种情况中选择适合的规则来调整。</li></ul><p><img src="imgs/2/1570445145477.png" alt="1570445145477"></p><p><strong>CASE 2：关注节点 a的兄弟节点 c 是黑色，并且节点 c 的左右子节点 d、e 都是黑色</strong></p><ul><li>将关注节点 a 的兄弟节点 c设置为红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</li><li>关注节点从 a 变成其父节点 b；</li><li>继续从四种情况中选择符合的规则来调整。</li></ul><p><img src="imgs/2/1570445163520.png" alt="1570445163520"></p><p><strong>CASE 3：关注节点a的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</strong></p><ul><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变，跳到 CASE 4，继续调整。</li></ul><p><img src="imgs/2/1570445186041.png" alt="1570445186041"></p><p><strong>CASE 4：关注节点 a 的兄弟节点 c 是黑色，并且兄弟节点c 的右子节点是红色的</strong></p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 设置为跟关注节点 a 的父节点 b 相同的颜色；</li><li>将关注节点 a 的父节点 b 和叔叔节点 e 设置为黑色；</li><li>去掉关注节点 a 的一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>调整结束。</li></ul><p><img src="imgs/2/1570445206401.png" alt="1570445206401"></p><h2 id="为什么红黑树要求叶子节点是黑色的空节点？"><a href="#为什么红黑树要求叶子节点是黑色的空节点？" class="headerlink" title="为什么红黑树要求叶子节点是黑色的空节点？"></a>为什么红黑树要求叶子节点是黑色的空节点？</h2><p>是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为上面说到那几种情况。</p><p>假设红黑树不要求“叶子节点必须是黑色的空节点”，当插入节点的父节点也是红色的时候，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。这个时候，新插入的节点没有叔叔节点，三种情况下的平衡调整规则就都不适用的。</p><p><img src="imgs/2/1570445220062.png" alt="1570445220062"></p><p>但如果把黑色的空节点都给它加上，就可以满足 CASE 2 ：</p><p><img src="imgs/2/1570445234190.png" alt="1570445234190"></p><p>CASE 2 可以改为“关注节点 a的叔叔节点 d 是黑色或者叔叔节点 d 不存在， a是其父节点的右子节点”，但没有原来的规则简洁。</p><p>给红黑树添加黑色的空的叶子节点，并不会太浪费存储空间呢。因为在具体实现的时候，只需共用一个黑色的、空的叶子节点就行了。</p><p><img src="imgs/2/1570445246373.png" alt="1570445246373"></p><h1 id="红黑树的python可视化"><a href="#红黑树的python可视化" class="headerlink" title="红黑树的python可视化"></a>红黑树的python可视化</h1><h2 id="安装graphviz"><a href="#安装graphviz" class="headerlink" title="安装graphviz"></a>安装graphviz</h2><p>下载地址：<a href="http://www.graphviz.org/download/" target="_blank" rel="noopener">http://www.graphviz.org/download/</a></p><p>windows平台下可以选择：</p><ul><li><a href="https://graphviz.gitlab.io/_pages/Download/Download_windows.html" target="_blank" rel="noopener">Stable 2.38 Windows install packages</a></li></ul><p>安装完成后将bin目录添加到环境变量中。</p><p>验证安装：</p><pre class="line-numbers language-bash"><code class="language-bash">C:\Users\Administrator<span class="token operator">></span>dot -versiondot - graphviz version 2.38.0 <span class="token punctuation">(</span>20140413.2041<span class="token punctuation">)</span>libdir <span class="token operator">=</span> <span class="token string">"D:\Program Files (x86)\Graphviz2.38\bin"</span>Activated plugin library: gvplugin_dot_layout.dllUsing layout: dot:dot_layoutActivated plugin library: gvplugin_core.dllUsing render: dot:coreUsing device: dot:dot:coreThe plugin configuration file:        D:\Program Files <span class="token punctuation">(</span>x86<span class="token punctuation">)</span>\Graphviz2.38\bin\config6                was successfully loaded.    render      <span class="token keyword">:</span>  cairo dot fig gd gdiplus map pic pov <span class="token function">ps</span> svg tk vml vrml xdot    layout      <span class="token keyword">:</span>  circo dot fdp neato nop nop1 nop2 osage patchwork sfdp twopi    textlayout  <span class="token keyword">:</span>  textlayout    device      <span class="token keyword">:</span>  bmp canon cmap cmapx cmapx_np dot emf emfplus eps fig gd gd2 gif gv imap imap_np ismap jpe jpeg jpg metafile pdf pic plain plain-ext png pov <span class="token function">ps</span> ps2 svg svgz tiftiff tk vml vmlz vrml wbmp xdot xdot1.2 xdot1.4    loadimage   <span class="token keyword">:</span>  <span class="token punctuation">(</span>lib<span class="token punctuation">)</span> bmp eps gd gd2 gif jpe jpeg jpg png <span class="token function">ps</span> svg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出现类似上面的版本信息，表示安装成功。</p><h2 id="安装pygraphviz"><a href="#安装pygraphviz" class="headerlink" title="安装pygraphviz"></a>安装pygraphviz</h2><p>下载地址：<a href="https://github.com/CristiFati/Prebuilt-Binaries/tree/master/PyGraphviz">https://github.com/CristiFati/Prebuilt-Binaries/tree/master/PyGraphviz</a></p><p>从上面地址下载指定python版本的pygraphviz，我下载的是64位系统python3.7版本：</p><p><a href="https://github.com/CristiFati/Prebuilt-Binaries/raw/master/PyGraphviz/pygraphviz-1.5-cp37-cp37m-win_amd64.whl">https://github.com/CristiFati/Prebuilt-Binaries/raw/master/PyGraphviz/pygraphviz-1.5-cp37-cp37m-win_amd64.whl</a></p><p>然后在下载目录中运行以下命令即可安装成功：</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> pygraphviz-1.5-cp37-cp37m-win_amd64.whl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="红黑树python实现代码"><a href="#红黑树python实现代码" class="headerlink" title="红黑树python实现代码"></a>红黑树python实现代码</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">import</span> pygraphviz <span class="token keyword">as</span> pgv<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token operator">=</span>None<span class="token punctuation">,</span> color<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        <span class="token keyword">assert</span> color <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span> <span class="token keyword">if</span> color <span class="token operator">==</span> <span class="token string">'r'</span> <span class="token keyword">else</span> <span class="token string">'black'</span>        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">is_black</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>color <span class="token operator">==</span> <span class="token string">'black'</span>    <span class="token keyword">def</span> <span class="token function">is_red</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>color <span class="token operator">==</span> <span class="token string">'red'</span>    <span class="token keyword">def</span> <span class="token function">set_black</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'black'</span>    <span class="token keyword">def</span> <span class="token function">set_red</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'red'</span><span class="token keyword">class</span> <span class="token class-name">RedBlackTree</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val_list<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>tree<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span> <span class="token operator">=</span> None        self<span class="token punctuation">.</span>black_leaf <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>color<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 共用的黑色叶子节点</span>        <span class="token keyword">if</span> val_list <span class="token keyword">is</span> None<span class="token punctuation">:</span>            val_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> n <span class="token keyword">in</span> val_list<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>            <span class="token keyword">if</span> data <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>left            <span class="token keyword">elif</span> data <span class="token operator">></span> p<span class="token punctuation">.</span>data<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> p        <span class="token keyword">return</span> None    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 新插入的节点为红色</span>        <span class="token comment" spellcheck="true"># 根节点</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>tree <span class="token operator">=</span> new_node        <span class="token keyword">else</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree  <span class="token comment" spellcheck="true"># 根节点</span>            <span class="token keyword">while</span> p <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 黑色叶子节点</span>                pp <span class="token operator">=</span> p  <span class="token comment" spellcheck="true"># pp表示插入点的父节点</span>                <span class="token keyword">if</span> data <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">:</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>left                <span class="token keyword">elif</span> data <span class="token operator">></span> p<span class="token punctuation">.</span>data<span class="token punctuation">:</span>                    p <span class="token operator">=</span> p<span class="token punctuation">.</span>right                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># raise KeyError('val:{} already exists' % data)  # 该值已存在，插入失败</span>                    <span class="token keyword">return</span>            <span class="token keyword">if</span> data <span class="token operator">&lt;</span> pp<span class="token punctuation">.</span>data<span class="token punctuation">:</span>                pp<span class="token punctuation">.</span>left <span class="token operator">=</span> new_node            <span class="token keyword">else</span><span class="token punctuation">:</span>                pp<span class="token punctuation">.</span>right <span class="token operator">=</span> new_node            new_node<span class="token punctuation">.</span>parent <span class="token operator">=</span> pp        new_node<span class="token punctuation">.</span>left <span class="token operator">=</span> new_node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>black_leaf        <span class="token comment" spellcheck="true"># 插入后调整</span>        self<span class="token punctuation">.</span>_insert_fixup<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_insert_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token punctuation">:</span> TreeNode <span class="token operator">=</span> node  <span class="token comment" spellcheck="true"># 关注节点</span>        <span class="token keyword">while</span> n <span class="token operator">!=</span> self<span class="token punctuation">.</span>tree <span class="token operator">and</span> n<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>is_red<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 父p 叔u 祖父g</span>            p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>n<span class="token punctuation">)</span>            u <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            g <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>p<span class="token punctuation">)</span>            <span class="token keyword">if</span> u<span class="token punctuation">.</span>is_red<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># case 1 叔叔节点是红色</span>                p<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 父节点设置成黑色</span>                u<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 叔叔节点设置成黑色</span>                g<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 祖父节点设置成红色</span>                n <span class="token operator">=</span> g  <span class="token comment" spellcheck="true"># 关注节点变成祖父节点</span>                <span class="token keyword">continue</span>            <span class="token comment" spellcheck="true"># 往下走，说明叔叔节点是黑色</span>            <span class="token keyword">if</span> p <span class="token operator">==</span> g<span class="token punctuation">.</span>left<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 父节点为祖父节点的左子结点</span>                <span class="token keyword">if</span> n <span class="token operator">==</span> p<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># case 2 关注节点是其父节点的右子节点</span>                    self<span class="token punctuation">.</span>rotate_l<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 围绕关注节点的父节点左旋</span>                    n<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token punctuation">,</span> n  <span class="token comment" spellcheck="true"># 左旋后指针交换，关注节点设置为关注节点的父节点</span>                <span class="token comment" spellcheck="true"># case 3 关注节点是其父节点的左子节点</span>                p<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 关注节点的父节点设置为黑色</span>                g<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 关注节点的祖父节点设置为红色</span>                self<span class="token punctuation">.</span>rotate_r<span class="token punctuation">(</span>g<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 围绕关注节点的祖父节点右旋</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 父节点为祖父节点的右子结点</span>                <span class="token keyword">if</span> n <span class="token operator">==</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># case 2 关注节点是其父节点的左子节点</span>                    self<span class="token punctuation">.</span>rotate_r<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 围绕关注节点的父节点右旋</span>                    n<span class="token punctuation">,</span> p <span class="token operator">=</span> p<span class="token punctuation">,</span> n  <span class="token comment" spellcheck="true"># 右旋后指针交换，关注节点设置为关注节点的父节点</span>                <span class="token comment" spellcheck="true"># case 3 关注节点是其父节点的右子节点</span>                p<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 关注节点的父节点设置为黑色</span>                g<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 关注节点的祖父节点设置为红色</span>                self<span class="token punctuation">.</span>rotate_l<span class="token punctuation">(</span>g<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 围绕关注节点的祖父节点左旋</span>        <span class="token comment" spellcheck="true"># 根节点强制置黑，有两种情况根节点是红色：</span>        <span class="token comment" spellcheck="true"># 1. 新插入时是红色</span>        <span class="token comment" spellcheck="true"># 2. 经过case 1调整过后变红色</span>        self<span class="token punctuation">.</span>tree<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'black'</span>    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        n<span class="token punctuation">:</span> TreeNode <span class="token operator">=</span> self<span class="token punctuation">.</span>find<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">if</span> n <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment" spellcheck="true"># n的子节点个数等于2</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>children_count<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 寻找n的后继s</span>            s <span class="token operator">=</span> n<span class="token punctuation">.</span>right            <span class="token keyword">while</span> s<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>                s <span class="token operator">=</span> s<span class="token punctuation">.</span>left            n<span class="token punctuation">.</span>data <span class="token operator">=</span> s<span class="token punctuation">.</span>data            <span class="token comment" spellcheck="true"># 将删除n转化为删除s</span>            n <span class="token operator">=</span> s        <span class="token comment" spellcheck="true"># n的子节点个数小于2</span>        <span class="token keyword">if</span> n<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>            c <span class="token operator">=</span> n<span class="token punctuation">.</span>right        <span class="token keyword">else</span><span class="token punctuation">:</span>            c <span class="token operator">=</span> n<span class="token punctuation">.</span>left        self<span class="token punctuation">.</span>_transplant<span class="token punctuation">(</span>n<span class="token punctuation">,</span> c<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 删除的节点是黑色，需要调整</span>        <span class="token keyword">if</span> n<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_delete_fixup<span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">def</span> <span class="token function">_delete_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> node        <span class="token keyword">while</span> n <span class="token operator">!=</span> self<span class="token punctuation">.</span>tree <span class="token operator">and</span> n<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>n<span class="token punctuation">)</span>            b <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>n<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 左右节点对称</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>left <span class="token operator">==</span> n<span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> b<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    b<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    p<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    self<span class="token punctuation">.</span>rotate_l<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    <span class="token comment" spellcheck="true"># new bro after rotate</span>                    b <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                <span class="token keyword">if</span> b<span class="token punctuation">.</span>left<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> b<span class="token punctuation">.</span>right<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    b<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 2</span>                    n <span class="token operator">=</span> p  <span class="token comment" spellcheck="true"># case 2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> b<span class="token punctuation">.</span>right<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        b<span class="token punctuation">.</span>left<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        b<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        self<span class="token punctuation">.</span>rotate_r<span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        <span class="token comment" spellcheck="true"># new bro after rotate</span>                        b <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                    <span class="token comment" spellcheck="true"># 注意，因为p可能是红或黑，所以不能直接赋值颜色，只能copy</span>                    b<span class="token punctuation">.</span>color <span class="token operator">=</span> p<span class="token punctuation">.</span>color  <span class="token comment" spellcheck="true"># case 4</span>                    p<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    b<span class="token punctuation">.</span>right<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    self<span class="token punctuation">.</span>rotate_l<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    <span class="token comment" spellcheck="true"># trick, 调整结束跳出while</span>                    n <span class="token operator">=</span> self<span class="token punctuation">.</span>tree  <span class="token comment" spellcheck="true"># case 4</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> b<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    b<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    p<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    self<span class="token punctuation">.</span>rotate_r<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                    <span class="token comment" spellcheck="true"># new bro after rotate</span>                    b <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 1</span>                <span class="token keyword">if</span> b<span class="token punctuation">.</span>left<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> b<span class="token punctuation">.</span>right<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    b<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 2</span>                    n <span class="token operator">=</span> p  <span class="token comment" spellcheck="true"># case 2</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> b<span class="token punctuation">.</span>left<span class="token punctuation">.</span>is_black<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                        b<span class="token punctuation">.</span>right<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        b<span class="token punctuation">.</span>set_red<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        self<span class="token punctuation">.</span>rotate_l<span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                        <span class="token comment" spellcheck="true"># new bro after rotate</span>                        b <span class="token operator">=</span> self<span class="token punctuation">.</span>bro<span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 3</span>                    <span class="token comment" spellcheck="true"># 注意，因为p可能是红或黑，所以不能直接赋值颜色，只能copy</span>                    b<span class="token punctuation">.</span>color <span class="token operator">=</span> p<span class="token punctuation">.</span>color  <span class="token comment" spellcheck="true"># case 4</span>                    p<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    b<span class="token punctuation">.</span>left<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    self<span class="token punctuation">.</span>rotate_r<span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># case 4</span>                    <span class="token comment" spellcheck="true"># trick, 调整结束跳出while</span>                    n <span class="token operator">=</span> self<span class="token punctuation">.</span>tree  <span class="token comment" spellcheck="true"># case 4</span>        <span class="token comment" spellcheck="true"># 将n设为黑色，从上面while循环跳出，情况有两种</span>        <span class="token comment" spellcheck="true"># 1. n是根节点，直接无视附加的黑色</span>        <span class="token comment" spellcheck="true"># 2. n是红色的节点，则染黑</span>        n<span class="token punctuation">.</span>set_black<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_transplant</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        节点移植， n2 -> n1        :param n1: 原节点        :param n2: 移植节点        :return:        """</span>        <span class="token keyword">if</span> n1 <span class="token operator">==</span> self<span class="token punctuation">.</span>tree<span class="token punctuation">:</span>            <span class="token keyword">if</span> n2 <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>tree <span class="token operator">=</span> n2                n2<span class="token punctuation">.</span>parent <span class="token operator">=</span> None            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>tree <span class="token operator">=</span> None  <span class="token comment" spellcheck="true"># 只有删除根节点时会进来</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>n1<span class="token punctuation">)</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>left <span class="token operator">==</span> n1<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>left <span class="token operator">=</span> n2            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>right <span class="token operator">=</span> n2            n2<span class="token punctuation">.</span>parent <span class="token operator">=</span> p    <span class="token keyword">def</span> <span class="token function">rotate_l</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>right <span class="token keyword">is</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>            <span class="token keyword">return</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        x <span class="token operator">=</span> node        y <span class="token operator">=</span> node<span class="token punctuation">.</span>right        <span class="token comment" spellcheck="true"># node为根节点时，p为None，旋转后要更新根节点指向</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>left <span class="token operator">=</span> y            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>right <span class="token operator">=</span> y        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>tree <span class="token operator">=</span> y        x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> y<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">,</span> p        <span class="token keyword">if</span> y<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>            y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> x        x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> y<span class="token punctuation">.</span>left <span class="token operator">=</span> y<span class="token punctuation">.</span>left<span class="token punctuation">,</span> x    <span class="token keyword">def</span> <span class="token function">rotate_r</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token keyword">if</span> node<span class="token punctuation">.</span>left <span class="token keyword">is</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>            <span class="token keyword">return</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        x <span class="token operator">=</span> node        y <span class="token operator">=</span> node<span class="token punctuation">.</span>left        <span class="token comment" spellcheck="true"># 同左旋</span>        <span class="token keyword">if</span> p <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                p<span class="token punctuation">.</span>left <span class="token operator">=</span> y            <span class="token keyword">else</span><span class="token punctuation">:</span>                p<span class="token punctuation">.</span>right <span class="token operator">=</span> y        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>tree <span class="token operator">=</span> y        x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> y<span class="token punctuation">.</span>parent <span class="token operator">=</span> y<span class="token punctuation">,</span> p        <span class="token keyword">if</span> y<span class="token punctuation">.</span>right <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> x        x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> y<span class="token punctuation">.</span>right <span class="token operator">=</span> y<span class="token punctuation">.</span>right<span class="token punctuation">,</span> x    @staticmethod    <span class="token keyword">def</span> <span class="token function">bro</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        获取兄弟节点        """</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None <span class="token operator">or</span> node<span class="token punctuation">.</span>parent <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">else</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> node<span class="token punctuation">.</span>parent            <span class="token keyword">if</span> node <span class="token operator">==</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                <span class="token keyword">return</span> p<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> p<span class="token punctuation">.</span>left    @staticmethod    <span class="token keyword">def</span> <span class="token function">parent</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        获取父节点        """</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent    <span class="token keyword">def</span> <span class="token function">children_count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        获取子节点个数        """</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span>self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">draw_img</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img_name<span class="token operator">=</span><span class="token string">'Red_Black_Tree.png'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""用pygraphviz画红黑树"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span>        tree <span class="token operator">=</span> pgv<span class="token punctuation">.</span>AGraph<span class="token punctuation">(</span>directed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">]</span><span class="token punctuation">)</span>        num <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            e <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> e <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 黑色叶子的连线由各个节点自己画</span>                tree<span class="token punctuation">.</span>add_node<span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> color<span class="token operator">=</span>e<span class="token punctuation">.</span>color<span class="token punctuation">,</span> fontcolor<span class="token operator">=</span><span class="token string">"white"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"filled"</span><span class="token punctuation">,</span>                              fontname<span class="token operator">=</span><span class="token string">"Microsoft YaHei"</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token string">"circle"</span><span class="token punctuation">,</span> margin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> c <span class="token keyword">in</span> <span class="token punctuation">[</span>e<span class="token punctuation">.</span>left<span class="token punctuation">,</span> e<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">:</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                    <span class="token keyword">if</span> c <span class="token operator">!=</span> self<span class="token punctuation">.</span>black_leaf<span class="token punctuation">:</span>                        tree<span class="token punctuation">.</span>add_edge<span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> c<span class="token punctuation">.</span>data<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"blue"</span><span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        num <span class="token operator">+=</span> <span class="token number">1</span>                        tree<span class="token punctuation">.</span>add_node<span class="token punctuation">(</span><span class="token string">"nil%s"</span> <span class="token operator">%</span> num<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">"Nil"</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"black"</span><span class="token punctuation">,</span> fontcolor<span class="token operator">=</span><span class="token string">"white"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"filled"</span><span class="token punctuation">,</span>                                      fontname<span class="token operator">=</span><span class="token string">"Microsoft YaHei"</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token string">"circle"</span><span class="token punctuation">,</span> margin<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>                        tree<span class="token punctuation">.</span>add_edge<span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token string">"nil%s"</span> <span class="token operator">%</span> num<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">"blue"</span><span class="token punctuation">)</span>        tree<span class="token punctuation">.</span>graph_attr<span class="token punctuation">[</span><span class="token string">'epsilon'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0.01'</span>        tree<span class="token punctuation">.</span>layout<span class="token punctuation">(</span><span class="token string">'dot'</span><span class="token punctuation">)</span>        tree<span class="token punctuation">.</span>draw<span class="token punctuation">(</span>img_name<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    rbt <span class="token operator">=</span> RedBlackTree<span class="token punctuation">(</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        rbt<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    search_num <span class="token operator">=</span> <span class="token number">7</span>    n <span class="token operator">=</span> rbt<span class="token punctuation">.</span>find<span class="token punctuation">(</span>search_num<span class="token punctuation">)</span>    <span class="token keyword">if</span> n<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'node {} not found'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>search_num<span class="token punctuation">)</span><span class="token punctuation">)</span>    rbt<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    rbt<span class="token punctuation">.</span>draw_img<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="红黑树可视化效果"><a href="#红黑树可视化效果" class="headerlink" title="红黑树可视化效果"></a>红黑树可视化效果</h2><p><img src="imgs/d9yCzX5UJ6eT.png" alt="mark"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>13.二叉树基础</title>
      <link href="//post/13.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80.html"/>
      <url>//post/13.%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h1><h1 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h1><p>树是一种非线性表结构，比线性表的数据结构要复杂得多：</p><table><thead><tr><th align="center">树的种类</th></tr></thead><tbody><tr><td align="center">树，二叉树</td></tr><tr><td align="center">二叉查找树</td></tr><tr><td align="center">平衡二叉查找树、红黑树</td></tr><tr><td align="center">递归树</td></tr></tbody></table><p>“树”的特征：</p><p><img src="imgs/2/1570444279777.png" alt="1570444279777"></p><p>“树”这种数据结构里面每个元素叫作“节点”；用来连线相邻节点之间的关系叫作“父子关系”。</p><p>比如下面这幅图，A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。没有父节点的节点叫<strong>根节点</strong>，也就是图中的节点 E。没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><p><img src="imgs/2/1570444335291.png" alt="1570444335291"></p><p><strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）的定义：</p><pre><code>节点的高度=节点到叶子节点的最长路径(边数)节点的深度=根节点到这个节点所经历的边的个数节点的层数=节点的深度+1树的高度=根节点的高度</code></pre><p><img src="imgs/2/1570444363236.png" alt="1570444363236"></p><p>“高度”是从下往上度量，从最底层开始计数计数的起点是 0。</p><p>“深度”是从上往下度量，从根结点开始度量计数起点也是 0。</p><p>“层数”跟深度的计算类似，不过计数起点是 1。</p><h1 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h1><p>二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，需要用递归代码来实现。</p><p>二叉树是树的一种，特点是每个节点最多有两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。不过，二叉树有的节点只有左子节点，有的节点只有右子节点：</p><p><img src="imgs/2/1570444377068.png" alt="1570444377068"></p><p>上图编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p><p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树和非完全二叉树的区别：</p><p><img src="imgs/2/1570444390843.png" alt="1570444390843"></p><p>最后一层的叶子节点靠左排列的才叫完全二叉树，如果靠右排列就不能叫完全二叉树了。</p><p>存储一棵二叉树有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><p><strong>链式存储法</strong>中每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。从根节点开始可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p><p><img src="imgs/2/1570444403668.png" alt="1570444403668"></p><p>基于数组的<strong>顺序存储法</strong>：把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 <em> i = 2 的位置，右子节点存储在 2 </em> i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 <em> i = 2 </em> 2 = 4 的位置，右子节点存储在 2 <em> i + 1 = 2 </em> 2 + 1 = 5 的位置。</p><p><img src="imgs/2/1570444415962.png" alt="1570444415962"></p><p>如果节点 X 存储在数组中下标为 i 的位置，左子节点的下标为 2 <em> i ，右子节点的下标为 2 </em> i + 1。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），就可以通过下标计算，把整棵树都串起来。</p><p>一棵完全二叉树仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，会浪费比较多的数组存储空间：</p><p><img src="imgs/2/1570444429469.png" alt="1570444429469"></p><p>如果某棵二叉树是一棵完全二叉树，用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要存储额外的左右子节点的指针。</p><p>堆其实就是一种完全二叉树，最常用的存储方式是数组。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>将二叉树所有节点都遍历打印出来有三种方法，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li></ul><p><img src="imgs/2/1570444448382.png" alt="1570444448382"></p><p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><p>写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。前、中、后序遍历的递推公式：</p><pre class="line-numbers language-c"><code class="language-c">前序遍历的递推公式：<span class="token function">preOrder</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span> print r<span class="token operator">-></span><span class="token function">preOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">preOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>right<span class="token punctuation">)</span>中序遍历的递推公式：<span class="token function">inOrder</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token operator">-></span>print r<span class="token operator">-></span><span class="token function">inOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>right<span class="token punctuation">)</span>后序遍历的递推公式：<span class="token function">postOrder</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">postOrder</span><span class="token punctuation">(</span>r<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token operator">-></span>print r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>java伪代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  print root <span class="token comment" spellcheck="true">// 此处为伪代码，表示打印 root 节点</span>  <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  print root <span class="token comment" spellcheck="true">// 此处为伪代码，表示打印 root 节点</span>  <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  print root <span class="token comment" spellcheck="true">// 此处为伪代码，表示打印 root 节点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二叉树遍历的时间复杂度：</strong>遍历过程中每个节点最多会被访问两次，所以遍历操作的时间复杂度跟节点的个数 n 成正比，二叉树遍历的时间复杂度是 O(n)。</p><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>val <span class="token operator">=</span> value        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token comment" spellcheck="true"># 前序遍历</span><span class="token keyword">def</span> <span class="token function">pre_order</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">:</span>        <span class="token keyword">yield</span> root<span class="token punctuation">.</span>val        <span class="token keyword">yield</span> <span class="token keyword">from</span> pre_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">yield</span> <span class="token keyword">from</span> pre_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 中序遍历</span><span class="token keyword">def</span> <span class="token function">in_order</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token keyword">from</span> in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">yield</span> root<span class="token punctuation">.</span>val        <span class="token keyword">yield</span> <span class="token keyword">from</span> in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 后序遍历</span><span class="token keyword">def</span> <span class="token function">post_order</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> root<span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token keyword">from</span> post_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">yield</span> <span class="token keyword">from</span> post_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token keyword">yield</span> root<span class="token punctuation">.</span>val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="按层次遍历二叉树"><a href="#按层次遍历二叉树" class="headerlink" title="按层次遍历二叉树"></a>按层次遍历二叉树</h2><p>除了前、中、后序三种二叉树遍历方式外还有按层遍历这种遍历方式。</p><p>实现思路：</p><p>按照 广度优先的遍历算法的思路，引入一个队列，根节点先入队列，然后开始从队列头部取元素，每取一个元素则先打印当前元素，然后依次将左右子节点加入队列，若左子节点或右子节点为空则跳过此步。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token comment" spellcheck="true"># 层级遍历</span><span class="token keyword">def</span> <span class="token function">layer_order</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span>    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>        e<span class="token punctuation">:</span> TreeNode <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">yield</span> e<span class="token punctuation">.</span>val        <span class="token keyword">if</span> e<span class="token punctuation">.</span>left<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> e<span class="token punctuation">.</span>right<span class="token punctuation">:</span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应leetcode题目：</p><p> <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a> </p><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">level_order</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>    levels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>        <span class="token keyword">return</span> levels    level <span class="token operator">=</span> <span class="token number">0</span>    queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> queue<span class="token punctuation">:</span>        levels<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            levels<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        level <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> levels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="n个不同的数据可以构建出多少种不同的二叉树？"><a href="#n个不同的数据可以构建出多少种不同的二叉树？" class="headerlink" title="n个不同的数据可以构建出多少种不同的二叉树？"></a>n个不同的数据可以构建出多少种不同的二叉树？</h2><p>给定一组数据，比如 1，3，5，6，9，10。可以构建出多少种不同的二叉树？</p><p>答：</p><p>根据卡特兰数n个数据能产生$\frac{C_{2n}^{n}}{n+1}=\frac{(2n)!}{n!\cdot(n+1)!}$种二叉树形状</p><p>而n个数据能产生$A_n^n=n!$种排列组合</p><p>故n个不同的数据能构建出$n!\cdot\frac{(2n)!}{n!\cdot(n+1)!}=\frac{(2n)!}{(n+1)!}$种二叉树</p><p>题目中给定数据n=6,故能构建出$\frac{12!}{7!}=12<em>11</em>10<em>9</em>8=95040$种不同的二叉树。</p><p>完全二叉树是其中一种二叉树形状，故能构建出$n!$种完全二叉树，题目中给定数据n=6时，可以构建出720种完全二叉树。</p><h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。二叉查找树支持动态数据集合的快速插入、删除、查找操作。</p><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值都小于这个节点的值，而右子树每个节点的值都大于这个节点的值:</p><p><img src="imgs/2/1570444524770.png" alt="1570444524770"></p><h3 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1. 二叉查找树的查找操作"></a>1. 二叉查找树的查找操作</h3><p>先取根节点，如果它等于要查找的数据就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><p><img src="imgs/2/1570444541558.png" alt="1570444541558"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Node tree<span class="token punctuation">;</span>  <span class="token keyword">public</span> Node <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node p <span class="token operator">=</span> tree<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">></span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node left<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node right<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2. 二叉查找树的插入操作"></a>2. 二叉查找树的插入操作</h3><p>二叉查找树的插入过程需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src="imgs/2/1570444560417.png" alt="1570444560417"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Node p <span class="token operator">=</span> tree<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">></span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// data &lt; p.data</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-二叉查找树的删除操作"><a href="#3-二叉查找树的删除操作" class="headerlink" title="3. 二叉查找树的删除操作"></a>3. 二叉查找树的删除操作</h3><p>针对要删除节点的子节点个数的不同需要分2种情况来处理。</p><p>如果要删除的节点只有一个子节点（只有左子节点或者右子节点）或没有子节点（左右子节点均为Null），只需要要将要删除节点的父节点的指针指向要删除节点的子节点。比如下图中删除节点 55、 13。</p><p>如果要删除的节点有两个子节点。需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再按照上面方法删除掉这个最小节点。比如下图中的删除节点 18。（用左子树的最大节点进行替换也可以）</p><p><img src="imgs/2/1570444574980.png" alt="1570444574980"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node p <span class="token operator">=</span> tree<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p 指向要删除的节点，初始化指向根节点</span>  Node pp <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// pp 记录的是 p 的父节点</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">></span> p<span class="token punctuation">.</span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token keyword">else</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有找到</span>  <span class="token comment" spellcheck="true">// 要删除的节点有两个子节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 查找右子树中最小节点</span>    Node minP <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    Node minPP <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// minPP 表示 minP 的父节点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>minP<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      minPP <span class="token operator">=</span> minP<span class="token punctuation">;</span>      minP <span class="token operator">=</span> minP<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span>data <span class="token operator">=</span> minP<span class="token punctuation">.</span>data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 minP 的数据替换到 p 中</span>    p <span class="token operator">=</span> minP<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下面就变成了删除 minP 了</span>    pp <span class="token operator">=</span> minPP<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 删除节点是叶子节点或者仅有一个子节点</span>  Node child<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// p 的子节点</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span> child <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span> child <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>  <span class="token keyword">else</span> child <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pp <span class="token operator">==</span> null<span class="token punctuation">)</span> tree <span class="token operator">=</span> child<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 删除的是根节点</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">)</span> pp<span class="token punctuation">.</span>left <span class="token operator">=</span> child<span class="token punctuation">;</span>  <span class="token keyword">else</span> pp<span class="token punctuation">.</span>right <span class="token operator">=</span> child<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于二叉查找树的删除操作，最简单的方法是单纯将要删除的节点标记为“已删除”并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，缺点是比较浪费内存空间。</p><h3 id="4-二叉查找树的其他操作"><a href="#4-二叉查找树的其他操作" class="headerlink" title="4. 二叉查找树的其他操作"></a>4. 二叉查找树的其他操作</h3><p>二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</p><p>二叉查找树也叫作二叉排序树，<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)</strong>。</p><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">find_min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left        <span class="token keyword">return</span> p    <span class="token keyword">def</span> <span class="token function">find_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right        <span class="token keyword">return</span> p    <span class="token keyword">def</span> <span class="token function">_in_order</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            <span class="token keyword">yield</span> <span class="token keyword">from</span> self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">yield</span> root<span class="token punctuation">.</span>data            <span class="token keyword">yield</span> <span class="token keyword">from</span> self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">in_order</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉查找树的python实现代码"><a href="#二叉查找树的python实现代码" class="headerlink" title="二叉查找树的python实现代码"></a>二叉查找树的python实现代码</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque<span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token punctuation">,</span> List<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>left <span class="token operator">=</span> None        self<span class="token punctuation">.</span>right <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val_list<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> val_list <span class="token keyword">is</span> None<span class="token punctuation">:</span>            val_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>tree<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span> <span class="token operator">=</span> None        <span class="token keyword">for</span> n <span class="token keyword">in</span> val_list<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p <span class="token operator">and</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> data<span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left <span class="token keyword">if</span> data <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>data <span class="token keyword">else</span> p<span class="token punctuation">.</span>right        <span class="token keyword">return</span> p    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>tree<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>tree <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">return</span>        pp <span class="token operator">=</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            pp <span class="token operator">=</span> p            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left <span class="token keyword">if</span> p<span class="token punctuation">.</span>data <span class="token operator">></span> data <span class="token keyword">else</span> p<span class="token punctuation">.</span>right        <span class="token keyword">if</span> pp<span class="token punctuation">.</span>data <span class="token operator">></span> data<span class="token punctuation">:</span>            pp<span class="token punctuation">.</span>left <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            pp<span class="token punctuation">.</span>right <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        p<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>tree  <span class="token comment" spellcheck="true"># p指向要删除的节点，初始化指向根节点</span>        pp<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span> <span class="token operator">=</span> None  <span class="token comment" spellcheck="true"># pp记录的是p的父节点</span>        <span class="token keyword">while</span> p <span class="token operator">and</span> p<span class="token punctuation">.</span>data <span class="token operator">!=</span> data<span class="token punctuation">:</span>            pp <span class="token operator">=</span> p            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token keyword">if</span> p<span class="token punctuation">.</span>data <span class="token operator">&lt;</span> data <span class="token keyword">else</span> p<span class="token punctuation">.</span>left        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span>  <span class="token comment" spellcheck="true"># 没有找到</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>left <span class="token operator">and</span> p<span class="token punctuation">.</span>right<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 查找右子树中最小节点</span>            min_p <span class="token operator">=</span> p<span class="token punctuation">.</span>right  <span class="token comment" spellcheck="true"># 记录右子树的最小节点</span>            min_pp <span class="token operator">=</span> p  <span class="token comment" spellcheck="true"># minPP表示minP的父节点</span>            <span class="token keyword">while</span> min_p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                min_pp <span class="token operator">=</span> min_p                min_p <span class="token operator">=</span> min_p<span class="token punctuation">.</span>left            p<span class="token punctuation">.</span>data <span class="token operator">=</span> min_p<span class="token punctuation">.</span>data  <span class="token comment" spellcheck="true"># 替换数据</span>            p<span class="token punctuation">,</span> pp <span class="token operator">=</span> min_p<span class="token punctuation">,</span> min_pp  <span class="token comment" spellcheck="true"># p指向要删除的min_p</span>        <span class="token comment" spellcheck="true">#  删除节点是叶子节点或者仅有一个子节点</span>        child<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">.</span>left <span class="token keyword">if</span> p<span class="token punctuation">.</span>left <span class="token keyword">else</span> p<span class="token punctuation">.</span>right        <span class="token keyword">if</span> <span class="token operator">not</span> pp<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>tree <span class="token operator">=</span> child  <span class="token comment" spellcheck="true"># 删除的是根节点</span>        <span class="token keyword">elif</span> pp<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">:</span>            pp<span class="token punctuation">.</span>left <span class="token operator">=</span> child        <span class="token keyword">else</span><span class="token punctuation">:</span>            pp<span class="token punctuation">.</span>right <span class="token operator">=</span> child    <span class="token keyword">def</span> <span class="token function">find_min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p<span class="token punctuation">.</span>left<span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left        <span class="token keyword">return</span> p    <span class="token keyword">def</span> <span class="token function">find_max</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> None        p <span class="token operator">=</span> self<span class="token punctuation">.</span>tree        <span class="token keyword">while</span> p<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>right        <span class="token keyword">return</span> p    <span class="token keyword">def</span> <span class="token function">_in_order</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> root<span class="token punctuation">:</span>            <span class="token keyword">yield</span> <span class="token keyword">from</span> self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            <span class="token keyword">yield</span> root<span class="token punctuation">.</span>data            <span class="token keyword">yield</span> <span class="token keyword">from</span> self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">in_order</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tree <span class="token keyword">is</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> list<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>in_order<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_in_order<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">draw_tree</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>tree<span class="token punctuation">:</span>            <span class="token keyword">return</span>        <span class="token comment" spellcheck="true"># level = 0</span>        queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>tree<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            length <span class="token operator">=</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>            <span class="token keyword">if</span> set<span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">{</span>None<span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token keyword">return</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">:</span>                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> node<span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>data<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>None<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>None<span class="token punctuation">)</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>None<span class="token punctuation">)</span>                <span class="token keyword">if</span> i <span class="token operator">!=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>    bst <span class="token operator">=</span> BinarySearchTree<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span>    bst<span class="token punctuation">.</span>draw_tree<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 插入</span>    bst<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 删除</span>    bst<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span>    bst<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">)</span>    bst<span class="token punctuation">.</span>draw_tree<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># min max</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>find_max<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>bst<span class="token punctuation">.</span>find_min<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>在实际的软件开发中，在二叉查找树中存储的，是一个包含很多字段的对象。利用对象的某个字段作为键值（key）来构建二叉查找树，对象中的其他字段叫作卫星数据。</p><p>如果存储的两个对象键值相同的两种解决方法：</p><p>1.二叉查找树中每一个节点存储链表或支持动态扩容的数组，把值相同的数据都存储在同一个节点上。</p><p>2.每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，就把这个新插入的数据当作大于这个节点的值来处理，放到这个节点的右子树。</p><p><img src="imgs/2/1570444644303.png" alt="1570444644303"></p><p>查找数据的时候，遇到值相同的节点并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p><img src="imgs/2/1570444657714.png" alt="1570444657714"></p><p>对于删除操作也需要先查找到每个要删除的节点，然后再依次删除。</p><p><img src="imgs/2/1570444672716.png" alt="1570444672716"></p><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>二叉查找树的形态各式各样。下图中同一组数据构造的三种二叉查找树，它们的查找、插入、删除操作的执行效率都是不一样的。</p><p>不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。</p><p><img src="imgs/2/1570444686811.png" alt="1570444686811"></p><p>上图中，第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p>最理想的情况下，二叉查找树是一棵完全二叉树（或满二叉树），插入、删除、查找操作时间复杂度是 $O(logn)$</p><p>树的高度就等于最大层数减1，包含 n 个节点的满二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 $2^{K-1}$。</p><p>对于完全二叉树来说，最后一层的节点个数在 1 到 $2^{K-1}$个之间（假设最大层数是 K）。 n 满足这样一个关系：<br>$$<br>1+2+4+8+…+2^{K-2}+1 &lt;= n &lt;= 1+2+4+8+…+2^{K-2}+2^{K-1} \<br>\Rightarrow 2^{K-1} &lt;= n &lt;= 2^K-1 \<br>\Rightarrow log_2(n+1) &lt;= K &lt;= log_2{n}+1<br>$$<br>K 的范围是$[log_2(n+1),log_2{n}+1]$。完全二叉树的层数小于等于$log_2{n}+1$，即高度小于等于$log_2{n}$。</p><h2 id="散列表vs二叉查找树"><a href="#散列表vs二叉查找树" class="headerlink" title="散列表vs二叉查找树"></a>散列表vs二叉查找树</h2><p>散列表的优势：</p><p>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 $O(logn)$。</p><p>散列表的劣势：</p><p>我认为有下面几个原因：</p><p>第一，散列表要输出有序的数据，需要先进行排序；二叉查找树只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定；最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p>第三，因为哈希冲突的存在，散列表的实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的。</p><h2 id="求给定二叉树的确切高度"><a href="#求给定二叉树的确切高度" class="headerlink" title="求给定二叉树的确切高度"></a>求给定二叉树的确切高度</h2><p>思路：</p><p>递归法，根节点高度=max(左子树高度，右子树高度)+1 </p><p>实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_level</span><span class="token punctuation">(</span>node<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token keyword">return</span> max<span class="token punctuation">(</span>get_level<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> get_level<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>12.哈希算法</title>
      <link href="//post/12.%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html"/>
      <url>//post/12.%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>哈希算法是指将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。</p><p>要设计一个优秀的哈希算法需要满足的几点要求：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ul><p>哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。比如，我们把今天一篇包含 4000 多个汉字的文章，用 MD5 计算哈希值，用不了 1ms 的时间。</p><h1 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h1><p>最常见的应用分别是<strong>安全加密、唯一标识、数据校验、散列函数</strong>。</p><p>在分布式系统中的应用有<strong>负载均衡、数据分片、分布式存储</strong>。</p><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><p>最常用于加密的哈希算法是<strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、<strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）、<strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p><p><strong>为什么哈希算法无法做到零冲突？</strong></p><p>鸽巢原理（也叫抽屉原理）是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p><p>哈希算法产生的哈希值的长度是固定且有限的。比如 MD5 的哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 $2^{128}$ 个数据，但要哈希的数据是无穷的。基于鸽巢原理，如果对 $2^{128}+1$ 个数据求哈希值，就必然会存在哈希值相同的情况。当然，哈希值越长的哈希算法，散列冲突的概率越低。</p><pre><code>2^128=340282366920938463463374607431768211456</code></pre><p>但MD5有  $2^{128}$ 个不同的哈希值，散列冲突的概率小于  $\frac{1}{2^{128}}$，冲突的概率极低。</p><p>通过毫无规律的穷举的方法，找到跟一个 MD5 值相同的另一个数据，那耗费的时间是个天文数字。没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。</p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>如果要在海量的图库中，搜索一张图是否存在 ，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。</p><p>给每一个图片取一个唯一标识，即信息摘要。比如，从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>如果还想继续提高效率，可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p><p>如果不存在，那就说明这个图片不在图库中；如果存在，再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>BT 下载是基于 P2P 协议的，比如下载一个电影文件，BT 下载会从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p><p>但网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。</p><p>种子文件保存了 100 个文件块的哈希值。当文件块下载完成之后，通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>散列函数也是哈希算法的一种应用，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。</p><p>散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布。</p><p>另外，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h2><p>负载均衡算法有轮询、随机、加权轮询等。</p><p>一个会话粘滞（session sticky）的负载均衡算法是指在同一个客户端上一次会话中的所有请求都路由到同一个服务器上。</p><p>实现方法：</p><p><strong>通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</strong> </p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><p>哈希算法还可以用于数据的分片：</p><p><strong>1.假如1T 的日志文件，里面记录了用户的搜索关键词，想要快速统计出每个关键词被搜索的次数，该怎么做呢？</strong></p><p>问题：搜索日志很大，没办法放到一台机器的内存中；如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p><p>具体解决的思路：为了提高处理的速度，用 n 台机器并行处理。从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值分配到指定的机器上。</p><p>哈希值相同的搜索关键词会被分配到同一个机器上，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p>这个处理过程也是 MapReduce 的基本设计思想。</p><p><strong>2. 如何快速判断图片是否在图库中（图库中有 1 亿张以上的海量图片）？</strong></p><p>基本方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。</p><p>问题： 1 亿张图片构建散列表远远超过了单台机器的内存上限。</p><p><strong>解决思路：</strong></p><p>准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。每次从图库中读取一个图片，计算唯一标识与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p><p><strong>给 1 亿张图片构建散列表所需存储空间估算：</strong></p><p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设通过 MD5 来计算哈希值，那长度就是 128 比特， 16 字节。文件路径长度的上限是 256 字节，可以假设平均长度是 128 字节。如果用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中平均每个数据单元就占用 152 字节。</p><p>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以对 1 亿张图片构建索引，大约需要十几台机器。</p><p>这种估算能事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。</p><h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>现在互联网面对的都是海量的数据、海量的用户，为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。有海量的数据需要缓存，一个缓存机器肯定是不够的，就需要将数据分布在多台机器上。</p><p>随着数据增多就需要增加机器扩容了，但一旦扩容所有的数据都要重新计算哈希值，缓存中的数据一下子都失效了。</p><p><img src="imgs/2/1570443690705.png" alt="1570443690705"></p><p>引入<strong>一致性哈希算法</strong>可以使得在新加入一个机器后，并不需要做大量的数据搬移。</p><h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><ol><li><p>首先用哈希算法求出服务器（一般用ip地址或主机名）的哈希值与$2^{32}$取模，将其映射到$0～2^{32}$的Hash环上。</p></li><li><p>然后采用同样的哈希算法求出存储数据的键的哈希值与$2^{32}$取模，映射到相同的Hash环上。</p></li><li><p>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。由于映射在环上，超过$2^{32}$仍然找不到服务器就会指向第一台服务器。</p><p><img src="imgs/498077-20160822172408386-366341651.png" alt="img"> </p></li></ol><p>当添加一台机器node5时，先计算hash值与$2^{32}$取模并映射到Hash环上，然后将顺时针指向node5的数据从原本指向的node4迁移到node5机器上：</p><p> <img src="imgs/498077-20160822172431933-546286787.png" alt="img"> </p><p>如果node5节点出现故障宕机，则数据分布又会重新恢复到上图的特点。</p><h2 id="Hash环的偏斜"><a href="#Hash环的偏斜" class="headerlink" title="Hash环的偏斜"></a>Hash环的偏斜</h2><p>上面描述了比较理想的情况，但在实际的映射中，服务器可能会被映射成如下模样： </p><p> <img src="imgs/496275-20180527124958975-24745120.png" alt="img"> </p><p>这样大部分缓存数据都被映射到了服务器A节点上。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>对于上面的情况，如果想要均衡地将缓存分布到三台服务器上，最佳办法是将现有的物理节点通过虚拟的方法复制出来映射到Hash环上，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash环如下： </p><p> <img src="imgs/496275-20180527123823742-514849225.png" alt="img"> </p><p> “虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品，一个实际节点可以对应多个虚拟节点。上图中A、B、C三台服务器分别虚拟出了一个虚拟节点。实际可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。 </p><p>假设有4个物理节点Node，虚拟节点可设置为160个，此时可带来较好的均匀分布：</p><p> <img src="imgs/8926909-e188847813d04828.webp" alt="img"> </p><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设NODE1的IP地址为192.168.1.100。引入“虚拟节点”前，计算 cache A 的 hash 值：</p><blockquote><p>Hash(“192.168.1.100”);</p></blockquote><p>引入“虚拟节点”后，计算“虚拟节”点NODE1-1和NODE1-2的hash值：</p><blockquote><p>Hash(“192.168.1.100#1”); // NODE1-1<br>Hash(“192.168.1.100#2”); // NODE1-2</p></blockquote><h1 id="哈希算法的其他应用"><a href="#哈希算法的其他应用" class="headerlink" title="哈希算法的其他应用"></a>哈希算法的其他应用</h1><p>比如网络协议中的 CRC 校验、Git commit id 等等。</p><p>Hash算法在信息安全方面的应用主要体现在以下的3个方面：</p><p>1.文件校验</p><p>常见校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，但却不能防止对数据的恶意破坏。</p><p> MD5 Hash算法的“数字指纹”特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。</p><p>2.数字签名</p><p>Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。 对 Hash 值，又称“数字摘要”进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。</p><p>3.鉴权协议<br>鉴权协议又被称作挑战–认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</p><h1 id="如何防止数据库中的用户信息被脱库？"><a href="#如何防止数据库中的用户信息被脱库？" class="headerlink" title="如何防止数据库中的用户信息被脱库？"></a>如何防止数据库中的用户信息被脱库？</h1><p>引入一个盐（salt），跟用户的密码组合在一起，拿组合之后的字符串来做哈希算法加密，将它存储到数据库中。</p><p>不过安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</p><h1 id="区块链-amp-比特币"><a href="#区块链-amp-比特币" class="headerlink" title="区块链&amp;比特币"></a>区块链&amp;比特币</h1><p>区块链是由包含交易信息的区块从后向前有序链接起来的数据结构.  它可以被存储为flat file (一种包含非相对关系记录的文件),或是存储在一个简单数据库中.比特币核心(Bitcoin Core)客户端使用Google的LeveLDB数据库存储区块链元数据.区块被从后向前有序地链接在这个链条里,每个区块都指向前一个区块.</p><p>区块链经常被视为一个垂直的栈,第一个区块作为栈底的首区块,随后每个区块都被放置在其他区块之上.用栈来形象化表示区块依次堆叠这一概念后, 我们便可以使用一些术语,例如,”高度”来表示区块与首区块之间的距离;以及用”顶部”或”顶端”来表示最新添加的区块. </p><p>对每个区块头进行SHA256加密哈希,可生成一个哈希值.通过这个哈希值, 可以识别出区块链中的对应区块.同时,每一个区块都可以通过其区块头的”父区块哈希值”字段引用前一区块(父区块).也就是说,每个区块头都包含它的父区块哈希值.这样把每个区块链接到各自父区块的哈希值序列就创建了一条一直可以追溯到第一区块(创世区块）的链条.</p><p>虽然每个区块都只有一个父区块,但可以暂时拥有多个子区块.每个子区块都将同一区块作为其父区块，并且在”父区块哈希值”字段中具有相同的(父区块)哈希值.一个区块出现多个子区块的情况被称为”区块链分叉”.区块链分义只是暂时状态,只有当多个不同区块几乎同时被不同的矿工发现时才会发生. 最终,只有一个子区块会成为区块链的一部分,同时解决了”区块链分叉”的问题.尽管一个区块可能会有不止一个子区块,但每个区块只有一个父区块,这是因为一个区块只有一个”父区块哈希值”字段可以指向它的唯一父区块.</p><p>由于区块头里面包含”父区块哈希值”字段,所以当前区块的哈希值因此也受到该字段的影响.如果父区块的身份标识发生变化,子区块的身份标识也会跟看变化.当父区块有任何改动时,父区块的哈希值也发生变化。父区块的哈希值发生改变将迫使子区块的”父区块哈希值”字段发生改变,从而又将导致子区块的哈希值发生改变.而子区块的哈希值发生改变又将迫使孙区块的”父区块哈希值”字段发生改变,又因此改变了孙区块哈希值,等等,以此类推.一旦一个区块自很多代以后,这种<strong>瀑布效应</strong>将保证该区块不会被改变,除非强制重新计算该区块所有后续的区块.正是因为这样的重新计算需要耗费巨大的计算量,所以一个长区块链的存在可以让区块链的历史不可改变，这也是比特巾安全性的一个关键特征.</p><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>区块是一种被包含在公开账簿(区块链)里的聚合了交易信息的容器数据结构.它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成.区块头是80字节,而平均每个交易至少是250字节,而且平均每个区块至少包含超过500个交易.因此, 一个包含所有交易的元整区块比区块头的1000倍还要大.下表描述了一个区块结构. </p><p> <img src="imgs/v2-a576dfe6a192cca2a055ceb59a49ac27_hd.jpg" alt="img"> </p><h2 id="区块头（区块中的B段）"><a href="#区块头（区块中的B段）" class="headerlink" title="区块头（区块中的B段）"></a>区块头（区块中的B段）</h2><p>区块头由三组区块元数据组成.首先是一组引用父区块哈希值的数据,这组元数据用于将该区块与区块链中前一区块相连接。第二组元数据 即难度、时间戳和Nonce,与挖矿竞争相关.第三组元数据是Merkle树根(一种用来有效地总结区块中所有交易的数据结构） </p><p> <img src="imgs/v2-d1ff6d696834fa2d02bcae74b5cbc0af_hd.jpg" alt="img"> </p><p> <img src="imgs/1475054023258693.jpg" alt="img"> </p><h2 id="挖矿算法"><a href="#挖矿算法" class="headerlink" title="挖矿算法"></a>挖矿算法</h2><p>比特币挖矿的算法，可以简单地总结为<strong>对区块头做两次sha256哈希运算，得到的结果如果小于区块头中规定的难度目标，即挖矿成功</strong>。 </p><p><img src="imgs/1571762267701.png" alt="1571762267701"></p><p>挖矿的算法可以用python代码表达为：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> nonce <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    block_header <span class="token operator">=</span> version <span class="token operator">+</span> previous_block_hash <span class="token operator">+</span> merkle_root <span class="token operator">+</span> time <span class="token operator">+</span> target_bits <span class="token operator">+</span> nonce    <span class="token keyword">if</span> sha256<span class="token punctuation">(</span>sha256<span class="token punctuation">(</span>block_header<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> target_bits<span class="token punctuation">:</span>        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>挖矿的流程可以定义为四个阶段：</p><ol><li>验证和筛选交易</li><li>计算Merkle root</li><li>计算区块头</li><li>穷举nonce计算hash</li></ol><h3 id="验证和筛选交易"><a href="#验证和筛选交易" class="headerlink" title="验证和筛选交易"></a>验证和筛选交易</h3><p>挖矿节点首先对交易做验证，剔除有问题的，然后通过一套自定义的标准来选择哪些交易希望打包进区块，比如通过交易费与交易占用的字节大小的比值超过某个门槛来判断，这样的交易才被认为有利可图。当然，节点也可以特意选择要加入某条交易，或者故意忽略某些交易，每个挖矿节点有很大的自由裁度权力。如果是通过矿池挖矿的话，矿池的服务器会去筛选交易，然后分配给每个参与的矿机一个独立的任务。这个任务的难度小于总的挖矿难度，通过完成较小难度的计算，来确认自己参与的份额。每台不同的矿机计算的问题不会重复，当其中一台矿机成功挖矿时，所有矿机依据确认的工作量来分配收益。</p><h3 id="计算Merkle-root"><a href="#计算Merkle-root" class="headerlink" title="计算Merkle root"></a>计算Merkle root</h3><p>一旦筛选好交易数据，按照时间排序，两两哈希，层层约减，通过这些交易就可以计算出一棵Merkle树，可以确定一个唯一的摘要，这就是Merkl树的根。Merkle树中，任何节点的变化，都会导致merkle root发生变化，通过这个值，可以用来验证区块中的交易数据是否被改动过。</p><pre class="line-numbers language-python"><code class="language-python">ABCDEEEE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Merkle root      <span class="token operator">/</span>        \   ABCD        EEEE  <span class="token operator">/</span>    \      <span class="token operator">/</span> AB    CD    EE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>E与自己配对<span class="token punctuation">,</span>奇数树叶时<span class="token operator">/</span>  \  <span class="token operator">/</span>  \  <span class="token operator">/</span>A  B  C  D  E <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>交易<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算区块头"><a href="#计算区块头" class="headerlink" title="计算区块头"></a>计算区块头</h3><p>依次获取挖矿需要的每一项区块头信息。 区块头只有80个字节，挖矿只需要对区块头进行运算即可。区块头中的信息，在挖矿前大部分已经是固定的，或者是容易计算的。区块中的交易数据虽然很大，但是已经通过Merkle树固定了下来，不需要再包含进来。</p><p>逐项准备需要的数字：</p><p><strong>版本号</strong></p><p>跟随比特币客户端而定，一段时间内不会改变。即使要改变，也会有比特币的核心开发人员来协调升级策略，这个可以理解为一个静态常数。</p><p><strong>前一区块摘要</strong></p><p>一次哈希即可。前一区块已经是打包好的。</p><p><strong>默克尔根</strong></p><p>刚才已经得到了结果，根据本次交易包含的交易列表得到。</p><p><strong>时间</strong></p><p>取打包时的时间。也不需要很精确，前后几秒，几十秒也都可以。</p><p><strong>难度目标</strong></p><p>参考上两周产生的区块的平均生成时间而定。两周内如果平均10分钟产生一个区块的话，两周会产生2016个区块，软件会计算最新的2016个区块生成的时间，然后做对比，随之调整难度，使得接下来产生的区块的预期时间保持在10分钟左右。因为最近的2016个区块已经确定，所以这个数字也是确定的。</p><p><strong>随机数nonce</strong></p><p>这个就是挖矿的目标了。这是一个32位的数字。</p><h3 id="穷举nonce计算hash"><a href="#穷举nonce计算hash" class="headerlink" title="穷举nonce计算hash"></a>穷举nonce计算hash</h3><p>随机数可以变化，而且要从0试到最大值2^32。直到最后出现的hash结果，其数字低于难度目标值。不过以现在的计算机算力，一台矿机用不了一秒就把全部的变化可能计算完了，所以还需要改变区块内部的创币交易中的附带消息，这样就让merkle root也发生了变化，从而有更多的可能去找到符合要求的nonce。</p><p>挖矿中，第一笔交易是新发的比特币，接收方就是矿工指定的地址，这是挖矿中最大的奖励；另外一小部分来自交易手续费。这笔交易没有输入方，称为创币交易。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.散列表</title>
      <link href="//post/11.%E6%95%A3%E5%88%97%E8%A1%A8.html"/>
      <url>//post/11.%E6%95%A3%E5%88%97%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><p>散列表的英文叫“Hash Table”，也叫它“哈希表”或者“Hash 表”，<strong>散列表用的是数组支持按照下标随机访问数据的特性，是数组的一种扩展。</strong></p><p>散列表利用了数组按照下标随机访问的时候时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><p><img src="imgs/2/1570442938362.png" alt="1570442938362"></p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数，可以定义成hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成<strong>hash(key)</strong>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p>散列函数设计的三点基本要求：</p><ol><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li></ol><p>对于第一点，因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。</p><p>对于第二点，相同的 key，经过散列函数得到的散列值也应该是相同的。</p><p>对于第三点，几乎无法找到一个完美的无冲突的散列函数，即便像业界著名的<a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5</a>、<a href="https://zh.wikipedia.org/wiki/SHA家族" target="_blank" rel="noopener">SHA</a>、<a href="https://zh.wikipedia.org/wiki/循環冗餘校驗" target="_blank" rel="noopener">CRC</a>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。针对散列冲突问题，需要通过其他途径来解决。</p><h2 id="解决散列冲突问题的两种方法"><a href="#解决散列冲突问题的两种方法" class="headerlink" title="解决散列冲突问题的两种方法"></a>解决散列冲突问题的两种方法</h2><p>常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，就重新探测一个空闲位置，将其插入。</p><p>探测新的位置的方法有<strong>线性探测</strong>（Linear Probing）、<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）</p><p><strong>线性探测：</strong></p><p>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>下图黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p><p><img src="imgs/2/1570442960343.png" alt="1570442960343"></p><p>图中散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我顺序地往后一个一个找，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p><p>在散列表中查找元素，会先通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p><p><img src="imgs/2/1570442976703.png" alt="1570442976703"></p><p>使用线性探测法解决冲突的散列表，对于删除操作，会将被删除的元素特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p><p><img src="imgs/2/1570442999808.png" alt="1570442999808"></p><p><strong>线性探测法存在的问题：</strong></p><p>当散列表中插入的数据越来越多时，散列冲突发生的可能性越来越大，空闲位置越来越少，线性探测的时间越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p><strong>二次探测：</strong></p><p>线性探测每次探测的步长是 1，它探测的下标序列是 $hash(key)+0$，$hash(key)+1$，$hash(key)+2$……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 $hash(key)+0$，$hash(key)+1^2$，$hash(key)+2^2$……</p><p><strong>双重散列：</strong></p><p>并不只用一个散列函数，而是同时使用一组散列函数 $hash1(key)，hash2(key)，hash3(key)……$先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><h3 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2. 链表法"></a>2. 链表法</h3><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p><img src="imgs/2/1570443033230.png" alt="1570443033230"></p><p>插入的时候只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p><p>查找或删除操作的时间复杂度跟链表的长度 k 成正比，即 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p><h2 id="Word的单词拼写检查功能是如何实现的？"><a href="#Word的单词拼写检查功能是如何实现的？" class="headerlink" title="Word的单词拼写检查功能是如何实现的？"></a>Word的单词拼写检查功能是如何实现的？</h2><p>Word 这种文本编辑器能自动识别错误的英文单词，用标红的方式提示“拼写错误”。<strong>Word 的这个单词拼写检查功能是如何实现的呢？</strong></p><p>解决思路：</p><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>1.假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p><p>解决思路：</p><p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p><p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用一般的排序方法，复杂度 $O(NlogN)$。 </p><p>模拟实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>__author__ <span class="token operator">=</span> <span class="token string">'xiaoxiaoming'</span>url_count_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"access.log"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        url <span class="token operator">=</span> line<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            value <span class="token operator">=</span> url_count_dict<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>            url_count_dict<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> value            <span class="token keyword">if</span> value <span class="token operator">></span> k<span class="token punctuation">:</span> k <span class="token operator">=</span> valueresult <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># k不大可以使用桶排序,每个次数一个桶</span><span class="token keyword">if</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将数组中值分配到各个桶里</span>    <span class="token keyword">for</span> url<span class="token punctuation">,</span> value <span class="token keyword">in</span> url_count_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">[</span>value <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">for</span> value <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>buckets<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> url <span class="token keyword">in</span> buckets<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> sorted<span class="token punctuation">(</span>url_count_dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">for</span> x <span class="token keyword">in</span> result<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p><p>思路：</p><p>将两个字符串数组分别存入散列表中，遍历其中一个散列表，每个遍历出来的字符串都去另一个散列表中查找，若找到则说明该字符串为公共字符串。 </p><p>python简易实现：</p><pre class="line-numbers language-python"><code class="language-python">arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">]</span>arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'Apricot'</span><span class="token punctuation">,</span><span class="token string">'Avocado'</span><span class="token punctuation">]</span>common_str <span class="token operator">=</span> set<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> set<span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>common_str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="散列表的设计"><a href="#散列表的设计" class="headerlink" title="散列表的设计"></a>散列表的设计</h1><p>散列函数要尽可能让散列后的值随机且均匀分布，尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。</p><p>关于散列冲突解决方法的选择，大部分情况下，链表法更加普适。还可以将链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)。对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p><p>对于动态散列表来说，随着数据的不断增加，散列表总会出现装载因子过高的情况，这个时候需要启动动态扩容。</p><p><strong>工业级的散列表的特性：</strong></p><ul><li>支持快速的查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多的内存空间；</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li></ul><p><strong>散列表的设计思路：</strong></p><ul><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法。</li></ul><p>散列表的查询效率并不都是 O(1)，它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，所有的数据经过散列函数之后，可能都散列到同一个槽里，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><h2 id="设计良好的散列函数"><a href="#设计良好的散列函数" class="headerlink" title="设计良好的散列函数"></a>设计良好的散列函数</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。</p><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>需要综合考虑关键字的长度、特点、分布、还有散列表的大小等各种因素。</p><p>实现 Word 拼写检查功能的散列函数可以这样设计：将单词中每个字母的<a href="http://www.96yx.com/tool/ASC2.htm" target="_blank" rel="noopener">ASCll 码</a><a href="http://www.96yx.com/tool/ASC2.htm" target="_blank" rel="noopener">值</a>“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。</p><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hash_code</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token number">0</span>    base <span class="token operator">=</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> result <span class="token operator">*</span> <span class="token number">26</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ord<span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如，英文单词 nice，我们转化出来的散列值就是下面这样：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">hash</span><span class="token punctuation">(</span><span class="token string">"nice"</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"n"</span> <span class="token operator">-</span> <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">"i"</span> <span class="token operator">-</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">*</span><span class="token number">26</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">"c"</span> <span class="token operator">-</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">26</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">"e"</span><span class="token operator">-</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">78978</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>散列函数的设计方法还有直接寻址法、平方取中法、折叠法、随机数法等，根据实际情况设计即可。</p><h2 id="装载因子过大时需要进行动态扩容"><a href="#装载因子过大时需要进行动态扩容" class="headerlink" title="装载因子过大时需要进行动态扩容"></a>装载因子过大时需要进行动态扩容</h2><p>装载因子的计算公式：</p><p><strong>散列表的装载因子 = 填入表中的元素个数 / 散列表的长度​</strong></p><p>装载因子越大说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p><p>装载因子过大时，就需要进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p><p>针对散列表的扩容，数据搬移操作相对数组要复杂很多。散列表的大小变了，数据的存储位置也变了需要通过散列函数重新计算每个数据的存储位置。</p><p>下图中，21 这个元素原来存储在下标为 0 的位置，搬移到新的散列表中，存储在下标为 7 的位置。</p><p><img src="imgs/2/1570443204350.png" alt="1570443204350"></p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，启动扩容需要重新申请内存空间，重新计算哈希位置，并且搬移数据，时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p><p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p><h2 id="均摊插入避免低效扩容"><a href="#均摊插入避免低效扩容" class="headerlink" title="均摊插入避免低效扩容"></a>均摊插入避免低效扩容</h2><p>当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样就没有了集中的一次性数据搬移，而是分摊到了每一次插入操作上。</p><p><img src="imgs/2/1570443225487.png" alt="1570443225487"></p><p>对于查询操作，先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p><h2 id="两种散列冲突的解决办法的应用场景"><a href="#两种散列冲突的解决办法的应用场景" class="headerlink" title="两种散列冲突的解决办法的应用场景"></a>两种散列冲突的解决办法的应用场景</h2><p>开放寻址法和链表法，这两种冲突解决办法在实际的软件开发中都非常常用。比如，Java 中 <strong>LinkedHashMap</strong> 就采用了链表法解决冲突，<strong>ThreadLocalMap</strong> 是通过线性探测的开放寻址法来解决冲突。</p><h3 id="1-开放寻址法-1"><a href="#1-开放寻址法-1" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p><strong>优点：</strong>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度，序列化起来比较简单。</p><p><strong>缺点：</strong></p><ul><li>删除数据的时候需要特殊标记已经删除掉的数据。</li><li>所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li><li>使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。</li><li>相比链表法更浪费内存空间。</li></ul><p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong></p><h3 id="2-链表法-1"><a href="#2-链表法-1" class="headerlink" title="2. 链表法"></a>2. 链表法</h3><p><strong>优点：</strong></p><ul><li>对内存的利用率比开放寻址法要高，链表结点可以在需要的时候再创建。</li></ul><ul><li>对大装载因子的容忍度更高：开放寻址法只能适用装载因子小于 1 的情况。对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也只是是链表的长度变长了而已。</li></ul><p><strong>缺点：</strong></p><ul><li>链表要存储指针对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。</li><li>链表中的结点是零散分布在内存中的，不是连续的，对 CPU 缓存不友好对于执行效率有一定的影响。</li></ul><p>如果存储的是大对象，即存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前可以忽略了。</p><p>链表法中的链表可以改造为跳表、红黑树等其他的动态数据结构，这样即便所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 $O(logn)$。</p><p><img src="imgs/2/1570443243282.png" alt="1570443243282"></p><p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表</strong></p><h2 id="Java-中的HashMap"><a href="#Java-中的HashMap" class="headerlink" title="Java 中的HashMap"></a>Java 中的HashMap</h2><h3 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h3><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p><h3 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2. 装载因子和动态扩容"></a>2. 装载因子和动态扩容</h3><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h3 id="3-散列冲突解决方法"><a href="#3-散列冲突解决方法" class="headerlink" title="3. 散列冲突解决方法"></a>3. 散列冲突解决方法</h3><p>HashMap 底层采用链表法来解决冲突。</p><p>在 JDK1.8 版本中， HashMap 的链表长度默认超过 8时，链表就转换为红黑树。当红黑树结点个数少于 8 个的时，红黑树又会转化为链表。</p><h3 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4. 散列函数"></a>4. 散列函数</h3><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>；    <span class="token keyword">return</span> <span class="token punctuation">(</span>h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>capitity <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//capicity 表示散列表的大小</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() ：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hash<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>      var1 <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> var1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> var1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="散列表-链表"><a href="#散列表-链表" class="headerlink" title="散列表+链表"></a>散列表+链表</h1><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，按顺序遍历散列表中的数据的时候，都需要先排序，效率很低。为了解决这个问题，可以将散列表和链表（或者跳表）结合在一起使用。</p><p>用链表来实现 LRU 缓存淘汰算法，时间复杂度是 O(n)，通过散列表可以将这个时间复杂度降低到 O(1)。</p><p><strong>Redis</strong> 有序集合不仅使用了跳表，还用到了散列表。</p><p><strong>LinkedHashMap</strong>也用到了散列表和链表两种数据结构。</p><h2 id="散列表-双向链表实现LRU-缓存"><a href="#散列表-双向链表实现LRU-缓存" class="headerlink" title="散列表+双向链表实现LRU 缓存"></a>散列表+双向链表实现LRU 缓存</h2><p>用链表实现的 LRU 缓存淘汰算法查找的时间复杂度是 O(n)，而将散列表和链表组合使用，可以将查找的时间复杂度降低到 O(1)。</p><p>一个缓存（cache）系统主要包含下面这几个操作：</p><ul><li>添加一个数据；</li><li>删除一个数据；</li><li>查找一个数据。</li></ul><p>这三个操作都要涉及“查找”操作，单纯采用链表时间复杂度是 O(n)，散列表+链表时间复杂度是 O(1)。</p><p><img src="imgs/2/1570443319623.png" alt="1570443319623"></p><p>双向链表的每个结点包含存储数据的data和prev、next、hnext三个指针。</p><p>hnext是散列表的<strong>拉链</strong>指针，前驱prev和后继next是双向链表的串联指针。</p><p><strong>查找一个数据：</strong>通过散列表的拉链指针可以很快地在缓存中找到一个数据。找到数据之后将它移动到双向链表的尾部。</p><p><strong>删除一个数据：</strong>找到数据所在的结点，然后将结点删除。借助散列表可以在 O(1) 时间复杂度里找到要删除的结点。</p><p><strong>添加一个数据：</strong>查看这个数据是否已经在缓存中。如果已经在其中将其移动到双向链表的尾部；如果不在其中，再看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">class</span> <span class="token class-name">DNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">,</span> value<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value        self<span class="token punctuation">.</span>prev<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>DNode<span class="token punctuation">]</span> <span class="token operator">=</span> None        self<span class="token punctuation">.</span>next<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>DNode<span class="token punctuation">]</span> <span class="token operator">=</span> None<span class="token keyword">class</span> <span class="token class-name">LRUCacheHashTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 链表长度</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity  <span class="token comment" spellcheck="true"># 链表容量</span>        self<span class="token punctuation">.</span>table <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 散列表存储key</span>        self<span class="token punctuation">.</span>head_node <span class="token operator">=</span> DNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>tail_node <span class="token operator">=</span> DNode<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>tail_node        self<span class="token punctuation">.</span>tail_node<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head_node    <span class="token keyword">def</span> <span class="token function">put</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        node<span class="token punctuation">:</span> DNode <span class="token operator">=</span> self<span class="token punctuation">.</span>table<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span>            new_node <span class="token operator">=</span> DNode<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> new_node            self<span class="token punctuation">.</span>add_node<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>length <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>length <span class="token operator">></span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>                tail <span class="token operator">=</span> self<span class="token punctuation">.</span>pop_tail<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">del</span> self<span class="token punctuation">.</span>table<span class="token punctuation">[</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">]</span>                self<span class="token punctuation">.</span>length <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value            self<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">add_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_node<span class="token punctuation">:</span> DNode<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将新节点加到头部"""</span>        new_node<span class="token punctuation">.</span>next <span class="token operator">=</span> self<span class="token punctuation">.</span>head_node<span class="token punctuation">.</span>next        new_node<span class="token punctuation">.</span>prev <span class="token operator">=</span> self<span class="token punctuation">.</span>head_node        self<span class="token punctuation">.</span>head_node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> new_node        self<span class="token punctuation">.</span>head_node<span class="token punctuation">.</span>next <span class="token operator">=</span> new_node    <span class="token keyword">def</span> <span class="token function">pop_tail</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""弹出尾部数据节点"""</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>tail_node<span class="token punctuation">.</span>prev        self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> node    @staticmethod    <span class="token keyword">def</span> <span class="token function">remove_node</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""移除节点"""</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev    <span class="token keyword">def</span> <span class="token function">move_to_head</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将节点移动到头部"""</span>        self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""获取节点数据"""</span>        node<span class="token punctuation">:</span> DNode <span class="token operator">=</span> self<span class="token punctuation">.</span>table<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span> None        self<span class="token punctuation">.</span>move_to_head<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""移除节点数据"""</span>        node <span class="token operator">=</span> self<span class="token punctuation">.</span>table<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        <span class="token keyword">if</span> node <span class="token keyword">is</span> None<span class="token punctuation">:</span> <span class="token keyword">return</span>        self<span class="token punctuation">.</span>remove_node<span class="token punctuation">(</span>node<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>length <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>head_node<span class="token punctuation">.</span>next        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> p<span class="token punctuation">.</span>next<span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"%s:%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>key<span class="token punctuation">,</span> p<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next        <span class="token keyword">return</span> <span class="token string">"{%s}"</span> <span class="token operator">%</span> <span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h2><p>在Redis有序集合中，每个成员对象有两个重要的属性，<strong>key</strong>（键值）和<strong>score</strong>（分值）。可以同时通过key 和 score 来查找数据。</p><p>比如用户积分排行榜有这样一个功能：可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。</p><p> Redis 有序集合的操作：</p><ul><li>添加一个成员对象；</li><li>按照键值来删除一个成员对象；</li><li>按照键值来查找一个成员对象；</li><li>按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；</li><li>按照分值从小到大排序成员变量；</li></ul><p>如果仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢。</p><p>可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。</p><h2 id="Java的LinkedHashMap"><a href="#Java的LinkedHashMap" class="headerlink" title="Java的LinkedHashMap"></a>Java的LinkedHashMap</h2><p>LinkedHashMap 是通过散列表和链表组合在一起实现的。它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。</p><p>LinkedHashMap 中的“Linked”相当于在HashMap的基础上加了一层双向链表。</p><p>比如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序</span>HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码打印的结果是 1，2，3，5。</p><p>每次调用 put() 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，在前四个操作完成之后：</p><p><img src="imgs/2/1570443360066.png" alt="1570443360066"></p><p>再次将键值为 3 的数据放入到 LinkedHashMap 的时候，会先查找这个键值是否已经有了，然后，再将已经存在的 (3,11) 删除，并且将新的 (3,26) 放到链表的尾部：</p><p><img src="imgs/2/1570443376432.png" alt="1570443376432"></p><p>当访问到 key 为 5 的数据的时候，将被访问到的数据移动到链表的尾部：</p><p><img src="imgs/2/1570443391552.png" alt="1570443391552"></p><p>按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统。</p><h2 id="2道思考题"><a href="#2道思考题" class="headerlink" title="2道思考题"></a>2道思考题</h2><p>1.散列表+链表，把双向链表改成单链表，还能否正常工作呢？为什么呢？</p><p>答：可以正常工作，散列表+链表主要是查找、删除和添加三种操作，改成单链表后，只是相对需要增加一个变量记录前驱节点，照样可以在找到目标节点后很快的实现查找、删除和添加三种操作。</p><p>2.假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</p><ol><li>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息；</li><li>查找积分在某个区间的猎头 ID 列表；</li><li>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。</li></ol><p>答：</p><p>构建一个散列表，并在链表节点上增加用于构建跳表的指针，散列表根据猎头的 ID 计算hash值，跳表根据积分从小到大排序。</p><ol><li>ID 在散列表中存储，可以根据ID在O(1)的时间复杂度内快速查找、删除、更新这个猎头的积分信息。</li><li>积分在跳表存储，可以做到 O(logn) 的时间复杂度定位积分区间的起点，然后在原始链表中顺序往后遍历到积分的终点就可以了。</li><li>从头开始遍历原始跳表，用变量记录当前排名，若当前排名符合大于等于第 x 位则开始输出，当然排名大于第 y 位时则循环结束。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10.跳表</title>
      <link href="//post/10.%E8%B7%B3%E8%A1%A8.html"/>
      <url>//post/10.%E8%B7%B3%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h2 id="跳表-链表-多级索引"><a href="#跳表-链表-多级索引" class="headerlink" title="跳表=链表+多级索引"></a>跳表=链表+多级索引</h2><p>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。</p><p>跳表的空间复杂度是 O(n)。跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。跳表的代码比起红黑树来说，要简单、易读。</p><p><strong>链表加多级索引的结构，就是跳表</strong>。</p><p>对于一个单链表，即便链表中存储的数据是有序的，如果要查找某个数据，也只能从头到尾遍历，时间复杂度是 O(n)。</p><p><img src="imgs/2/1570442602270.png" alt="1570442602270"></p><p>对链表建立一级“索引”，每两个结点提取一个结点到上一级，把抽出来的那一级叫作<strong>索引</strong>或<strong>索引层</strong>。图中的 down 表示 down 指针，指向下一级结点。</p><p><img src="imgs/2/1570442615779.png" alt="1570442615779"></p><p>这样就可以先在索引层遍历，然后通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。</p><p>比如要查找16，当在索引层遍历到13时，发现索引层下一个节点是17大于目标16，则可从13的down指针下降到原始链表继续遍历。这样只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。原来查找 16，需要遍历 10 个结点，加入一层索引后只需要遍历 7 个结点。</p><p><strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，查找效率提高了</strong>。继续再加一级索引，在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在再查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p><p><img src="imgs/2/1570442649156.png" alt="1570442649156"></p><p>下图是一个包含 64 个结点的链表，建立五级索引。</p><p><img src="imgs/2/1570442675055.png" alt="1570442675055"></p><p>在五级索引的作用下，查找 62 只需要遍历 11 个结点。当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建多级索引之后，查找效率的提升就会非常明显。</p><h2 id="跳表的时间复杂度分析"><a href="#跳表的时间复杂度分析" class="headerlink" title="跳表的时间复杂度分析"></a>跳表的时间复杂度分析</h2><p>一个链表里有 n 个结点，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 $n/(2^k)$。</strong></p><p>假设索引有 h 级，最高级的索引有 2 个结点，则 $n/(2^h)=2$，即 $h=log_2n-1$。加上原始链表这一层，整个跳表的高度就是 $log_2n$。在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 $O(m*logn)$。</p><p>按照每两个结点提取一个结点到上一级建立索引这种结构，每一级索引都最多只需要遍历 3 个结点，那么m=3.</p><p>假设要查找的数据是 x，在第 k 级索引中遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p><p><img src="imgs/2/1570442695929.png" alt="1570442695929"></p><p>所以在跳表中查询任意数据的时间复杂度就是 O(logn)。</p><h2 id="跳表的空间复杂度分析"><a href="#跳表的空间复杂度分析" class="headerlink" title="跳表的空间复杂度分析"></a>跳表的空间复杂度分析</h2><p>假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。每层索引的节点数为：<br>$$<br>\frac{n}2,\frac{n}4,\frac{n}8,…,8,4,2<br>$$<br>这几级索引的结点总和就是 $\frac{n}2+\frac{n}4+\frac{n}8+…+8+4+2=n-2$。所以跳表的空间复杂度是 O(n)。</p><p>将包含 n 个结点的单链表构造成跳表，需要额外再用接近 n 个结点的存储空间。</p><p>如果每三个结点或五个结点，抽一个结点到上级索引:</p><p><img src="imgs/2/1570442729225.png" alt="1570442729225"></p><p>那第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，假设最高一级的索引结点个数是 1。每3个节点抽一个，每层索引的节点数为：</p><p>$$<br>\frac{n}3,\frac{n}9,\frac{n}{27},…,9,3,1<br>$$<br>总的索引结点个数为$\frac{n}{3}+\frac{n}{9}+\frac{n}{27}+…+9+3+1=n/2$。空间复杂度依然是 O(n)，但比每两个结点抽一个结点的索引构建方法，减少了一半的索引结点存储空间。</p><p>在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h2 id="跳表动态的插入和删除"><a href="#跳表动态的插入和删除" class="headerlink" title="跳表动态的插入和删除"></a>跳表动态的插入和删除</h2><p>跳表插入、删除操作的时间复杂度是 O(logn)。</p><p><img src="imgs/2/1570442776661.png" alt="1570442776661"></p><p>对于删除操作，如果这个结点在索引中也有出现，删除原始链表中的结点之后还要删除对应的索引。</p><p>查找要删除的结点的时候，一定要获取前驱结点（双向链表不需要考虑这个问题）。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><p><img src="imgs/2/1570442793990.png" alt="1570442793990"></p><p>作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡：</p><p>如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>往跳表中插入数据的时候，可以同时将这个数据插入到部分索引层中。通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，就将这个结点添加到第一级到第 K 级这 K 级索引中。</p><p><img src="imgs/2/1570442809447.png" alt="1570442809447"></p><h2 id="Redis-用跳表实现有序集合"><a href="#Redis-用跳表实现有序集合" class="headerlink" title="Redis 用跳表实现有序集合"></a>Redis 用跳表实现有序集合</h2><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。</p><p>Redis 中的有序集合支持的核心操作主要有：</p><ul><li>插入一个数据；</li><li>删除一个数据；</li><li>查找一个数据；</li><li>按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；</li><li>迭代输出有序序列。</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p><p>对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>跳表相对红黑树而言代码更容易实现，简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><h2 id="跳表的简易代码实现"><a href="#跳表的简易代码实现" class="headerlink" title="跳表的简易代码实现"></a>跳表的简易代码实现</h2><p>跳表的java实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SkipList</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> SKIPLIST_P <span class="token operator">=</span> <span class="token number">0.5f</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_LEVEL <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> levelCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> Node cls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 带头链表</span>  <span class="token keyword">public</span> Node <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node p <span class="token operator">=</span> cls<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newNode<span class="token punctuation">.</span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>    newNode<span class="token punctuation">.</span>maxLevel <span class="token operator">=</span> level<span class="token punctuation">;</span>    Node update<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cls<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// record every level largest value which smaller than insert value in update[]</span>    Node p <span class="token operator">=</span> cls<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// use update save node in search path</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// in search path node next node become new node forwords(next)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      newNode<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// update node hight</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>levelCount <span class="token operator">&lt;</span> level<span class="token punctuation">)</span> levelCount <span class="token operator">=</span> level<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token punctuation">[</span><span class="token punctuation">]</span> update <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>levelCount<span class="token punctuation">]</span><span class="token punctuation">;</span>    Node p <span class="token operator">=</span> cls<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> levelCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>levelCount<span class="token operator">></span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>cls<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>levelCount<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>      levelCount<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。</span>  <span class="token comment" spellcheck="true">// 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。</span>  <span class="token comment" spellcheck="true">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span>  <span class="token comment" spellcheck="true">//        50%的概率返回 1</span>  <span class="token comment" spellcheck="true">//        25%的概率返回 2</span>  <span class="token comment" spellcheck="true">//      12.5%的概率返回 3 ...</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">randomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> SKIPLIST_P <span class="token operator">&amp;&amp;</span> level <span class="token operator">&lt;</span> MAX_LEVEL<span class="token punctuation">)</span>      level <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> level<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node p <span class="token operator">=</span> cls<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Node forwards<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>MAX_LEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxLevel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"{ data: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"; levels: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>maxLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>      builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>__author__ <span class="token operator">=</span> <span class="token string">'xiaoxiaoming'</span><span class="token keyword">import</span> random<span class="token keyword">class</span> <span class="token class-name">SkipListNode</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">,</span> max_level<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> val  <span class="token comment" spellcheck="true"># 节点存储的值</span>        self<span class="token punctuation">.</span>forwards <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> max_level  <span class="token comment" spellcheck="true"># 节点对应索引层的深度</span><span class="token keyword">class</span> <span class="token class-name">SkipList</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""        跳表的一种实现方法。        跳表中储存的是不重复的正整数。    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__MAX_LEVEL <span class="token operator">=</span> <span class="token number">16</span>  <span class="token comment" spellcheck="true"># 索引层的最大深度</span>        self<span class="token punctuation">.</span>SKIPLIST_P <span class="token operator">=</span> <span class="token number">0.5</span>  <span class="token comment" spellcheck="true"># 索引生成层数的随机因子</span>        self<span class="token punctuation">.</span>_level_count <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 跳表的深度</span>        self<span class="token punctuation">.</span>_head <span class="token operator">=</span> SkipListNode<span class="token punctuation">(</span>None<span class="token punctuation">,</span> self<span class="token punctuation">.</span>__MAX_LEVEL<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 带头链表</span>    <span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>_head        <span class="token comment" spellcheck="true"># 从索引的顶层, 逐层定位要查找的值</span>        <span class="token comment" spellcheck="true"># 索引层上下是对应的, 下层的起点是上一个索引层中小于插入值的最大值对应的节点</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_level_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 同一索引层内, 查找小于插入值的最大值对应的节点</span>            <span class="token keyword">while</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> val<span class="token punctuation">:</span>            <span class="token keyword">return</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> None    <span class="token keyword">def</span> <span class="token function">insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        新增时, 通过随机函数获取要更新的索引层数,        要对低于给定高度的索引层添加新结点的指针        '''</span>        level <span class="token operator">=</span> self<span class="token punctuation">.</span>random_level<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 更新跳表索引层数</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_level_count <span class="token operator">&lt;</span> level<span class="token punctuation">:</span> self<span class="token punctuation">.</span>_level_count <span class="token operator">=</span> level        new_node <span class="token operator">=</span> SkipListNode<span class="token punctuation">(</span>val<span class="token punctuation">,</span> level<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 申请新结点</span>        <span class="token comment" spellcheck="true"># cache用来缓存对应索引层中小于插入值的最大节点</span>        cache <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> level        <span class="token comment" spellcheck="true"># 在低于随机高度的每一个索引层寻找小于插入值的节点</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>_head        <span class="token comment" spellcheck="true"># 缓存每一个索引层定位小于插入值的节点</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p        <span class="token comment" spellcheck="true"># 在小于高度的每个索引层中插入新结点</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">:</span>            new_node<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> new_node    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        删除时, 要将每个索引层中对应的节点都删掉        '''</span>        <span class="token comment" spellcheck="true"># cache用来缓存对应索引层中小于插入值的最大节点</span>        cache <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>_level_count        p <span class="token operator">=</span> self<span class="token punctuation">.</span>_head        <span class="token comment" spellcheck="true"># 缓存每一个索引层定位小于插入值的节点</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_level_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">while</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;</span> val<span class="token punctuation">:</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p        <span class="token comment" spellcheck="true"># 如果给定的值存在, 更新索引层中对应的节点</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> val<span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_level_count<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">and</span> cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">==</span> val<span class="token punctuation">:</span>                    cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 更新跳表的深度</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>_level_count <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">and</span> self<span class="token punctuation">.</span>_head<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>self<span class="token punctuation">.</span>_level_count<span class="token punctuation">]</span> <span class="token operator">==</span> None<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_level_count <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">random_level</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        一级索引中元素个数应该占原始数据的 SKIPLIST_P,二级索引中元素个数占SKIPLIST_P^2,三级索引SKIPLIST_P^3,一直到最顶层。        每一层的晋升概率是 SKIPLIST_P。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。        该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数        :return: 按概率返回 1-MAX_LEVEL中的一个值        """</span>        level <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>SKIPLIST_P <span class="token operator">and</span> level <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>__MAX_LEVEL<span class="token punctuation">:</span>            level <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> level    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        vals <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p <span class="token operator">=</span> self<span class="token punctuation">.</span>_head        <span class="token keyword">while</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            vals<span class="token punctuation">.</span>append<span class="token punctuation">(</span>str<span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> <span class="token string">'->'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>vals<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">print_all</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_level_count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            p <span class="token operator">=</span> self<span class="token punctuation">.</span>_head            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"level:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>            <span class="token keyword">while</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">"->"</span><span class="token punctuation">)</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>forwards<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    sl <span class="token operator">=</span> SkipList<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sl<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> i <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">:</span>            sl<span class="token punctuation">.</span>print_all<span class="token punctuation">(</span><span class="token punctuation">)</span>    sl<span class="token punctuation">.</span>print_all<span class="token punctuation">(</span><span class="token punctuation">)</span>    p <span class="token operator">=</span> sl<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    sl<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">37</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span>    sl<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token number">37.5</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>09.二分查找</title>
      <link href="//post/09.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"/>
      <url>//post/09.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h1 id="二分查找的思想"><a href="#二分查找的思想" class="headerlink" title="二分查找的思想"></a>二分查找的思想</h1><p>二分查找（Binary Search）算法，也叫折半查找算法。</p><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong>。</p><p>假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。</p><p>利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。下图中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标。</p><p><img src="imgs/2/1570440501975.png" alt="1570440501975"></p><p>二分查找的时间复杂度为O(logn) ，被查找区间的大小变化：</p><p>$$<br>n, \frac{n}{2}, \frac{n}{4}, \frac{n}{8}, \cdots, \frac{n}{2^{k}} \cdots<br>$$</p><h1 id="二分查找的实现"><a href="#二分查找的实现" class="headerlink" title="二分查找的实现"></a>二分查找的实现</h1><p><strong>最简单的情况</strong>就是<strong>有序数组中不存在重复元素</strong>， Java 代码循环实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> mid<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">:</span>            <span class="token keyword">return</span> mid        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token comment" spellcheck="true"># 未找到返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示 [low, high] 的中间位置。我们通过对比 a[mid] 与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。</p><p>需要注意的点：</p><p>1.循环退出条件是 low&lt;=high，而不是 low&lt;high。</p><p>2.mid=(low+high)/2 这种写法，在 low 和 high 比较大时，两者之和可能会溢出。</p><p>改进的方法是将 mid 的计算方式写成 low+(high-low)/2，转化成位运算 low+((high-low)&gt;&gt;1)更佳。</p><p>3.写成 low=mid 或者 high=mid，可能会发生死循环。应当写成low=mid+1，high=mid-1。</p><p>二分查找的java递归实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 二分查找的递归实现</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">bsearchInternally</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">bsearchInternally</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> mid <span class="token operator">=</span>  low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mid<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">bsearchInternally</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">bsearchInternally</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><p><strong>1.二分查找依赖的是顺序表结构，即数组。</strong></p><p>二分查找算法需要按照下标随机访问元素，所以不能用链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p><p><strong>2.二分查找要求数据必须是有序的，或者无序但没有频繁的插入和删除操作。</strong></p><p>数据没有序，进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>但如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。</p><p><strong>3.数据量太小二分查找性能提升不大</strong></p><p>但如果数据之间的比较操作非常耗时，比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><p><strong>4.数据量太大不适合二分查找</strong></p><p>只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p>不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如有 1GB 大小的数据，用数组来存储，就需要 1GB 的连续内存空间。</p><p>“连续”意味着即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那就无法申请一个 1GB 大小的数组。</p><h1 id="二分查找的三种变体"><a href="#二分查找的三种变体" class="headerlink" title="二分查找的三种变体"></a>二分查找的三种变体</h1><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>如果有序数据集合中存在重复的数据，要找到第一个值等于给定值的数据。</p><p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="imgs/2/1570441654764.png" alt="1570441654764"></p><p>简洁实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">==</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span> low<span class="token punctuation">;</span>  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容易理解的java实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span>  low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求解的是第一个值等于给定值的元素，当 a[mid] 等于要查找的值时，就需要确认一下这个 a[mid] 是不是第一个值等于给定值的元素。</p><p>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；</p><p>如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是要查找的第一个值等于给定值的元素。那就更新 high=mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。</p><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 2分查找第一个值等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_first</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> mid <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> arr<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python简洁实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bsearch_first_simple</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> value<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> low    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><p>java实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span>  low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 a[mid] 这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；</p><p>如果 a[mid] 的后一个元素 a[mid+1] 不等于 value，那也说明 a[mid] 就是我们要找的最后一个值等于给定值的元素。</p><p>如果 a[mid] 后面的一个元素 a[mid+1] 也等于 value，那说明当前的这个 a[mid] 并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在 [mid+1, high] 之间。</p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 查找最后一个值等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_last</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> mid <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># 查找最后一个值等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_last_simple</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> value<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">if</span> high <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> high    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span>  low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 a[mid] 小于要查找的值 value，那要查找的值肯定在 [mid+1, high] 之间，更新 low=mid+1。</p><p>对于 a[mid] 大于等于给定值 value 的情况，如果 a[mid] 前面已经没有元素，或者前面一个元素 a[mid-1] 小于要查找的值 value，那 a[mid] 就是目标元素。</p><p>如果 a[mid-1] 也大于等于要查找的值 value，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。</p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 查找第一个大于等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_first_not_less</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> mid <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">or</span> arr<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># 查找第一个大于等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_first_not_less_simple</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> value<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">if</span> low <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">>=</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> low    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bsearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span>  low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mid <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>      <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 查找最后一个小于等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_last_not_greater</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> value<span class="token punctuation">:</span>            <span class="token keyword">if</span> mid <span class="token operator">==</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">or</span> arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> value<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">else</span><span class="token punctuation">:</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># 查找最后一个小于等于给定值的元素</span><span class="token keyword">def</span> <span class="token function">bsearch_last_not_greater_simple</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> value<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">if</span> high <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">or</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> value<span class="token punctuation">:</span>        <span class="token keyword">return</span> high    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二分查找相关问题"><a href="#二分查找相关问题" class="headerlink" title="二分查找相关问题"></a>二分查找相关问题</h1><h2 id="如何快速判断某个整数是否出现在这-1000-万数据中？"><a href="#如何快速判断某个整数是否出现在这-1000-万数据中？" class="headerlink" title="如何快速判断某个整数是否出现在这 1000 万数据中？"></a>如何快速判断某个整数是否出现在这 1000 万数据中？</h2><p>假设有 1000 万个整数数据，每个数据占 8 个字节，内存限制是 100MB，<strong>如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？</strong> </p><p>每个数据大小是 8 字节，将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。对这 1000 万数据利用原地排序算法排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p><h2 id="用二分查找求一个数的平方根"><a href="#用二分查找求一个数的平方根" class="headerlink" title="用二分查找求一个数的平方根"></a>用二分查找求一个数的平方根</h2><p>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</p><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bsearch_sqrt</span><span class="token punctuation">(</span>num<span class="token punctuation">:</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>    <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> ValueError    <span class="token keyword">if</span> num <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">==</span> num<span class="token punctuation">:</span>        <span class="token keyword">return</span> num    <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>        low<span class="token punctuation">,</span> high <span class="token operator">=</span> num<span class="token punctuation">,</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> num    <span class="token keyword">while</span> high <span class="token operator">-</span> low <span class="token operator">></span> <span class="token number">0.0000001</span><span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        mid_v2 <span class="token operator">=</span> mid <span class="token operator">**</span> <span class="token number">2</span>        <span class="token keyword">if</span> mid_v2 <span class="token operator">></span> num<span class="token punctuation">:</span>            high <span class="token operator">=</span> mid        <span class="token keyword">elif</span> mid_v2 <span class="token operator">&lt;</span> num<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid        <span class="token keyword">elif</span> mid_v2 <span class="token operator">==</span> num<span class="token punctuation">:</span>            <span class="token keyword">return</span> mid    <span class="token keyword">return</span> round<span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分查找快速定位IP对应的省份地址"><a href="#二分查找快速定位IP对应的省份地址" class="headerlink" title="二分查找快速定位IP对应的省份地址"></a>二分查找快速定位IP对应的省份地址</h2><p> IP 地址查找 IP 归属地是通过维护一个很大的 IP 地址库来实现的。地址库中包括 IP 地址范围和归属地的对应关系。</p><p>当查询 202.102.133.13 这个 IP 地址的归属地时，就在地址库中搜索，发现这个 IP 地址落在 [202.102.133.0, 202.102.133.255] 这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。</p><pre><code>202.102.133.0|202.102.133.63|山东东营联通202.102.133.64|202.102.133.255|山东济南联通202.102.134.0|202.102.134.255|山东青岛联通202.102.135.0|202.102.135.231|山东烟台联通202.102.48.0|202.102.48.255|江苏宿迁电信202.102.49.0|202.102.49.255|江苏泰州电信202.102.50.0|202.102.50.255|江苏苏州电信202.102.51.0|202.102.101.255|江苏南京电信</code></pre><p><strong>假设有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</strong></p><p>思路：</p><p>可以先预处理这 12 万条数据，存储到数组中，让其按照起始 IP（按照地址对应的整型值） 从小到大排序。</p><p>查询某个 IP 归属地时，先通过二分查找找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后检查这个 IP 是否在这个 IP 区间内，如果在就取出对应的归属地显示；如果不在就返回未查找到。</p><p>代码实现：</p><pre class="line-numbers language-python"><code class="language-python">ip_rule_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"ip.txt"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        start_ip<span class="token punctuation">,</span> end_ip<span class="token punctuation">,</span> location <span class="token operator">=</span> line<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"|"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>        ip_rule_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>start_ip<span class="token punctuation">,</span> end_ip<span class="token punctuation">,</span> location<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">ip2int</span><span class="token punctuation">(</span>ip_str<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> ip_str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token keyword">return</span> resultip_rule_list<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> ip2int<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">ip_to_location</span><span class="token punctuation">(</span>ip<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>ip_rule_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    ip_int <span class="token operator">=</span> ip2int<span class="token punctuation">(</span>ip<span class="token punctuation">)</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 查找最后一个起始IP小于等于这个IP的IP区间</span>        <span class="token keyword">if</span> ip2int<span class="token punctuation">(</span>ip_rule_list<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> ip_int<span class="token punctuation">:</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">if</span> high <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> ip2int<span class="token punctuation">(</span>ip_rule_list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> ip_int <span class="token operator">&lt;=</span> ip2int<span class="token punctuation">(</span>ip_rule_list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ip_rule_list<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环有序数组的二分查找问题"><a href="#循环有序数组的二分查找问题" class="headerlink" title="循环有序数组的二分查找问题"></a>循环有序数组的二分查找问题</h2><p>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><p>思路：</p><p>对于数组[1 2 3 4 5 6] 共有下列6种旋转方法：</p><p>1　　2　　<strong><font color=red>3　　4　　5　　6</font></strong></p><p>6　　1　　<strong><font color=red>2　　3　　4　　5</font></strong></p><p>5　　6　　<strong><font color=red>1　　2　　3　　4</font></strong></p><p><strong><font color=red>4　　5　　6</font></strong>　　1　　2　　3</p><p><strong><font color=red>3　　4　　5</font></strong>　　6　　1　　2</p><p><strong><font color=red>2　　3　　4</font></strong>　　5　　6　　1</p><p>以数组中间点为分区，会将数组分成升序和非升序两部分，观察发现上面红色加粗的数字都是升序部分。</p><p>由此可得：</p><ul><li>若中间数小于最右边数，则右半段是升序区间</li><li>若中间数大于最右边数，则左半段是升序区间</li></ul><p>然后根据目标值是否存在于升序区间，确定保留哪一区间，进行2分查找即可</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">binary_search_circle_array</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    low<span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> low <span class="token operator">&lt;=</span> high<span class="token punctuation">:</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">:</span> <span class="token keyword">return</span> mid        <span class="token comment" spellcheck="true"># 上面没有返回，说明中间值不是目标值</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 若中间数小于最右边数，则右半段是升序区间</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value <span class="token operator">and</span> value <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 在右半段有序区间</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 若中间数大于最右边数，则左半段是升序区间</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> value <span class="token operator">and</span> value <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 在左半段有序区间</span>                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 若中间数等于最右边数，则目标不在右半段</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>07.排序</title>
      <link href="//post/07.%E6%8E%92%E5%BA%8F.html"/>
      <url>//post/07.%E6%8E%92%E5%BA%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>最常用的排序算法：</p><p><strong>冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</strong></p><p>按照时间复杂度可分为三类：</p><table><thead><tr><th align="center">排序算法</th><th align="center">时间复杂度</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td align="center">冒泡、插入、选择</td><td align="center">$O(n^2)$</td><td align="center">Y</td></tr><tr><td align="center">快排、归并</td><td align="center">$O(nlogn)$</td><td align="center">Y</td></tr><tr><td align="center">桶、计数、基数</td><td align="center">$O(n)$</td><td align="center">N</td></tr></tbody></table><h1 id="排序算法的三个分析指标"><a href="#排序算法的三个分析指标" class="headerlink" title="排序算法的三个分析指标"></a>排序算法的三个分析指标</h1><h2 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h2><p>一般从这几个方面来衡量：</p><p><strong>1. 最好情况、最坏情况、平均情况时间复杂度</strong></p><p>要分别给出最好情况、最坏情况、平均情况下的时间复杂度，并说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p>区分这三种时间复杂度的目的：</p><ol><li>为了方便对比，所以都做一下区分。</li><li>要排序的数据，有的接近有序，有的完全无序。我们需要知道排序算法在不同数据下的性能表现。</li></ol><p><strong>2. 时间复杂度的系数、常数 、低阶</strong></p><p>时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，它会忽略系数、常数、低阶。</p><p>但排序的是 1000 以内规模很小的数据，对同阶时间复杂度的排序算法性能对比的时候，应当把系数、常数、低阶也考虑进来。</p><p><strong>3. 比较次数和交换（或移动）次数</strong></p><p>基于比较的排序算法的执行过程，会涉及元素比较大小和元素交换或移动两种操作。</p><p>在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h2 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量。</p><p><strong>原地排序（Sorted in place）</strong>算法，是特指空间复杂度是 O(1) 的排序算法。</p><h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p><strong>稳定性</strong>是指如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>比如有一组数据 2，9，3，4，8，3，按照大小排序之后是 2，3，3，4，8，9。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p><p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong></p><p>在实际软件开发中，往往要排序的是一组对象，需要按照对象的某个 key 来排序。</p><p>比如给电商交易系统中的“订单”排序。订单有两个属性，<strong>下单时间</strong>和<strong>订单金额</strong>。需要按照金额从小到大，如果金额相同则按照下单时间从早到晚，对订单数据排序。</p><p>这个问题借助稳定排序算法的解决思路是：先按照下单时间给订单排序，排序完成之后，再用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。</p><p>第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，用的是稳定的排序算法，相同金额的订单仍然保持下单时间从早到晚有序。</p><p><img src="imgs/2/1570434132748.png" alt="1570434132748"></p><p>在实际开发中，我对这个问题的解决方案是，把<strong>订单金额</strong>和<strong>下单时间</strong>两个key作为一个自定义的key进行排序。</p><h1 id="时间复杂度O-n-2-​的三种排序算法"><a href="#时间复杂度O-n-2-​的三种排序算法" class="headerlink" title="时间复杂度O(n^2)​的三种排序算法"></a>时间复杂度O(n^2)​的三种排序算法</h1><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>比如对一组数据 $4,5,6,3,2,1$从小到到大进行排序的，第一趟冒泡过程是：</p><p><img src="imgs/2/1570434178012.png" alt="1570434178012"></p><p>经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，只要进行 6 次这样的冒泡操作就行了：</p><p><img src="imgs/2/1570434192005.png" alt="1570434192005"></p><p>这个冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。比如下图给 6 个元素排序，只需要 4 次冒泡操作就可以了：</p><p><img src="imgs/2/1570434207006.png" alt="1570434207006"></p><p>冒泡排序算法的原理比较容易理解，具体的代码我贴到下面，你可以结合着代码来看我前面讲的原理。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 冒泡排序，a 表示数组，n 表示数组大小</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 提前退出冒泡循环的标志位</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 交换</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 表示有数据交换      </span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 没有数据交换，提前退出</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token keyword">def</span> <span class="token function">bubble_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""冒泡排序，arr是数组,n表示数组长度"""</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 提前退出标志位</span>        flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 交换</span>                flag <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment" spellcheck="true"># 此次冒泡有数据交换</span>        <span class="token keyword">if</span> <span class="token operator">not</span> flag<span class="token punctuation">:</span> <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析冒泡排序"><a href="#分析冒泡排序" class="headerlink" title="分析冒泡排序"></a>分析冒泡排序</h3><p><strong>第一，冒泡排序是原地排序算法吗？</strong></p><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p><p><strong>第二，冒泡排序是稳定的排序算法吗？</strong></p><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。有相邻的两个元素大小相等的时候未做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><p><strong>第三，冒泡排序的时间复杂度是多少？</strong></p><p>最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 $O(n)$。而最坏的情况是，要排序的数据刚好是倒序排列的，需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 $O(n^2)$。</p><p><img src="imgs/2/1570434239490.png" alt="1570434239490"></p><p>对于包含 n 个数据的数组，这 n 个数据有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。平均时间复杂度就是加权平均期望时间复杂度，如果用概率论方法定量分析冒泡平均时间复杂度，涉及的数学推理和计算就会很复杂。</p><h3 id="“有序度”和“逆序度”分析平均时间复杂度"><a href="#“有序度”和“逆序度”分析平均时间复杂度" class="headerlink" title="“有序度”和“逆序度”分析平均时间复杂度"></a>“<strong>有序度</strong>”和“<strong>逆序度</strong>”分析平均时间复杂度</h3><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。表达式：</p><pre><code>有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</code></pre><p>比如$2,4,3,1,5,6$这组数据的有序度为11，因为有序对为11个，分别是：<br>$$<br>(2,4)\quad(2,3)\quad(2,5)\quad(2,6) \<br>(4,5)\quad(4,6)\quad(3,5)\quad(3,6)\<br>(1,5)\quad(1,6)\quad(5,6)<br>$$<br>对于一个倒序排列的数组，比如 $6,5,4,3,2,1$有序度是 0；</p><p>对于一个完全有序的数组，比如$ 1,2,3,4,5,6$有序度就是$n<em>(n-1)/2$，也就是 15。这种完全有序的数组的有序度叫作<em>*满有序度</em></em>。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序）：</p><pre><code>逆序元素对：a[i] &gt; a[j], 如果 i &lt; j</code></pre><p><strong>逆序度 = 满有序度 - 有序度</strong>。</p><p><strong>排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</strong></p><p>比如数组  $4,5,6,3,2,1$有序元素对有 (4，5) (4，6) (5，6)，有序度是 3。n=6排序完成之后满有序度为 n*(n-1)/2=15。</p><p><img src="imgs/2/1570434286245.png" alt="1570434286245"></p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。</p><p>不管算法怎么改进，交换次数总是确定的，即逆序度，也就是$n<em>(n-1)/2$–<em>*初始有序度</em></em>。上图就是 15–3=12，要进行 12 次交换操作。</p><p>对于包含 n 个数据的数组进行冒泡排序，最坏情况下初始状态的有序度是 0，要进行 $n<em>(n-1)/2$ 次交换。最好情况下，初始状态的有序度是 $n</em>(n-1)/ 2$，不需要进行交换。可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>平均情况下，需要 $n*(n-1)/4$ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2 )$，所以平均情况下的时间复杂度就是 $O(n^2 )$。</p><p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>一个有序的数组，只要遍历数组找到数据应该插入的位置将其插入，就能继续保持数组有序。</p><p><img src="imgs/2/1570434301993.png" alt="1570434301993"></p><p>可以通过这种方法保持集合中的数据一直有序，插入排序算法就是采用这种思想来进行排序的：</p><p>将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如下图，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="imgs/2/1570434319108.png" alt="1570434319108"></p><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p><strong>移动次数=逆序度</strong></p><p>以下图为例：</p><p>满有序度是 $n*(n-1)/2=15$，初始序列的有序度是 5，所以逆序度是 10。而下图数据移动的个数总和也等于 10=3+3+4。</p><p><img src="imgs/2/1570434336773.png" alt="1570434336773"></p><p>java代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 插入排序，a 表示数组，n 表示数组大小</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> value <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查找插入的位置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 数据移动</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 插入数据</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertion_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 待插入元素，arr[0:i-1]作为有序序列</span>        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># j指向有序序列的末端</span>        <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">-=</span> <span class="token number">1</span>        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token comment" spellcheck="true"># 插入数据</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析插入排序"><a href="#分析插入排序" class="headerlink" title="分析插入排序"></a>分析插入排序</h3><p><strong>第一，插入排序是原地排序算法吗？</strong></p><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，这是一个原地排序算法。</p><p><strong>第二，插入排序是稳定的排序算法吗？</strong></p><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><p><strong>第三，插入排序的时间复杂度是多少？</strong></p><p>如果要排序的数据已经是有序的，并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，需要移动大量的数据，所以最坏情况时间复杂度为 $O(n^2)$。</p><p>在数组中插入一个数据的平均时间复杂度是 $O(n)$。对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 $O(n^2)$。</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法也分已排序区间和未排序区间，每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="imgs/2/1570434356028.png" alt="1570434356028"></p><p>java代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 选择排序，a表示数组，n表示数组大小</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 查找最小值</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 交换</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selection_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        min <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> min <span class="token operator">=</span> j        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析选择排序"><a href="#分析选择排序" class="headerlink" title="分析选择排序"></a>分析选择排序</h3><p><strong>第一，选择排序是原地排序算法吗？</strong></p><p>选择排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，这是一个原地排序算法。</p><p><strong>第二，选择排序是稳定的排序算法吗？</strong></p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。是一种不稳定的排序算法。</p><p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。</p><p><strong>第三，选择排序的时间复杂度是多少？</strong></p><p>选择排序总是需要进行(n-1)+(n-2)+…+2+1=n(n-1)/2次比较，所以最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 $O(n^2 )$。</p><h2 id="为什么插入排序比冒泡排序更受欢迎？"><a href="#为什么插入排序比冒泡排序更受欢迎？" class="headerlink" title="为什么插入排序比冒泡排序更受欢迎？"></a>为什么插入排序比冒泡排序更受欢迎？</h2><p><strong>插入排序和冒泡排序的时间复杂度相同都是 $O(n^2 )$，都是原地排序算法，为什么插入排序比冒泡排序更受欢迎？</strong></p><p>冒泡排序和插入排序，元素交换的次数是一个固定值，是原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序需要 1 个复杂的数据交换操作，而插入排序只需要 1 个赋值操作。在java语言上冒泡排序的1个数据交换操作需要3步才能实现：</p><pre class="line-numbers language-java"><code class="language-java">冒泡排序中数据的交换操作：<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 交换</span>   <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span>插入排序中数据的移动操作：<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 数据移动</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><p>所以，理论上来说，冒泡排序相对插入排序一般要多消耗3倍的时间。</p><h2 id="三种时间复杂度是-O-n-2-的排序算法小结"><a href="#三种时间复杂度是-O-n-2-的排序算法小结" class="headerlink" title="三种时间复杂度是 $O(n^2)$ 的排序算法小结"></a>三种时间复杂度是 $O(n^2)$ 的排序算法小结</h2><p><img src="imgs/2/1570434375850.png" alt="1570434375850"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（Shell Sort），也称递减增量排序算法，是基于插入排序的改进版本。<br>基本思想是：<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序<br>待整个序列中的记录”基本有序”时,再对全体记录进行依次直接插入排序。</p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shell_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    incr <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">while</span> incr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># i 表示待插入元素角标，arr[0:i:incr]将作为有序序列</span>        <span class="token comment" spellcheck="true"># 例如有序序列角标为{0，incr,2*incr,...,i-incr},待插入元素角标为i,{n*incr}</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>incr<span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> incr<span class="token punctuation">)</span><span class="token punctuation">:</span>            key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 待插入元素，arr[0:i:incr]作为有序序列</span>            j <span class="token operator">=</span> i <span class="token operator">-</span> incr  <span class="token comment" spellcheck="true"># j指向有序序列的末端</span>            <span class="token keyword">while</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> incr<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> incr            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> incr<span class="token punctuation">]</span> <span class="token operator">=</span> key        incr <span class="token operator">//=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="时间复杂度为-O-nlogn-的三种排序算法"><a href="#时间复杂度为-O-nlogn-的三种排序算法" class="headerlink" title="时间复杂度为 O(nlogn) 的三种排序算法"></a>时间复杂度为 O(nlogn) 的三种排序算法</h1><p><strong>归并排序</strong>和<strong>快速排序</strong>是时间复杂度为 O(nlogn) 的排序算法，这两种排序算法适合大规模的数据排序，比时间复杂度为 $O(n^2)$ 的排序算法要更常用。</p><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 $O(n^2  )$，但是平均情况下时间复杂度都是 $O(nlogn)$。不仅如此，快速排序算法时间复杂度退化到 $O(n^2  )$的概率非常小，可以通过合理地选择 pivot 来避免这种情况。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge Sort）的核心思想，如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="imgs/2/1570434553802.png" alt="1570434553802"></p><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p><p>归并排序的递推公式：</p><pre class="line-numbers language-c"><code class="language-c">递推公式：<span class="token function">merge_sort</span><span class="token punctuation">(</span>p…r<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">merge_sort</span><span class="token punctuation">(</span>p…q<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span>…r<span class="token punctuation">)</span><span class="token punctuation">)</span>终止条件：p <span class="token operator">>=</span> r 不用再继续分解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。merge(…)表示分解为merge_sort(p…q) 和 merge_sort(q+1…r)两个子问题再合并，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。</p><p>当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p><p>伪代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 归并排序算法, A 是数组，n 表示数组大小</span><span class="token function">merge_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 递归调用函数</span><span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 递归终止条件</span>  <span class="token keyword">if</span> p <span class="token operator">>=</span> r  then <span class="token keyword">return</span>  <span class="token comment" spellcheck="true">// 取 p 到 r 之间的中间位置 q</span>  q <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token operator">+</span>r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true">// 分治递归</span>  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>  <span class="token function">merge_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span>  <span class="token function">merge</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> p <span class="token operator">>=</span> r<span class="token punctuation">:</span>        <span class="token keyword">return</span>    q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>    merge_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>    merge<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge(A[p…r], A[p…q], A[q+1…r]) 的作用是将已经有序的 A[p…q] 和 A[q+1…r] 合并成一个有序的数组，并且放入 A[p…r]。</p><h3 id="merge函数实现方法"><a href="#merge函数实现方法" class="headerlink" title="merge函数实现方法"></a>merge函数实现方法</h3><p>申请一个临时数组 tmp，大小与 A[p…r] 相同。用变量 i 和 j分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中。</p><p><img src="imgs/2/1570434823959.png" alt="1570434823959"></p><p> merge() 函数的伪代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">merge</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>p<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  var i <span class="token punctuation">:</span><span class="token operator">=</span> p，j <span class="token punctuation">:</span><span class="token operator">=</span> q<span class="token operator">+</span><span class="token number">1</span>，k <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true">// 初始化变量 i, j, k</span>  var tmp <span class="token punctuation">:</span><span class="token operator">=</span> new array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 申请一个大小跟 A[p...r] 一样的临时数组</span>  <span class="token keyword">while</span> i<span class="token operator">&lt;=</span>q AND j<span class="token operator">&lt;=</span>r <span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// i++ 等于 i:=i+1</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 判断哪个子数组中有剩余的数据</span>  var start <span class="token punctuation">:</span><span class="token operator">=</span> i，end <span class="token punctuation">:</span><span class="token operator">=</span> q  <span class="token keyword">if</span> j<span class="token operator">&lt;=</span>r then start <span class="token punctuation">:</span><span class="token operator">=</span> j<span class="token punctuation">,</span> end<span class="token punctuation">:</span><span class="token operator">=</span>r  <span class="token comment" spellcheck="true">// 将剩余的数据拷贝到临时数组 tmp</span>  <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end <span class="token keyword">do</span> <span class="token punctuation">{</span>    tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> A<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 将 tmp 中的数组拷贝回 A[p...r]</span>  <span class="token keyword">for</span> i<span class="token punctuation">:</span><span class="token operator">=</span><span class="token number">0</span> to r<span class="token operator">-</span>p <span class="token keyword">do</span> <span class="token punctuation">{</span>    A<span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge()函数的python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> p<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 初始化变量 i, j, k</span>    tmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> p<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 申请一个大小跟 arr[p:r+1] 一样的临时数组</span>    <span class="token keyword">while</span> i <span class="token operator">&lt;=</span> q <span class="token operator">and</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        k <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 判断哪个子数组中有剩余的数据</span>    start<span class="token punctuation">,</span> end <span class="token operator">=</span> i<span class="token punctuation">,</span> q    <span class="token keyword">if</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end <span class="token operator">=</span> j<span class="token punctuation">,</span> r    <span class="token comment" spellcheck="true"># 将剩余的数据拷贝到临时数组 tmp</span>    <span class="token keyword">while</span> start <span class="token operator">&lt;=</span> end<span class="token punctuation">:</span>        tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span>        k <span class="token operator">+=</span> <span class="token number">1</span>        start <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 将 tmp 中的数组拷贝回 arr[p:r+1]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>p <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用哨兵简化merge函数的编写"><a href="#利用哨兵简化merge函数的编写" class="headerlink" title="利用哨兵简化merge函数的编写"></a>利用哨兵简化merge函数的编写</h3><p><img src="imgs/1571040886966.png" alt="1571040886966"></p><p>看上图并结合下面的代码，首先把原始数组arr[p…q] copy到临时数组L,原始数组arr[q+1…r]copy到临时数组R</p><p>然后分别再临时数组L和R添加哨兵，使用int的最大值保证任何非自己的数都比自己小即可。</p><p>然后开始比较L[i]和R[j],取较小值赋值到原始数组，赋值过程中对应的角标都会+1，当i或j移动到尾部max时，由于max永远比其他数要大，所以循环结束后，临时数组L和R不会再有剩余的元素。</p><p>带哨兵的merge函数的python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">merge_by_sentry</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    n1<span class="token punctuation">,</span> n2 <span class="token operator">=</span> q <span class="token operator">-</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">-</span> q  <span class="token comment" spellcheck="true"># 表示两个子数组的长度</span>    <span class="token comment" spellcheck="true"># 需要一个位置存储哨兵，所以临时数组长度是 子数组长度+1</span>    L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    R <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 拷贝数据到临时数组 L[] 和 R[]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span><span class="token punctuation">:</span>        L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p <span class="token operator">+</span> i<span class="token punctuation">]</span>    L<span class="token punctuation">[</span>n1<span class="token punctuation">]</span> <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize  <span class="token comment" spellcheck="true"># 第一个数组添加哨兵（最大值）</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n2<span class="token punctuation">)</span><span class="token punctuation">:</span>        R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>q <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span>    R<span class="token punctuation">[</span>n2<span class="token punctuation">]</span> <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize  <span class="token comment" spellcheck="true"># 第二个数组添加哨兵（最大值）</span>    <span class="token comment" spellcheck="true"># 归并临时数组到 arr[l..r]</span>    i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> p  <span class="token comment" spellcheck="true"># 初始化变量 i, j, k</span>    <span class="token keyword">while</span> k <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样</span>        <span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            j <span class="token operator">+=</span> <span class="token number">1</span>        k <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h3><p><strong>第一，归并排序是稳定的排序算法吗？</strong></p><p>归并排序在合并的过程中，如果 A[p…m] 和 A[m+1…r] 之间有值相同的元素，可以先把 A[p…m] 中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p><strong>第二，归并排序的时间复杂度是多少？</strong></p><p>递归代码的时间复杂度可以写成递推公式。</p><p>如果定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T(c)</p><p>那就可以得到这样的递推关系式：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">T</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">T</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">+</span> K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p><p>假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。而merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，归并排序的时间复杂度的计算公式就是：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">T</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> C；   n<span class="token operator">=</span><span class="token number">1</span> 时，只需要常量级的执行时间，所以表示为 C。<span class="token function">T</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> n； n<span class="token operator">></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进一步分解一下计算过程：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> n     <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>n     <span class="token operator">=</span> <span class="token number">4</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>n <span class="token operator">=</span> <span class="token number">8</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>n     <span class="token operator">=</span> <span class="token number">8</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token operator">*</span>n <span class="token operator">=</span> <span class="token number">16</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token operator">*</span>n     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span>k <span class="token operator">*</span> <span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">^</span>k<span class="token punctuation">)</span> <span class="token operator">+</span> k <span class="token operator">*</span> n     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过一步一步分解推导可以得到$T(n) =2^k<em>T( \frac{n}{2^k})+k</em>n$。</p><p>当 $T(\frac{n}{2^k})=T(1)$ 时，也就是 $\frac{n}{2^k}=1$，得到 $k=log_2n$ 。</p><p>将 k 值代入上面的公式，得到 $T(n)=C<em>n+n</em>log_2n $。</p><p>用大 O 标记法来表示T(n) 就等于 $O(nlogn)$。所以归并排序的时间复杂度是 $O(nlogn)$。</p><p>从原理分析和代码来看，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 $O(nlogn)$。</p><p><strong>第三，归并排序的空间复杂度是多少？</strong></p><p>归并排序不是原地排序算法。归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 $O(n)$。</p><h3 id="日志合并题"><a href="#日志合并题" class="headerlink" title="日志合并题"></a>日志合并题</h3><p>现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><p>答：</p><p>按照归并排序，归并的思路合并即可，只不过归并排序两两合并，这里是一次性10个一起合并完。</p><p>具体方法：</p><p>申请一个10个空间的临时数组，每个空间的角标对应一个日志文件，一开始先从10日志文件每个都读取一行数据存入临时对应角标数组中，然后查找这个数组中，时间戳最小的数据，写入文件，然后该角标对应的文件流读一行数据。再循环上述过程，若有文件没有数据可以读，则在临时数组对应位置写入一个会被判断为最大的哨兵数据。若在临时数组中查找到的最小数据也是写入的哨兵数据，则表示所有文件已经全部读取完，处理完毕！</p><p>由于内存有1GB，为了充分利用内存，可以把读取流和写入流的缓冲区写大一些。这里我给每个日志文件读取流设置50MB缓冲，写出流设置300MB缓冲共800MB缓冲区。</p><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>__author__ <span class="token operator">=</span> <span class="token string">'xiaoxiaoming'</span><span class="token keyword">import</span> sysfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>out <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"out.log"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> buffering<span class="token operator">=</span><span class="token number">300</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    fs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">"../logs/%s.log"</span> <span class="token operator">%</span> i<span class="token punctuation">,</span> buffering<span class="token operator">=</span><span class="token number">50</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>fs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>    min <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> int<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            min <span class="token operator">=</span> i    <span class="token keyword">if</span> data<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">==</span> sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">:</span> <span class="token keyword">break</span>    out<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span>    out<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span>    line <span class="token operator">=</span> fs<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> line<span class="token punctuation">:</span>        data<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> line    <span class="token keyword">else</span><span class="token punctuation">:</span>        data<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize<span class="token keyword">for</span> f <span class="token keyword">in</span> fs<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法（Quicksort），简称为“快排”。</p><p>快排采用分治的思想，被排序数组中下标从 p 到 r ，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p><p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。这样数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p><img src="imgs/2/1570439501672.png" alt="1570439501672"></p><p>根据分治、递归的处理思想，递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p><p>上面的过程的递推公式：</p><pre class="line-numbers language-c"><code class="language-c">递推公式：<span class="token function">quick_sort</span><span class="token punctuation">(</span>p…r<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>p…q<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>终止条件：p <span class="token operator">>=</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归伪代码实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 快速排序，A 是数组，n 表示数组的大小</span><span class="token function">quick_sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 快速排序递归函数，p,r 为下标</span><span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> p <span class="token operator">>=</span> r then <span class="token keyword">return</span>  q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取分区点</span>  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token number">-1</span><span class="token punctuation">)</span>  <span class="token function">quick_sort_c</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>partition() 分区函数会随机选择一个元素作为 pivot，然后对 A[p…r] 分区，函数返回 pivot 的下标。</p><p>如果不考虑空间消耗的话，partition() 分区函数可以写得非常简单。申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]。</p><p><img src="imgs/2/1570439557784.png" alt="1570439557784"></p><p>但如果按照这种思路实现partition() 函数就需要很多额外的内存空间，快排就不是原地排序算法了。</p><p>如果希望快排是原地排序算法，它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，需要在 A[p…r] 的原地完成分区操作。</p><p>原地分区函数的伪代码实现思路：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>  pivot <span class="token punctuation">:</span><span class="token operator">=</span> A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>  i <span class="token punctuation">:</span><span class="token operator">=</span> p  <span class="token keyword">for</span> j <span class="token punctuation">:</span><span class="token operator">=</span> p to r<span class="token number">-1</span> <span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot <span class="token punctuation">{</span>      swap A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> with A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>      i <span class="token punctuation">:</span><span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  swap A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> with A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>  <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 i 把 A[p…r-1] 分成两部分，A[p…i-1] 的元素都是小于 pivot 的，暂且叫它“已处理区间”，A[i…r-1] 是“未处理区间”。每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i] 的位置。这样可以在 O(1) 时间复杂度内将 A[j] 放到下标为 i 的位置：</p><p><img src="imgs/2/1570439590377.png" alt="1570439590377"></p><p>上面的分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取最后一个元素作为分区点</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> p<span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> p<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    i<span class="token punctuation">,</span> pivot <span class="token operator">=</span> p<span class="token punctuation">,</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">!=</span> j<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            i <span class="token operator">+=</span> <span class="token number">1</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h3><p>快排并不占用额外的内存空间，所以快排是一种稳定的排序算法。</p><p>快排的分区过程涉及交换操作，相同元素先后顺序会发生改变、所以快排是一种不稳定的排序算法。</p><p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 $O(nlogn)$。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">T</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> C；   n<span class="token operator">=</span><span class="token number">1</span> 时，只需要常量级的执行时间，所以表示为 C。<span class="token function">T</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> n； n<span class="token operator">></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>但是并不能每次分区操作都正好能将大区间对等地一分为二：</strong></p><p>如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 $O(nlogn)$ 退化成了 $O(n^2)$。</p><p>分区极其均衡和分区极其不均衡，两个极端情况下，分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。</p><p>假设每次分区操作都将区间分成大小为 9:1 的两个小区间。套用递归时间复杂度的递推公式：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">T</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> C；   n<span class="token operator">=</span><span class="token number">1</span> 时，只需要常量级的执行时间，所以表示为 C。<span class="token function">T</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">T</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span>n<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> n； n<span class="token operator">></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结论：T(n) 在大部分情况下的时间复杂度都可以做到 $O( nlogn)$，只有在极端情况下，才会退化到 $O(n^2)$。</p><p>所以平均情况时间复杂度为$O(nlogn)$</p><h3 id="快速排序的另一种分区实现"><a href="#快速排序的另一种分区实现" class="headerlink" title="快速排序的另一种分区实现"></a>快速排序的另一种分区实现</h3><p>思路：</p><ul><li>随机选取基准值, 并将基准值替换到数组第一个元素</li><li>选取第一个元素作为基准值</li><li>从右向左查找一个比基准值小的元素替换左指针的元素</li><li>从左向右查找一个比基准值大的元素替换右指针的元素</li><li>直到左指针与右指针之间没有元素</li><li>最后左指针与右指针共同指向的位置就是分区点，将分区点的值设置为基准值。</li></ul><p><img src="imgs/1571227085370.png" alt="1571227085370"></p><p>上图中的颜色表示从黄色位置复制到红色位置：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partition_two_way</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 随机选取基准值, 并将基准值替换到数组第一个元素</span>    q <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>p<span class="token punctuation">,</span> r<span class="token punctuation">)</span>    arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span>    pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span>    <span class="token keyword">while</span> p <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 从右向左查找比基准值小的位置</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;</span> r <span class="token operator">and</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">:</span> r <span class="token operator">-=</span> <span class="token number">1</span>        arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 从左向右查找比基准值大的位置</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;</span> r <span class="token operator">and</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">:</span> p <span class="token operator">+=</span> <span class="token number">1</span>        arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> pivot    <span class="token keyword">return</span> p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速在无序数组中查找第-K-大元素"><a href="#快速在无序数组中查找第-K-大元素" class="headerlink" title="快速在无序数组中查找第 K 大元素"></a>快速在无序数组中查找第 K 大元素</h3><p>快排核心思想就是<strong>分治</strong>和<strong>分区</strong>，利用分区的思想，可以很容易在O(n) 时间复杂度内求无序数组中的第 K 大元素。</p><p>思路：</p><p>使用任意一种快排的分区函数即可将数组A[0…n-1]分为A[0…q-1]、A[q]、A[q+1…n-1]三部分。</p><p>如果 q=K-1，那 A[q] 就是要求解的元素；</p><p>如果 q&lt;K-1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，再递归地在 A[p+1…n-1] 这个区间内继续查找。</p><p>如果 q&gt;K-1，说明第 K 大元素出现在 A[0…p-1] 区间，再递归地在 A[p+1…n-1] 这个区间内继续查找。</p><p><img src="imgs/2/1570439636166.png" alt="1570439636166"></p><p>代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">kth_smallest</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> k<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    q <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> q <span class="token operator">!=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> q <span class="token operator">&lt;</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>            q <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            q <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一次分区查找，需要遍历 n 个元素执行分区操作。第二次分区查找，只需要遍历 n/2 个元素执行分区操作。</p><p>依次类推，分区遍历元素的个数分别为n、n/2、n/4、n/8、n/16.……直到区间缩小为 1。</p><p>最差的情况:<br>$$<br>由(\frac{1}2)^{m}=\frac{1}n得m=log_{\frac{1}2}\frac{1}n \\故n+\frac{n}2+\frac{n}4+\frac{n}8+…+1=n\cdot(1+\frac{1}2+\frac{1}4+\frac{1}8+…+\frac{1}n) \\=n\cdot\frac{1-\frac{1}2\cdot(\frac{1}2)^{\log_{\frac{1}2}{\frac{1}n}}}{1-\frac{1}2} =2n\cdot (1-\frac{1}2\cdot\frac{1}n)\\=2n-1<br>$$<br>所以，上述代码的时间复杂度为 O(n)。</p><h2 id="快排和归并的区别"><a href="#快排和归并的区别" class="headerlink" title="快排和归并的区别"></a>快排和归并的区别</h2><p><img src="imgs/2/1570439607551.png" alt="1570439607551"></p><p>归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。快速排序的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。</p><p>归并排序和快速排序的时间复杂度都为 $O(nlogn)$。</p><p>归并排序是稳定的、非原地排序算法，而快速排序是非稳定的原地排序算法。</p><h1 id="时间复杂度为-O-n-的三种线性排序算法"><a href="#时间复杂度为-O-n-的三种线性排序算法" class="headerlink" title="时间复杂度为 O(n) 的三种线性排序算法"></a>时间复杂度为 O(n) 的三种线性排序算法</h1><p>三种时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。</p><p>因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作<strong>线性排序</strong>（Linear sort）。</p><p>这三个算法都不涉及元素之间的比较操作，是不基于比较的排序算法。</p><h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>桶排序核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="imgs/2/1570439866145.png" alt="1570439866145"></p><p>桶排序的时间复杂度分析：</p><p>如果要排序的数据有 n 个均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 $O(k\cdot\log_{}k)$。m 个桶排序的时间复杂度就是 $O(m\cdot k\cdot logk)$，因为 $k=n/m$，所以整个桶排序的时间复杂度就是 $O(n\cdot log(n/m))$。当桶的个数 m 接近数据个数 n 时，$log(n/m)$ 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 $O(n)$。</p><p>桶排序要求要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次要求数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 $O(nlogn)$ 的排序算法了。</p><p>简易python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token comment" spellcheck="true"># m表示桶的个数</span><span class="token keyword">def</span> <span class="token function">bucket_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> list<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span> <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 扫描最小值和最大值</span>    min<span class="token punctuation">,</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">:</span>            min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">elif</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">:</span>            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    bucket_size <span class="token operator">=</span> math<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> m<span class="token punctuation">)</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 将数组中值分配到各个桶里</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> arr<span class="token punctuation">:</span>        bucket_index <span class="token operator">=</span> <span class="token punctuation">(</span>data <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">//</span> bucket_size        buckets<span class="token punctuation">[</span>bucket_index<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 对每个桶进行排序,时间复杂度小于O(nlogn)的排序算法都可以</span>    k <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> bucket <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>        bucket<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> data <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data            k <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    a3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span>    bucket_sort<span class="token punctuation">(</span>a3<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>桶排序比较适合用在外部排序（数据存储在外部磁盘中）中</strong>：</p><p>比如有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存只有几百 MB。</p><p>可以先扫描一遍文件，分析订单金额所处的数据范围。假设经过扫描之后订单金额最小是 1 元，最大是 10 万元。将所有订单根据金额划分到 100 个桶里，第一个桶存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p><p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>但订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，有可能某个金额区间的数据特别多，针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p><h2 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h2><p><strong>计数排序可以理解是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>比如高考查分数系统排序并计算名次，考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p><strong>计数排序算法的简单实现：</strong></p><p>假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩放在一个数组 A[8] 中，它们分别是：2，5，3，0，2，3，0，3。</p><p>考生的成绩从 0 到 5 分，可以使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数，C[6]内存储对应的考生个数。</p><p><img src="imgs/2/1570439893869.png" alt="1570439893869"></p><p>然后只需要将C[6]数组的数据展开遍历赋值回A[8]，A[8]中的数据就是有序的了。</p><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token comment" spellcheck="true"># 对每个分数进行计数</span><span class="token keyword">def</span> <span class="token function">get_counts</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    counts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> counts<span class="token comment" spellcheck="true"># 简单的计数排序</span><span class="token keyword">def</span> <span class="token function">counting_sort_simple</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span>    counts <span class="token operator">=</span> get_counts<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    k <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        count <span class="token operator">=</span> counts<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> i            k <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>计数排序的复杂实现方法：</strong></p><p>对 C[6] 数组顺序求和，C[k] 里存储小于等于分数 k 的考生个数，可以快速计算出每个分数的考生在有序数组中对应的存储位置 ：</p><p><img src="imgs/1571226184051.png" alt="1571226184051"></p><p>python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_sum_counts</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    counts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> counts<span class="token punctuation">[</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> counts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历数组A，对于被遍历的数据去数组C中取出对应角标的值，比如遍历到3时，从数组C中取出角标为3的值7。然后把被遍历的数据放入临时数组R角标为7-1的位置中，数组C中对应角标位置的值减1。</p><p>遍历数组A的过程中，当第二次遍历到3时，就会把它放入临时数组 R 中的角标为 6 -1的位置，遍历完整个数组 A 后，临时数组 R 内的数据就是有序排列的了。</p><p>如果要求计数排序是稳定的排序算法，则对数组A必须倒序遍历，因为数组C中先取出的是相同元素中最后一个元素的位置，倒序遍历数组A，则可以使用数组A后面的元素先插入临时数组R。</p><p><img src="imgs/1570439941723.png" alt="1570439941723"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 查找数组中数据的范围</span>  <span class="token keyword">int</span> max <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      max <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 申请一个计数数组 c，下标大小 [0,max]</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 计算每个元素的个数，放入 c 中</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 依次累加</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 临时数组 r，存储排序之后的结果</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 计算排序的关键步骤，有点难理解</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> c<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    r<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    c<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 将结果拷贝给 a 数组</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> List<span class="token comment" spellcheck="true"># 便于获得指定数值的在有序数组中对应的存储位置</span><span class="token keyword">def</span> <span class="token function">get_sum_counts</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    counts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">+=</span> counts<span class="token punctuation">[</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> counts<span class="token comment" spellcheck="true"># 计数排序</span><span class="token keyword">def</span> <span class="token function">counting_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> arr    counts <span class="token operator">=</span> get_sum_counts<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n    <span class="token comment" spellcheck="true"># 遍历数组arr，对于被遍历的数据去数组C中取出对应角标的值，比如遍历到3时，从数组C中取出角标为3的值7。</span>    <span class="token comment" spellcheck="true"># 然后把被遍历的数据放入临时数组R角标为7-1的位置中，数组C中对应角标位置的值减1。</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        r<span class="token punctuation">[</span>counts<span class="token punctuation">[</span>data<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data        counts<span class="token punctuation">[</span>data<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总之，<strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p><p>比如，考生成绩精确到小数后一位，就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是 [-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p><h2 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h2><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p><p>例如，希望将 10 万个手机号码从小到大排序，要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。但如果要求是稳定的排序算法，可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p><p>根据每一位来排序，可以用桶排序或者计数排序，如果要排序的数据有 k 位，最大需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，基数排序的时间复杂度就近似于 O(n)。</p><p>对于字符串数据，假如要排序的数据并不都是等长的，可以把所有数据补齐到相同长度，位数不够的可以在后面补“0”。</p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">radix_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">:</span>            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    max_len <span class="token operator">=</span> len<span class="token punctuation">(</span>str<span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 从个位开始（保证稳定性），对数组每一位都进行一次计数排序</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>max_len<span class="token punctuation">)</span><span class="token punctuation">:</span>        exp <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">**</span> i        arr <span class="token operator">=</span> counting_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> exp<span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token keyword">def</span> <span class="token function">counting_sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 计算每个元素的个数</span>    counts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        counts<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">//</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 计算排序后的位置</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>counts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        counts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> counts<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 临时数组r，存储排序之后的结果</span>    r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">//</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span>        r<span class="token punctuation">[</span>counts<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        counts<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="根据年龄快速给-100-万用户排序"><a href="#根据年龄快速给-100-万用户排序" class="headerlink" title="根据年龄快速给 100 万用户排序"></a>根据年龄快速给 100 万用户排序</h2><p>解决思路：</p><p>可以按照计数排序的思路，假设年龄的范围最小 1 岁，最大不超过 120 岁。可以遍历这 100 万用户，根据年龄将其划分到121 个桶里，然后依次顺序遍历这 121 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。</p><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 桶排序</span><span class="token keyword">def</span> <span class="token function">quick_user_sort_by_age</span><span class="token punctuation">(</span>user_list<span class="token punctuation">:</span> list<span class="token punctuation">,</span> fn<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> int<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>user_list<span class="token punctuation">)</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> user_list    <span class="token comment" spellcheck="true"># 便于获得指定数值的在有序数组中对应的存储位置</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">121</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        buckets<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> data <span class="token keyword">in</span> user_list<span class="token punctuation">:</span>        buckets<span class="token punctuation">[</span>fn<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    k <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> bucket <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>        <span class="token keyword">for</span> data <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>            user_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> data            k <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串排序问题"><a href="#字符串排序问题" class="headerlink" title="字符串排序问题"></a>字符串排序问题</h2><p>假设需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 桶排序</span><span class="token keyword">def</span> <span class="token function">string_sort</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 便于获得指定数值的在有序数组中对应的存储位置</span>    buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    i <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> ch <span class="token keyword">in</span> s<span class="token punctuation">:</span>        <span class="token keyword">if</span> ch<span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            buckets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">elif</span> ch<span class="token punctuation">.</span>isnumeric<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            buckets<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">elif</span> ch<span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            buckets<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>ch<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> i<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> bucket <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>        <span class="token keyword">for</span> data <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h1><table><thead><tr><th align="center"></th><th align="center">时间复杂度</th><th align="center">是稳定排序？</th><th align="center">是原地排序？</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">$O(n^2)$</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">插入排序</td><td align="center">$O(n^2)$</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">选择排序</td><td align="center">$O(n^2)$</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="center">快速排序</td><td align="center">$O(nlogn)$</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="center">归并排序</td><td align="center">$O(nlogn)$</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">计数排序</td><td align="center">$O(n+k)$ k是数据范围</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">桶排序</td><td align="center">$O(n)$</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">基数排序</td><td align="center">$O(dn)$  d是维度</td><td align="center">Y</td><td align="center">N</td></tr></tbody></table><p>如果对小规模数据进行排序，可以选择时间复杂度是 $O(n^2 )$ 的算法；如果对大规模数据进行排序，时间复杂度是 $O(nlogn)$ 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 $O(nlogn)$ 的排序算法来实现排序函数。</p><p>归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了。整体而言快速排序比较适合来实现排序函数。</p><h2 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h2><p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 $O(n^2)$。实际上，<strong>这种 $O(n^2)$ 时间复杂度出现的主要原因还是因为我们分区点选的不够合理</strong>。</p><p>两个比较常用、比较简单的分区算法：</p><h3 id="1-三数取中法"><a href="#1-三数取中法" class="headerlink" title="1. 三数取中法"></a>1. 三数取中法</h3><p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><h3 id="2-随机法"><a href="#2-随机法" class="headerlink" title="2. 随机法"></a>2. 随机法</h3><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 $O(n^2)$ 的情况，出现的可能性不大。</p><p>快速排序是用递归来实现的，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h2 id="C语言qsort-排序函数的实现原理"><a href="#C语言qsort-排序函数的实现原理" class="headerlink" title="C语言qsort()排序函数的实现原理"></a>C语言qsort()排序函数的实现原理</h2><p><strong>qsort() 会优先使用归并排序来排序输入数据</strong>，但要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序，使用“三数取中法”选择快速排序算法的分区点。</p><p>qsort() 通过自己实现一个堆上的栈，手动模拟递归来解决递归太深会导致堆栈溢出的问题。</p><p>在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>06.递归</title>
      <link href="//post/06.%E9%80%92%E5%BD%92.html"/>
      <url>//post/06.%E9%80%92%E5%BD%92.html</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><p>递归是一种非常高效、简洁的编码技巧，不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><p>很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等。</p><p>一个生活中用到递归的例子：</p><blockquote><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p></blockquote><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。这个例子，用递推公式将它表示出来就是这样的：</p><pre><code>f(n)=f(n-1)+1 其中，f(1)=1</code></pre><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，就可以很轻松地将它改为递归代码，如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>满足三个条件的问题可以用递归来解决：</p><p><strong>1. 一个问题的解可以分解为几个子问题的解</strong></p><p>子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p><p><strong>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong></p><p>比如电影院那个例子，求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p><p><strong>3. 存在递归终止条件</strong></p><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。</p><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>。</p><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p><p>可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后n-1 个台阶的走法，加上先走 2 阶后n-2 个台阶的走法。用公式表示就是：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看终止条件:</p><p>当有一个台阶时，就不需要再继续递归，就只有一种走法。所以 f(1)=1。</p><p>再用 n=2，n=3 这样比较小的数试验一下这个递归终止条件是否足够：</p><p>n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来又不符合正常的逻辑思维。所以可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 f(1)=1，f(2)=2。这时再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。</p><p>把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p><p>第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p><p><strong>正确的理解递归的思维方式：</strong></p><p>如果一个问题 A 可以分解为若干子问题 B、C、D，先假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。如果递归求解的数据规模很大，调用层次很深，一直压入栈，<strong>就会有堆栈溢出的风险</strong>。</p><p>上面的讲的电影院的例子，如果将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：</p><pre class="line-numbers language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StackOverflowError<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么，如何避免出现堆栈溢出呢？</p><p>方法之一是在代码中限制递归调用的最大深度，递归调用超过一定深度（比如 1000）之后，就直接返回报错。</p><p>电影院那个例子，可以改造成下面这样子，就可以避免堆栈溢出了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 全局变量，表示递归的深度。</span><span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token operator">++</span>depth；  <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span> throw exception<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不实用。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>刚才第二个递归代码的例子把整个递归过程分解一下：</p><p><img src="imgs/2/1570433907877.png" alt="1570433907877"></p><p>从图中，可以看到要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasSolvedList<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hasSovledList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hasSovledList<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如电影院递归代码，空间复杂度是 O(n)。</p><h2 id="将递归代码改写为非递归代码"><a href="#将递归代码改写为非递归代码" class="headerlink" title="将递归代码改写为非递归代码"></a>将递归代码改写为非递归代码</h2><p>递归代码的表达力很强，写起来非常简洁，但是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，应当根据实际情况尽量把递归代码改写为非递归代码。</p><p>只看 f(x) =f(x-1)+1 这个递推公式。可以这样改写：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个例子也可以改为非递归的实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> prepre <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret <span class="token operator">=</span> pre <span class="token operator">+</span> prepre<span class="token punctuation">;</span>    prepre <span class="token operator">=</span> pre<span class="token punctuation">;</span>    pre <span class="token operator">=</span> ret<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那是不是所有的递归代码都可以改为这种<strong>迭代循环</strong>的非递归写法呢？</p><p>因为递归本身就是借助栈来实现的，如果自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，徒增了实现的复杂度。</p><h2 id="如何用三行代码找到“最终推荐人”？"><a href="#如何用三行代码找到“最终推荐人”？" class="headerlink" title="如何用三行代码找到“最终推荐人”？"></a>如何用三行代码找到“最终推荐人”？</h2><p>推荐注册返佣金这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。则用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p><p>可以通过数据库来记录这种推荐关系，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。</p><table><thead><tr><th align="center">actor_id</th><th align="center">referrer_id</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">A</td></tr><tr><td align="center">C</td><td align="center">B</td></tr></tbody></table><p><strong>给定一个用户 ID，如何查找这个用户的“最终推荐人”？</strong> </p><p>java递归伪代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">long</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span><span class="token keyword">long</span> actorId<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Long referrerId <span class="token operator">=</span> select referrer_id from <span class="token punctuation">[</span>table<span class="token punctuation">]</span> where actor_id <span class="token operator">=</span> actorId<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>referrerId <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> actorId<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">findRootReferrerId</span><span class="token punctuation">(</span>referrerId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作。</p><p>第一，如果递归很深，可能会有堆栈溢出的问题。</p><p>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。</p><p>前两种问题都可以用限制递归深度来解决，</p><p>第二种问题还可以检测 A-B-C-A 这种“环”，上面的伪代码可以改写为</p><p>可以利用python的set进行检测：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">find_root_referrer_id</span><span class="token punctuation">(</span>actorId<span class="token punctuation">:</span> int<span class="token punctuation">,</span> relation<span class="token punctuation">:</span> set<span class="token punctuation">)</span><span class="token punctuation">:</span>    relation<span class="token punctuation">.</span>add<span class="token punctuation">(</span>actorId<span class="token punctuation">)</span>    referrerId <span class="token operator">=</span> cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>r<span class="token string">"select referrer_id from user_info where actor_id = %s"</span><span class="token punctuation">,</span> actorId<span class="token punctuation">)</span>    <span class="token keyword">if</span> referrerId <span class="token keyword">in</span> relation <span class="token operator">or</span> referrerId <span class="token operator">==</span> None<span class="token punctuation">:</span>        <span class="token keyword">return</span> actorId    <span class="token keyword">return</span> find_root_referrer_id<span class="token punctuation">(</span>referrerId<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a><strong>斐波那契数列</strong></h2><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……。</p><p>在数学上，费波那契数列是以递归的方法来定义：</p><pre><code>F(0)=0(n=0)F(1)=1(n=1)F(n)=F(n-1)+F(n-2) (n&gt;=2，n∈N*)</code></pre><p>python实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> n    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树形显示目录"><a href="#树形显示目录" class="headerlink" title="树形显示目录"></a>树形显示目录</h2><p>利用递归实现类似linux下的tree命令的效果，例如：</p><pre><code>static|--css|  |--addons|  |  |--uikit.addons.min.css|  |  |--uikit.almost-flat.addons.min.css|  |  `--uikit.gradient.addons.min.css|  |--awesome.css|  |--uikit.almost-flat.min.css|  |--uikit.gradient.min.css|  `--uikit.min.css|--fonts|  |--fontawesome-webfont.eot|  |--fontawesome-webfont.ttf|  |--fontawesome-webfont.woff|  `--FontAwesome.otf|--img|  `--user.png|--js|  |--awesome.js|  |--jquery.min.js|  |--sha1.min.js|  |--sticky.min.js|  |--uikit.min.js|  `--vue.min.js`--READMEtemplates|--blog.html|--blogs.html|--manage_blogs.html|--manage_blog_edit.html|--manage_comments.html|--manage_users.html|--register.html|--signin.html`--__base__.html</code></pre><p>代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>__author__ <span class="token operator">=</span> <span class="token string">'xiaoxiaoming'</span><span class="token keyword">import</span> os<span class="token keyword">def</span> <span class="token function">tree_dir</span><span class="token punctuation">(</span>dir<span class="token punctuation">,</span> layer<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    listdir <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>dir<span class="token punctuation">)</span>    <span class="token keyword">for</span> index<span class="token punctuation">,</span> file <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>listdir<span class="token punctuation">)</span><span class="token punctuation">:</span>        file_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dir<span class="token punctuation">,</span> file<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"|  "</span> <span class="token operator">*</span> <span class="token punctuation">(</span>layer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>layer <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"`--"</span> <span class="token keyword">if</span> index <span class="token operator">==</span> len<span class="token punctuation">(</span>listdir<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token string">"|--"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            tree_dir<span class="token punctuation">(</span>file_path<span class="token punctuation">,</span> layer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>tree_dir<span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>05.队列</title>
      <link href="//post/05.%E9%98%9F%E5%88%97.html"/>
      <url>//post/05.%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="队列的结构"><a href="#队列的结构" class="headerlink" title="队列的结构"></a>队列的结构</h1><p>可以把队列想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。</p><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，就需要循环数组实现的循环队列。</p><p><strong>先进者先出，是典型的“队列”</strong>。</p><p><strong>后进者先出，先进者后出，是典型的“栈”结构。</strong></p><p>栈只支持<strong>入栈 push()和出栈 pop()</strong>两个操作。</p><p>队列只支持：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。</p><p><img src="imgs/2/1570433339703.png" alt="1570433339703"></p><p>队列跟栈一样也是一种<strong>操作受限的线性表数据结构</strong>。</p><p>循环队列、阻塞队列、并发队列等具有某些额外特性的队列，它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。</p><p>比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；</p><p>Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><h1 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h1><p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><h2 id="数组实现的顺序队列"><a href="#数组实现的顺序队列" class="headerlink" title="数组实现的顺序队列"></a>数组实现的顺序队列</h2><p>java基于数组的实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 用数组实现的队列</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 数组：items，数组大小：n</span>  <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// head 表示队头下标，tail 表示队尾下标</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 申请一个大小为 capacity 的数组</span>  <span class="token keyword">public</span> <span class="token function">ArrayQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 入队</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>String item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 tail == n 表示队列已经满了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token operator">++</span>tail<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 出队</span>  <span class="token keyword">public</span> String <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 head == tail 表示队列为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了</span>    String ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">++</span>head<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把上面代码翻译成python：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""用数组实现的队列"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>items<span class="token punctuation">:</span> list <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> capacity        self<span class="token punctuation">.</span>_capacity <span class="token operator">=</span> capacity        self<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 队头下标</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># 队尾下标</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""入队"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail <span class="token operator">==</span> self<span class="token punctuation">.</span>_capacity<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item        self<span class="token punctuation">.</span>tail <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""出队"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>head <span class="token operator">==</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">:</span>            <span class="token keyword">return</span> None        item <span class="token operator">=</span> self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>head<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>head <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> item    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">return</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>head<span class="token punctuation">:</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p><p>当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p><p><img src="imgs/2/1570433366474.png" alt="1570433366474"></p><p>调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p><p><img src="imgs/2/1570433383574.png" alt="1570433383574"></p><p>随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。</p><p>当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这时只需要触发一次数据的搬移操作即可：</p><pre class="line-numbers language-java"><code class="language-java">   <span class="token comment" spellcheck="true">// 入队操作，将 item 放入队尾</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>String item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// tail == n 表示队列末尾没有空间了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 数据搬移</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tail<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">[</span>i<span class="token operator">-</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 搬移完之后重新更新 head 和 tail</span>      tail <span class="token operator">-=</span> head<span class="token punctuation">;</span>      head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token operator">++</span>tail<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相应python代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""入队"""</span>    <span class="token comment" spellcheck="true"># 表示队列末尾没有空间了</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail <span class="token operator">==</span> self<span class="token punctuation">.</span>capacity<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>head <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token comment" spellcheck="true"># 数据搬移</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>head<span class="token punctuation">,</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>i <span class="token operator">-</span> self<span class="token punctuation">.</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 搬移完之后重新更新 head 和 tail</span>        self<span class="token punctuation">.</span>tail <span class="token operator">-=</span> self<span class="token punctuation">.</span>head        self<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span>    self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item    self<span class="token punctuation">.</span>tail <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，就将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p><p><img src="imgs/2/1570433406655.png" alt="1570433406655"></p><p>这种实现思路中，出队入队操作的时间复杂度是 <strong>O(1)</strong></p><h2 id="链表实现的链式队列"><a href="#链表实现的链式队列" class="headerlink" title="链表实现的链式队列"></a>链表实现的链式队列</h2><p>基于链表的实现，需要head 和 tail 两个指针。分别指向链表的第一个和最后一个结点。</p><p>入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。</p><p><img src="imgs/2/1570433422411.png" alt="1570433422411"></p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueueBasedOnLinkedList</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 队列的队首和队尾</span>  <span class="token keyword">private</span> Node head <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">private</span> Node tail <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 入队</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>String value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Node newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>      tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>      tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 出队</span>  <span class="token keyword">public</span> String <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    String value <span class="token operator">=</span> head<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      tail <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node p <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String data<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>String data<span class="token punctuation">,</span> Node next<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python代码实现：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">class</span> <span class="token class-name">ListNode</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">:</span> str<span class="token punctuation">,</span> next<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>_next <span class="token operator">=</span> next<span class="token keyword">class</span> <span class="token class-name">LinkedQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span> <span class="token operator">=</span> None        self<span class="token punctuation">.</span>_tail<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span> <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 入队</span>        new_node <span class="token operator">=</span> ListNode<span class="token punctuation">(</span>value<span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_tail<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_tail<span class="token punctuation">.</span>_next <span class="token operator">=</span> new_node        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_head <span class="token operator">=</span> new_node        self<span class="token punctuation">.</span>_tail <span class="token operator">=</span> new_node    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""出队"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>_head<span class="token punctuation">:</span>            value <span class="token operator">=</span> self<span class="token punctuation">.</span>_head<span class="token punctuation">.</span>data            self<span class="token punctuation">.</span>_head <span class="token operator">=</span> self<span class="token punctuation">.</span>_head<span class="token punctuation">.</span>_next            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_head<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_tail <span class="token operator">=</span> None            <span class="token keyword">return</span> value    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p<span class="token punctuation">:</span> ListNode <span class="token operator">=</span> self<span class="token punctuation">.</span>_head        <span class="token keyword">while</span> p<span class="token punctuation">:</span>            values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>p<span class="token punctuation">.</span>data<span class="token punctuation">)</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>_next        <span class="token keyword">return</span> <span class="token string">"->"</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环数组实现的队列"><a href="#循环数组实现的队列" class="headerlink" title="循环数组实现的队列"></a>循环数组实现的队列</h2><p>上面用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，采用循环数组则不需要数据搬移操作。</p><p>原本数组是有头有尾的是一条直线，把它首尾相连扳成一个环：</p><p><img src="imgs/2/1570433438772.png" alt="1570433438772"></p><p>图中这个队列的大小为 8，当前 head=4，tail=7。</p><p>当有一个新的元素 a 入队时，放入下标为 7 的位置， tail 并不更新为 8，而是到下标为 0 的位置。</p><p>当再有一个元素 b 入队时，将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。</p><p>在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src="imgs/2/1570433457896.png" alt="1570433457896"></p><p><strong>确定队空和队满的判定条件</strong>。</p><p>队列为空的判断条件是 head == tail。</p><p><img src="imgs/2/1570433479539.png" alt="1570433479539"></p><p>如上图，显然队列满的判断条件是<strong>(tail+1)%n=head</strong>，</p><p>为了避免和队空的判断条件混淆，则必须牺牲一个数组的存储空间。</p><p>java实现代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CircularQueue</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 数组：items，数组大小：n</span>  <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// head 表示队头下标，tail 表示队尾下标</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 申请一个大小为 capacity 的数组</span>  <span class="token keyword">public</span> <span class="token function">CircularQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 入队</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>String item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 队列满了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    items<span class="token punctuation">[</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    tail <span class="token operator">=</span> <span class="token punctuation">(</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 出队</span>  <span class="token keyword">public</span> String <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 head == tail 表示队列为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>    String ret <span class="token operator">=</span> items<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python实现代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<span class="token keyword">class</span> <span class="token class-name">CircularQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity <span class="token operator">+</span> <span class="token number">1</span>        self<span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>capacity        self<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># head表示队头下标</span>        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># tail表示队尾下标</span>    <span class="token keyword">def</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> item<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""入队"""</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>capacity <span class="token operator">==</span> self<span class="token punctuation">.</span>head<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item        self<span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>capacity        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 如果head == tail 表示队列为空</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>head <span class="token operator">==</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">:</span> <span class="token keyword">return</span> None        item <span class="token operator">=</span> self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>head<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>capacity        <span class="token keyword">return</span> item    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>tail <span class="token operator">>=</span> self<span class="token punctuation">.</span>head<span class="token punctuation">:</span>            <span class="token keyword">return</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>head<span class="token punctuation">:</span> self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>items<span class="token punctuation">[</span>self<span class="token punctuation">.</span>head<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>tail<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="队列在实际开发中的应用"><a href="#队列在实际开发中的应用" class="headerlink" title="队列在实际开发中的应用"></a>队列在实际开发中的应用</h1><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src="imgs/2/1570433507770.png" alt="1570433507770"></p><p>使用阻塞队列，就可以轻松实现一个“生产者 - 消费者模型”！</p><p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。</p><p>可以多配置几个“消费者”，来应对一个“生产者”：</p><p><img src="imgs/2/1570433522754.png" alt="1570433522754"></p><p>python基于阻塞队列实现的<strong>生产者 - 消费者模型</strong>：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> queue<span class="token keyword">import</span> random<span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    nameList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"peach"</span><span class="token punctuation">,</span> <span class="token string">"pineapple"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token string">"blueberry"</span><span class="token punctuation">]</span>    flag <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> q<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>q <span class="token operator">=</span> q    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        name_list <span class="token operator">=</span> Producer<span class="token punctuation">.</span>nameList        <span class="token keyword">while</span> Producer<span class="token punctuation">.</span>flag<span class="token punctuation">:</span>            queueLock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>full<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                data <span class="token operator">=</span> name_list<span class="token punctuation">[</span>random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>name_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>data<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 生产数据: %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>threading<span class="token punctuation">.</span>currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>                queueLock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                queueLock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    flag <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> q<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>q <span class="token operator">=</span> q    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> Consumer<span class="token punctuation">.</span>flag<span class="token punctuation">:</span>            queueLock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                data <span class="token operator">=</span> self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 消费数据: %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>threading<span class="token punctuation">.</span>currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">)</span>                queueLock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                queueLock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span>workQueue <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>queueLock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建新线程</span>Producer<span class="token punctuation">(</span>workQueue<span class="token punctuation">,</span> <span class="token string">"Producer1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>Producer<span class="token punctuation">(</span>workQueue<span class="token punctuation">,</span> <span class="token string">"Producer2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>Consumer<span class="token punctuation">(</span>workQueue<span class="token punctuation">,</span> <span class="token string">"Consumer1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>Consumer<span class="token punctuation">(</span>workQueue<span class="token punctuation">,</span> <span class="token string">"Consumer2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>Consumer<span class="token punctuation">(</span>workQueue<span class="token punctuation">,</span> <span class="token string">"Consumer3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>workQueue<span class="token punctuation">.</span>queue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。</p><p>线程安全的队列叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p><h2 id="有限资源池"><a href="#有限资源池" class="headerlink" title="有限资源池"></a>有限资源池</h2><p>常见的有限资源池有线程池和数据库连接池。</p><p>CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><strong>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</strong></p><p>线程池一般有两种处理策略：</p><ul><li>非阻塞的处理方式，直接拒绝任务请求；</li><li>阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</li></ul><p>我们希望公平地处理每个排队的请求，先进者先服务，队列这种数据结构很适合来存储排队请求。</p><p>基于链表实现的队列，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。</p><p>队列设置太大会导致等待的请求太多，设置太小会导致无法充分利用系统资源、发挥最大性能。</p><p><strong>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>1、你还知道有哪些场景中会用到队列的排队请求呢？</p><p>答：</p><blockquote><p>各种消息队列，例如Active MQ ,Rabbit MQ ,Rocket MQ ,Zero MQ 以及分布式消息队列Kafka等。</p></blockquote><p>2、如何实现无锁并发队列？</p><p>答：</p><blockquote><p>使用 CAS 原子操作 + 循环数组的方式可以实现。</p><p>对于java语言，jdk提供了java.util.concurrent.atomic 包实现 CAS 原子操作</p><p>对于python语言可以使用协程，这样就不会存在并发访问问题。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02.数组</title>
      <link href="//post/02.%E6%95%B0%E7%BB%84.html"/>
      <url>//post/02.%E6%95%B0%E7%BB%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="02-数组"><a href="#02-数组" class="headerlink" title="02.数组"></a>02.数组</h1><p>数组是一种最基础的数据结构，在大部分编程语言中，数组都是从 0 开始编号的。</p><h1 id="线性表与非线性表"><a href="#线性表与非线性表" class="headerlink" title="线性表与非线性表"></a>线性表与非线性表</h1><p><strong>线性表</strong>（Linear List），就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，包括<strong>数组，链表、队列、栈</strong>等。</p><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p><img src="imgs%5C4.jpg" alt=""></p><p><strong>非线性表</strong>，数据之间并不是简单的前后关系，有二叉树、堆、图等，如下图：</p><p><img src="imgs%5C5.jpg" alt=""></p><h1 id="数组实现随机访问的方法"><a href="#数组实现随机访问的方法" class="headerlink" title="数组实现随机访问的方法"></a>数组实现随机访问的方法</h1><p>数组使用了<strong>连续的内存空间和相同类型的数据</strong>。使得它可以“随机访问”，但同时也让数组的删除、插入等操作变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。</p><p><strong>数组是如何实现根据下标随机访问数组呢？</strong></p><p>以一个长度为 10 的 int 类型的数组 <code>int[] a = new int[10]</code>为例。</p><p>计算机会给每个内存单元分配一个地址，并通过地址来访问内存中的数据。</p><p>下图中，假设计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src="imgs/6.jpg" alt=""></p><p>当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><pre><code>a[i]_address = base_address + i * data_type_size</code></pre><ul><li>data_type_size 表示数组中每个元素的大小。</li></ul><p>上面的数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p><h1 id="数组查找的时间复杂度"><a href="#数组查找的时间复杂度" class="headerlink" title="数组查找的时间复杂度"></a>数组查找的时间复杂度</h1><p>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p><p>排好序的数组用二分查找，时间复杂度是 O(logn)；</p><p>顺序查找，最好时间复杂度为 O(1)，最差时间复杂度为O(n)，平均时间复杂度为O(n)</p><h1 id="数组的低效操作"><a href="#数组的低效操作" class="headerlink" title="数组的低效操作"></a>数组的低效操作</h1><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来给新来的数据，需要将第 k～n 这部分的元素都顺序地往后挪一位。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 $\frac{1+2+…n}{n}=O(n)$。</p><p>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就必须搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p><p>假设数组 a[10] 中存储了如下 5 个元素：a，b，c，d，e。</p><p>现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可：</p><p><img src="imgs%5C7.jpg" alt=""></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h2><p>如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。可以将多次删除操作集中在一起执行。</p><p>比如数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。要依次删除 a，b，c 三个元素：</p><p><img src="imgs%5C8.jpg" alt=""></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作。</p><p>这有点像是 JVM 标记清除垃圾回收算法的核心思想。</p><h1 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h1><p>先分析一下这段 C 语言代码的运行结果：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”。</p><p>因为，数组大小为 3，a[0]，a[1]，a[2]，而  a[3] 访问越界，在 C 语言中，a[3] 被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，其他高级语言一般会报角标越界异常。</p><p>那么 <strong>a[3]=0 就相当于 i=0</strong>，所以就会导致代码无限循环。</p><p>访问数组的本质就是访问一段连续内存，在 C 语言中只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。</p><p> C语言把数组越界检查的工作丢给程序员来做，但 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 java.lang.ArrayIndexOutOfBoundsException。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="容器vs数组"><a href="#容器vs数组" class="headerlink" title="容器vs数组"></a>容器vs数组</h1><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。</p><p>ArrayList 最大的优势就是<strong>可以将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p><p>扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p><p>比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>xxx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>有些时候用数组会更合适些：</p><ol><li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li><li>当要表示多维数组时，用数组往往会更加直观。比如 <code>Object[][] array</code>；而用容器的话则需要这样定义：<code>ArrayList&lt;ArrayList&gt; array​</code>。</li></ol><p>总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器。</p><h1 id="为什么数组要从-0-开始编号"><a href="#为什么数组要从-0-开始编号" class="headerlink" title="为什么数组要从 0 开始编号?"></a>为什么数组要从 0 开始编号?</h1><p><strong>为什么数组要从 0 开始编号，而不是从 1 开始呢？</strong> 从 1 开始不是更符合人类的思维习惯吗？</p><p>从数组存储的内存模型上来看，<strong>“下标”最确切的定义应该是“偏移（offset）”</strong>。</p><p>从 0 开始编号，数组 a[k] 的内存寻址公式为：</p><pre class="line-numbers language-c"><code class="language-c">a<span class="token punctuation">[</span>k<span class="token punctuation">]</span>_address <span class="token operator">=</span> base_address <span class="token operator">+</span> k <span class="token operator">*</span> type_size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从 1 开始编号，数组 a[k] 的内存寻址公式为：</p><pre class="line-numbers language-c"><code class="language-c">a<span class="token punctuation">[</span>k<span class="token punctuation">]</span>_address <span class="token operator">=</span> base_address <span class="token operator">+</span> <span class="token punctuation">(</span>k<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>type_size<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。另外，C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。</p><p>当然，并不是所有语言的数组都是从 0 开始计数的，比如 Matlab。</p><h1 id="二维数组的内存寻址公式"><a href="#二维数组的内存寻址公式" class="headerlink" title="二维数组的内存寻址公式"></a>二维数组的内存寻址公式</h1><p>对于 m * n 的数组，<code>a[i][j] (i&lt;m,j&lt;n)​</code>的地址为：</p><pre><code>address = base_address + (i*n+j)*type_size</code></pre><h1 id="JVM垃圾回收与算法"><a href="#JVM垃圾回收与算法" class="headerlink" title="JVM垃圾回收与算法"></a>JVM垃圾回收与算法</h1><p>一个对象如果没有任何与之关联的引用，即他们的引用计数为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。<br>为了解决引用计数法的循环引用问题，Java 使用了可达性分析，通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><h2 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark-Sweep)"></a>标记清除算法(Mark-Sweep)</h2><p>分为 标注 和 清除 两个阶段。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p><p><img src="imgs/jvm1.jpg" alt=""></p><p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><h2 id="复制算法-copying"><a href="#复制算法-copying" class="headerlink" title="复制算法(copying)"></a>复制算法(copying)</h2><p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法,按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p><p><img src="imgs/jvm2.jpg" alt=""></p><h2 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h2><p>结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清<br>理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</p><p><img src="imgs/jvm3.jpg" alt=""></p><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。</p><p>老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><h3 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h3><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代<br>划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><p><img src="imgs/jvm4.jpg" alt=""></p><h3 id="老年代与标记复制算法"><a href="#老年代与标记复制算法" class="headerlink" title="老年代与标记复制算法"></a>老年代与标记复制算法</h3><p>而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><ol><li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，<br>常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目<br>前存放对象的那一块)，少数情况会直接分配到老生代。</li><li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden<br>Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From<br>Space 进行清理。</li><li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li><li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被<br>移到老生代中。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01.入门篇</title>
      <link href="//post/01.%E5%85%A5%E9%97%A8%E7%AF%87.html"/>
      <url>//post/01.%E5%85%A5%E9%97%A8%E7%AF%87.html</url>
      
        <content type="html"><![CDATA[<h1 id="01-入门篇"><a href="#01-入门篇" class="headerlink" title="01.入门篇"></a>01.入门篇</h1><h1 id="数据结构-amp-算法的定义"><a href="#数据结构-amp-算法的定义" class="headerlink" title="数据结构&amp;算法的定义"></a>数据结构&amp;算法的定义</h1><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><p>图书管理员为了方便查找，一般会将书籍分门别类进行“<strong>存储</strong>”。按照一定规律编号，就是书籍这种“数据”的存储结构。</p><p><strong>查找一本书</strong>有很多种办法，你可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</p><p>从狭义上讲，数据结构和算法，是指某些著名的<strong>队列、栈、堆、二分查找、动态规划等</strong>。</p><p>这些都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。</p><h2 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h2><p>数据结构和算法是相辅相成的。</p><p><strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</strong></p><p> 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p><p>比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p><p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p><h2 id="数据结构与算法整体框架"><a href="#数据结构与算法整体框架" class="headerlink" title="数据结构与算法整体框架"></a>数据结构与算法整体框架</h2><p><img src="imgs%5C1.jpg" alt=""></p><p><strong>20 个最常用的、最基础</strong>数据结构与算法：</p><p>10 个数据结构：<strong>数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树</strong>；</p><p>10 个算法：<strong>递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</strong>。</p><p>掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。</p><p>在学习数据结构和算法的过程中，应当学习它的：</p><p><strong>“来历”</strong></p><p><strong>“自身的特点”</strong></p><p><strong>“适合解决的问题”</strong></p><p><strong>以及“实际的应用场景”</strong>。</p><h1 id="时间、空间复杂度分析"><a href="#时间、空间复杂度分析" class="headerlink" title="时间、空间复杂度分析"></a>时间、空间复杂度分析</h1><p><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong>。</p><h2 id="事后统计法的局限性"><a href="#事后统计法的局限性" class="headerlink" title="事后统计法的局限性"></a>事后统计法的局限性</h2><h3 id="1-测试结果非常依赖测试环境"><a href="#1-测试结果非常依赖测试环境" class="headerlink" title="1. 测试结果非常依赖测试环境"></a>1. 测试结果非常依赖测试环境</h3><p>测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。</p><h3 id="2-测试结果受数据规模的影响很大"><a href="#2-测试结果受数据规模的影响很大" class="headerlink" title="2. 测试结果受数据规模的影响很大"></a>2. 测试结果受数据规模的影响很大</h3><p>对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！</p><p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。这就是时间、空间复杂度分析方法。</p><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。</p><p>但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？</p><p>这里有段非常简单的代码，求 1,2,3…n 的累加和。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据</strong>-<strong>运算</strong>-<strong>写数据</strong>。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。</p><p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 $2n<em> unit_time$ 的执行时间，所以这段代码总的执行时间就是 $(2n+2)</em>unit_time$。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>按照这个分析思路，我们再来看这段代码。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>       sum <span class="token operator">=</span> sum <span class="token operator">+</span>  i <span class="token operator">*</span> j<span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？</p><p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要$2n<em>unit_time$ 的执行时间，第 7、8 行代码循环执行了 $n^2$遍，所以需要 $2n^{2} </em> unit_time$ 的执行时间。所以，整段代码总的执行时间$T(n) = (2n^2+2n+3)*unit_time$ .</p><p>需要 $2n <em> unit_time$ 的执行时间，第 7、8 行代码循环执行了 $n^{2}$遍，所以需要 $2n^{2} </em> unit_time$ 的执行时间。所以，整段代码总的执行时间 $T(n) = (2n^2+2n+3)*unit_time$。</p><p>尽管不知道 unit_time 的具体值，但<strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong>。</p><p>把这个规律总结成一个公式:</p><p>$$<br>T(n)=O(f(n))<br>$$<br>T(n) 表示代码执行的时间；n 表示数据规模的大小；</p><p>f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。</p><p>公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>所以，第一个例子中的 $T(n) = O(2n+2)$，第二个例子中的 $T(n) = O(2n^2+2n+3)$。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p><p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：$T(n) = O(n)； T(n) = O(n^2)$。</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，<strong>表示算法的执行时间与数据规模之间的增长关系</strong>。</p><h3 id="三个比较实用的分析方法"><a href="#三个比较实用的分析方法" class="headerlink" title="三个比较实用的分析方法"></a>三个比较实用的分析方法</h3><h4 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1. 只关注循环执行次数最多的一段代码"></a>1. 只关注循环执行次数最多的一段代码</h4><p>大 O 这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p><p>以前面的例子举例：</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p><h4 id="2-加法法则"><a href="#2-加法法则" class="headerlink" title="2. 加法法则"></a>2. 加法法则</h4><p><strong>总复杂度等于量级最大的那段代码的复杂度</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> sum_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>     sum_1 <span class="token operator">=</span> sum_1 <span class="token operator">+</span> p<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">int</span> sum_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> q <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>q<span class="token punctuation">)</span> <span class="token punctuation">{</span>     sum_2 <span class="token operator">=</span> sum_2 <span class="token operator">+</span> q<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">int</span> sum_3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>       sum_3 <span class="token operator">=</span> sum_3 <span class="token operator">+</span>  i <span class="token operator">*</span> j<span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum_1 <span class="token operator">+</span> sum_2 <span class="token operator">+</span> sum_3<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p><p>第一段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。</p><p>当 n 无限大的时候，尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大都可以忽略掉。因为它本身对增长趋势并没有影响。</p><p>第二段代码和第三段代码的时间复杂度分别是$O(n)$ 和 $O(n^2)$。</p><p>综合这三段代码的时间复杂度，取其中最大的量级。所以，整段代码的时间复杂度就为$O(n^2)$。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p><p>如果 $T1(n)=O(f(n))，T2(n)=O(g(n))$；那么 $T(n)=T1(n)+T2(n)=max(O(f(n))$, $O(g(n))) =O(max(f(n), g(n)))$.</p><h4 id="3-乘法法则"><a href="#3-乘法法则" class="headerlink" title="3.乘法法则"></a>3.乘法法则</h4><p><strong>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p><p>如果 $T1(n)=O(f(n))$，$T2(n)=O(g(n))$；那么 $T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))$.</p><p>也就是说，假设 T1(n) = O(n)，$T2(n) = O(n^2)$，则 $T1(n) <em> T2(n) = O(n^3)$。落实到具体的代码上，我们可以把乘法法则看成是<em>*嵌套循环</em></em>，举个例子:</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     ret <span class="token operator">=</span> ret <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum <span class="token operator">=</span> sum <span class="token operator">+</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，$T_1(n) = O(n)$。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 $T_2(n) = O(n)$，所以，整个 cal() 函数的时间复杂度就是，$T(n) = T_1(n) <em> T_2(n) = O(n</em>n) = O(n^2)$。</p><h3 id="多项式时间复杂度分析"><a href="#多项式时间复杂度分析" class="headerlink" title="多项式时间复杂度分析"></a>多项式时间复杂度分析</h3><p>常见的复杂度量级（按数量级递增）:</p><ul><li><p><strong>多项式量级：</strong></p><ul><li>常量阶：$O(1)$</li><li>对数阶：$O(log\ n)$</li><li>线性阶：$O(n)$</li><li>线性对数阶：$nO(log\ n)$</li><li>平方阶：$O(n^2)$、 立方阶：$O(n^3)$、……、 K次方阶：$O(n^k)$</li></ul></li><li><p><strong>非多项式量级：</strong></p><ul><li>指数阶：$O(2^n)$ </li><li>阶乘阶： $O(n!)$</li></ul></li></ul><p>可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：$O(2^n)$ 和 $O(n!)$。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p><p>我们主要来看几种常见的<strong>多项式时间复杂度</strong>。</p><h4 id="1-O-1"><a href="#1-O-1" class="headerlink" title="$1. O(1)$"></a>$1. O(1)$</h4><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1)，而不是 O(3)。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token keyword">int</span> sum <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p><h4 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="$2. O(logn)、O(nlogn)$"></a>$2. O(logn)、O(nlogn)$</h4><p>例子：</p><pre class="line-numbers language-c"><code class="language-c"> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>   i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第三行代码是循环执行次数最多的，只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>实际上，变量 i 的取值就是一个等比数列。如果把它列出来：<br>$$<br>2^{0} \quad 2^{1} \quad 2^{2} \cdots 2^{k} \cdots 2^{x}=n<br>$$<br>通过 $2^x=n$ 得 $x=log_2n$，所以，这段代码的时间复杂度就是 $O(log_2n)$。</p><p>例子：</p><pre class="line-numbers language-c"><code class="language-c"> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span>  <span class="token punctuation">{</span>   i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码的时间复杂度为 $O(log_3n)$。</p><p>实际上，可以把所有对数阶的时间复杂度都记为 $O(log\ n)$。</p><p>$log_3n= log_3 2 <em> log_2 n$，所以 $O(log_3 n) = O(C </em> log_2 n)$，其中 $C=log_32$ 是一个常量。</p><p>因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 $O(logn)$。</p><p>如果一段代码的时间复杂度是 $O(logn)$，循环执行 n 遍，时间复杂度就是  $O(logn)$了。</p><p>归并排序、快速排序的时间复杂度都是  $O(nlogn)$。</p><h4 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="$3. O(m+n)、O(m*n)$"></a>$3. O(m+n)、O(m*n)$</h4><p>这种时间复杂度，代码的复杂度<strong>由两个数据的规模</strong>来决定。</p><p>先看代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> sum_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum_1 <span class="token operator">=</span> sum_1 <span class="token operator">+</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> sum_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sum_2 <span class="token operator">=</span> sum_2 <span class="token operator">+</span> j<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> sum_1 <span class="token operator">+</span> sum_2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>m 和 n 是表示两个数据规模，无法事先评估 m 和 n 谁的量级大，无法忽略其中一个，所以上面代码的时间复杂度就是 O(m+n)。</p><p>针对这种情况，加法规则为：$T_1(m) + T_2(n) = O(f(m) + g(n))$。</p><p>但是乘法法则继续有效：$T_1(m)<em>T_2(n) = O(f(m) </em> f(n))$。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的额外存储空间与数据规模之间的增长关系</strong>。</p><p>举个弱智的例子：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    print out a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以可以忽略。</p><p>第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>我们常见的空间复杂度就是 $O(1)、O(n)、O(n^2)$，像 $O(logn)、O(nlogn)$ 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。</p><h2 id="渐进复杂度小结"><a href="#渐进复杂度小结" class="headerlink" title="渐进复杂度小结"></a>渐进复杂度小结</h2><p>渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：</p><p>$O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)$。</p><p><img src="imgs/1570684986266.png" alt="1570684986266"></p><p>渐进时间，渐进空间复杂度分析与是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何。</p><p>算法1的时间复杂度是$O(n)$，算法2的时间复杂度是$O(logn)$，能立刻就对不同的算法有一个“效率”上的感性认识。</p><p>渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在同一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。</p><p>综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。  </p><h1 id="四种情况下时间复杂度分析"><a href="#四种情况下时间复杂度分析" class="headerlink" title="四种情况下时间复杂度分析"></a>四种情况下时间复杂度分析</h1><p><strong>最好情况时间复杂度</strong>（best case time complexity）</p><p><strong>最坏情况时间复杂度</strong>（worst case time complexity）</p><p><strong>平均情况时间复杂度</strong>（average case time complexity）</p><p><strong>均摊时间复杂度</strong>（amortized time complexity）</p><p>在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p><p>在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// n 表示数组 array 的长度</span><span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>       pos <span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> pos<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要查找的变量 x 可能出现在数组的任意位置。</p><p>如果数组中第一个元素正好是要查找的变量 x，那时间复杂度就是 O(1)。</p><p>但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。</p><p>所以，不同的情况下，这段代码的时间复杂度是不一样的。</p><h1 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h1><p>为了表示代码在不同情况下的不同时间复杂度，引入最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p><strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。</p><p><strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><p>平均情况时间复杂度，可简称为平均时间复杂度。</p><p>分析示例：</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中</strong>和<strong>不在数组中</strong>。把每种情况下，查找需要遍历的元素个数累加起来，忽略概率只要再除以 n+1情况数，就可以得到需要遍历的元素个数的平均值，即：<br>$$<br>\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}<br>$$<br>省略掉系数、低阶、常量，得到的平均时间复杂度就是 O(n)。</p><p>要查找的变量 x，要么在数组里，要么就不在数组里，假设在数组中与不在数组中的概率都为 $\frac{1}{2}$，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为$\frac{1}{n}$。要查找的数据出现在 0～n-1 中任意位置的概率就是 $\frac{1}{2n}$。</p><p>如果把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程：<br>$$<br>\begin{aligned} &amp; 1 \times \frac{1}{2 n}+2 \times \frac{1}{2 n}+3 \times \frac{1}{2 n}+\dots+n \times \frac{1}{2 n}+n \times \frac{1}{2} \\=&amp; \frac{3 n+1}{4} \end{aligned}<br>$$<br>平均时间复杂度的可以叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><p>引入概率之后，前面那段代码的加权平均值为$\frac{3n+1}{4}$ 。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用最好最差平均三种复杂度表示法来区分。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><p>均摊时间复杂度 ，对应的分析方法，摊还分析（或者叫平摊分析）。</p><p>先举一个针对性的例子（实际没有人会这么写）：</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">// array 表示一个长度为 n 的数组</span> <span class="token comment" spellcheck="true">// 代码中的 array.length 就等于 n</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          sum <span class="token operator">=</span> sum <span class="token operator">+</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>       count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token operator">++</span>count<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当数组满了之后时，遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>数组中有空闲空间的情况下，只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。</p><p>数组中没有空闲空间的情况下，需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是 O(1)。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。“额外”的情况是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率都是 $\frac{1}{n+1}$ 。所以，求得的平均时间复杂度就是：<br>$$<br>1 \times \frac{1}{n+1}+1 \times \frac{1}{n+1}+\dots+1 \times \frac{1}{n+1}+n \times \frac{1}{n+1}=O(1)<br>$$</p><p>对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。</p><p>这就是<strong>摊还分析法</strong>，得到的时间复杂度就叫<strong>均摊时间复杂度</strong>。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p><h1 id="时间复杂度分析示例"><a href="#时间复杂度分析示例" class="headerlink" title="时间复杂度分析示例"></a>时间复杂度分析示例</h1><p>分析一下下面这个 add() 函数的时间复杂度。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 往数组中添加一个元素</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 数组空间不够了</span>     <span class="token comment" spellcheck="true">// 重新申请一个 2 倍大小的数组空间</span>     <span class="token keyword">int</span> new_array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 把原来 array 数组中的数据依次 copy 到 new_array</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>       new_array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span>     array <span class="token operator">=</span> new_array<span class="token punctuation">;</span>     len <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> len<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 将 element 放到下标为 i 的位置，下标 i 加一</span>   array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>   <span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最好时间复杂度是O(1)，最差时间复杂度是O(n)，平均时间复杂度是O(1)，均摊时间复杂度是O(1)</p><p>分析：</p><p>数组中有空闲空间的情况下，只需要将数据插入到数组下标为 i 的位置就可以了，所以<strong>最好情况时间复杂度为</strong>$O(1)$。</p><p>数组中没有空闲空间的情况下，需要先重新申请一个 2 倍大小的数组空间，然后把原来 array 数组中的数据依次 copy 到 new_array，所以<strong>最坏情况时间复杂度为</strong> $O(n)$</p><p>假设数组初始长度为len，当$i=len,2<em>len,4</em>len,\cdots,2^k<em>len,2^{k+1}</em>len$时，都会进行一次两倍扩容操作，第$2^{k+1}$插入copy次数为$2^k<em>len$，当数组$i\neq len,2</em>len,4<em>len,\cdots,2^k</em>len,2^{k+1}<em>len$时，直接插入时间复杂度为 O(1)，假设所有插入情况的概率相等均为p，则：<br>$$<br>(len-1)</em>p+p+(2len-len)<em>p+len</em>p+\cdots+(2^{k+1}-2^k)len<em>p+2^k</em>len<em>p \<br>=len</em>p+2len<em>p+\cdots+2^klen</em>p+2^{k+1}len<em>p \<br>=[1+2+\cdots+2^k+2^{k+1}]len</em>p \<br>=\frac{1-2^{k+1}}{1-2}<em>len</em>p \<br>=(2^{k+1}-1)<em>len</em>p<br>$$<br>$(2^{k+1}-1)<em>len</em>p$ 中各变量均与数据量大小无关，所以平均时间复杂度为$O(1)$</p><p>每$2^{k+1}-2^k$次O(1)插入操作时，都伴随一次$O(n)$算法复杂度的操作，把这一次的操耗时多的操作作均摊到$ 2^{k+1}-2^k$次耗时少的操作上，均摊下来这一组连续的操作的均摊时间复杂度就是 $O(1)$。</p><p><strong>故均摊时间复杂度是</strong>$O(1)$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十、计算机网络</title>
      <link href="//post/%E5%8D%81%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
      <url>//post/%E5%8D%81%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-5-1-节-计算机网络"><a href="#第-5-1-节-计算机网络" class="headerlink" title="第 5.1 节 计算机网络"></a>第 5.1 节 计算机网络</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p><p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p><h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p><p>对等（P2P）：不区分客户和服务器。</p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><p>1.电路交换<br>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该   链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。<br>2.分组交换<br>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影   响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。<br>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，   这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><h3 id="1-排队时延"><a href="#1-排队时延" class="headerlink" title="1.排队时延"></a>1.排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p><h3 id="2-处理时延"><a href="#2-处理时延" class="headerlink" title="2.处理时延"></a>2.处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路   由等。</p><h3 id="3-传输时延"><a href="#3-传输时延" class="headerlink" title="3.传输时延"></a>3.传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p><p>其中 l 表示数据帧的长度，v 表示传输速率。</p><h3 id="4-传播时延"><a href="#4-传播时延" class="headerlink" title="4.传播时延"></a>4.传播时延</h3><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p><p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1.五层协议"></a>1.五层协议</h2><p>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。<br>传输层   ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议  TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。<br>网络层  ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。<br>数据链路层  ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<br>物理层  ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p><h2 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2.OSI"></a>2.OSI</h2><p>其中表示层和会话层用途如下：<br>表示层  ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。会话层 ：建立及管理会话。<br>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h2 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3.TCP/IP"></a>3.TCP/IP</h2><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><h2 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4.数据在各层之间的传递过程"></a>4.数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。<br>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输   层和应用层。<br>微信公众号<br>更多精彩内容将发布在微信公众号 Python看世界  上，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 “大纲”即可领取。可以根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些 复习时间。</p><p>物理层<br>通信方式<br>根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输<br>半双工通信：双向交替传输<br>全双工通信：双向同时传输</p><p>带通调制<br>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p><p>微信公众号<br>更多精彩内容将发布在微信公众号 Python看世界  上，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 “大纲”即可领取。可以根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些 复习时间。</p><p>链路层<br>基本问题<br>1.封装成帧</p><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p>2.透明传输<br>透明表示一个实际存在的事物看起来好像不存在一样。<br>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的   判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符   前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉   不到转义字符的存在。</p><p>3.差错检测<br>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。<br>信道分类<br>1.广播信道<br>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。<br>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰  撞）。<br>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。<br>2.点对点信道一对一通信。<br>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。<br>信道复用技术<br>1.频分复用<br>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><p>2.时分复用<br>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性   质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。<br>3.统计时分复用<br>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后   发送。</p><p>4.波分复用<br>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。<br>5.码分复用<br>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片   和  有</p><p>为了讨论方便，取 m=8，设码片<br>为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p><p>其中   为  的反码。<br>利用上面的式子我们知道，当接收端使用码片<br>对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1<br>的是用户发送的比特 0。<br>码分复用需要发送的数据量为原先的 m 倍。</p><h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。<br>多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。<br>载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。<br>碰撞检测  ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。<br>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。<br>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p><p>PPP 协议<br>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p><p>PPP 的帧格式：<br>F 字段为帧的定界符<br>A 和 C 字段暂时没有意义<br>FCS 字段是使用 CRC 的检验序列信息部分的长度不超过 1500</p><h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。<br>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。<br>局域网<br>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。  主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。<br>可以按照网络拓扑结构对局域网进行分类：</p><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>以太网是一种星型拓扑结构局域网。<br>早期使用集线器进行连接，集线器是一种物理层设备，    作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线   器同时收到两个不同接口的帧，那么就发生了碰撞。<br>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。<br>以太网帧格式：<br>类型 ：标记上层使用的协议；<br>数据 ：长度在 46-1500 之间，如果太小则需要填充；<br>FCS ：帧检验序列，使用的是 CRC 检验方法；</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。<br>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。<br>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧， 主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。     例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。<br>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>概述<br>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大   努力交互的数据报服务。<br>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：<br>地址解析协议 ARP（Address Resolution Protocol）<br>网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol）<br>IP 数据报格式</p><p>版本 : 有 4（IPv4）和 6（IPv6）两个值；<br>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长<br>度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。区分服务 : 用来获得更好的服务，一般情况下不使用。<br>总长度 : 包括首部长度和数据部分长度。<br>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL<br>为 0 时就丢弃数据报。<br>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。<br>首部检验和  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。<br>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p><p>IP 地址编址方式<br>IP 地址的编址方式经历了三个历史阶段： 分类<br>子网划分<br>无分类<br>1.分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p>2.子网划分<br>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。<br>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}<br>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特， 那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。<br>注意，外部网络看不到子网的存在。<br>3.无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。<br>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}<br>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。<br>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由   聚合，也称为 构成超网 。<br>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹   配来确定应该匹配哪一个。<br>地址解析协议 ARP<br>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP   数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p>ARP 实现由 IP 地址得到 MAC 地址。</p><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。<br>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><h1 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h1><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p><p>ICMP 报文分为差错报告报文和询问报文。</p><p>1.Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。<br>2.Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。<br>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；<br>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。<br>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。<br>虚拟专用网 VPN<br>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。<br>有三个专用地址块：<br>10.0.0.0 ~ 10.255.255.255<br>172.16.0.0 ~ 172.31.255.255<br>192.168.0.0 ~ 192.168.255.255<br>VPN  使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信； 虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。<br>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。<br>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p>路由器分组转发流程<br>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；<br>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；<br>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。</p><p>路由选择协议<br>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类：<br>自治系统内部的路由选择：RIP 和 OSPF<br>自治系统间的路由选择：BGP<br>1.内部网关协议 RIP<br>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。<br>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。<br>距离向量算法：<br>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；<br>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<br>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；<br>否则：若下一跳路由器地址是  X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离  d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。<br>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。<br>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。<br>2.内部网关协议 OSPF<br>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。<br>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法<br>SPF。<br>OSPF 具有以下特点：<br>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。<br>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距  离、时延、带宽等来表示。<br>只有当链路状态发生变化时，路由器才会发送信息。<br>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。<br>3.外部网关协议 BGP<br>BGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于：<br>互联网规模很大；<br>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；<br>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。<br>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p>传输层<br>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，   传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑   通信信道。<br>UDP 和 TCP 的特点<br>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文<br>（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p>传输控制协议 TCP（Transmission Control  Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据     块），每一条 TCP 连接只能是点对点的（一对一）。<br>UDP 首部格式</p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。<br>TCP 首部格式</p><p>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100<br>字节，那么下一个报文段的序号应为 401。<br>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。<br>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。<br>确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把<br>ACK 置 1。<br>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。<br>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。窗口  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<br>TCP 的三次握手</p><p>假设 A 为客户端，B 为服务器端。<br>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。<br>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。<br>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。<br>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。B 收到 A 的确认后，连接建立。<br>三次握手的原因<br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。<br>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待   一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握     手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确     认，不进行第三次握手，因此就不会再次打开连接。<br>TCP 的四次挥手</p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。<br>A 发送连接释放报文，FIN=1。<br>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。当 B 不再需要连接时，发送连接释放报文，FIN=1。<br>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。B 收到 A 的确认后释放连接。<br>四次挥手的原因<br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。<br>TIME_WAIT<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：<br>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，<br>A 等待一段时间就是为了处理这种情况的发生。<br>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧  的连接请求报文。<br>TCP 可靠传输<br>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。<br>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p>其中 RTTd 为偏差的加权平均值。<br>TCP 滑动窗口<br>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确   认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类     似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31}<br>按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p>TCP 流量控制<br>流量控制是为了控制发送方发送速率，保证接收方来得及接收。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为<br>0，则发送方不能发送数据。<br>TCP 拥塞控制<br>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当   控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制   是为了降低整个网络的拥塞程度。</p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。<br>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状  态变量，实际决定发送方能发送多少数据的是发送方窗口。<br>为了便于讨论，做如下假设：<br>接收方有足够大的接收缓存，因此不会发生流量控制；<br>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</p><p>1.慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …<br>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。<br>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><p>2.快重传与快恢复<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1  和  M2，此时收到 M4，应当发送对 M2 的确认。<br>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例   如收到三个 M2，则 M3 丢失，立即重传 M3。<br>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。<br>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd<br>设定为 ssthresh。</p><p>微信公众号<br>更多精彩内容将发布在微信公众号 Python看世界  上，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 “大纲”即可领取。可以根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些 复习时间。</p><p>应用层<br>域名系统<br>DNS 是一个分布式数据库，提供了主机名和 IP  地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。<br>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：<br>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。<br>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。<br>文件传送协议<br>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：<br>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。<br>数据连接：用来传送一个文件数据。<br>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：<br>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于1024，因为 0~1023 是熟知端口号。</p><p>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即   可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。<br>动态主机配置协议<br>DHCP (Dynamic Host Conﬁguration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。<br>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。<br>DHCP 工作过程如下：<br>1.客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP<br>中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<br>2.DHCP 服务器收到 Discover 报文之后，发送 Oﬀer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<br>3.如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<br>4.DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</p><p>远程登录协议<br>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。<br>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。<br>电子邮件协议<br>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p><p>1.SMTP<br>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><p>2.POP3<br>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。<br>3.IMAP<br>IMAP  协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。<br>常用端口</p><p>应用    应用层协议    端口号    传输层协议    备注<br>域名解析    DNS    53    UDP/TCP    长度超过 512 字节时使用 TCP<br>动态主机配置协议    DHCP    67/68    UDP<br>简单网络管理协议    SNMP    161/162    UDP<br>文件传送协议    FTP    20/21    TCP    控制连接 21，数据连接 20<br>远程终端协议    TELNET    23    TCP<br>超文本传送协议    HTTP    80    TCP<br>简单邮件传送协议    SMTP    25    TCP<br>邮件读取协议    POP3    110    TCP<br>网际报文存取协议    IMAP    143    TCP<br>Web 页面请求过程<br>1.DHCP 配置主机信息<br>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。<br>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报<br>文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP<br>地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。<br>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。<br>2.ARP 解析 MAC 地址<br>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。<br>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。<br>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。<br>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。<br>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备， 包括网关路由器。<br>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。<br>3.DNS 解析域名<br>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。<br>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。<br>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。<br>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。<br>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。<br>4.HTTP 请求页面<br>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。<br>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。<br>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。<br>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。<br>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。<br>微信公众号</p><p>更多精彩内容将发布在微信公众号 Python看世界  上，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 “大纲”即可领取。可以根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些 复习时间。</p><p>参考链接<br>计算机网络, 谢希仁<br>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014. W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.<br>Active vs Passive FTP Mode: Which One is More Secure? Active and Passive FTP Transfers Deﬁned - KB Article #1138 Traceroute<br>ping<br>How DHCP works and DHCP Interview Questions and Answers What is process of DORA in DHCP?<br>What is DHCP Server ?<br>Tackling emissions targets in Tokyo What does my ISP know when I use Tor?<br>Technology-Computer Networking[1]-Computer Networks and the Internet P2P 网络概述.<br>Circuit Switching (a) Circuit switching. (b) Packet switching.<br>第 5.2 节 HTTP</p><p>一 、基础概念<br>URI<br>URI 包含 URL 和 URN。</p><p>请求和响应报文<br>1.请求报文</p><p>2.响应报文</p><p>二、HTTP 方法</p><p>客户端发送的 请求报文 第一行为请求行，包含了方法字段。<br>GET<br>获取资源<br>当前网络请求中，绝大部分使用的是 GET 方法。<br>HEAD<br>获取报文首部<br>和 GET 方法类似，但是不返回报文实体主体部分。<br>主要用于确认 URL 的有效性以及资源更新的日期时间等。<br>POST<br>传输实体主体<br>POST 主要用来传输数据，而 GET 主要用来获取资源。更多 POST 与 GET 的比较请见第九章。<br>PUT<br>上传文件<br>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><p>PATCH<br>对资源进行部分修改<br>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><p>DELETE<br>删除文件<br>与 PUT 功能相反，并且同样不带验证机制。</p><p>OPTIONS<br>查询支持的方法<br>查询指定的 URL 能够支持的方法。会返回<br>CONNECT<br>要求在与代理服务器通信时建立隧道</p><p>这样的内容。</p><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><p>TRACE<br>追踪路径<br>服务器会将通信路径返回给客户端。<br>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。<br>三、HTTP 状态码<br>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><p>状态码    类别    含义<br>1XX    Informational（信息性状态码）    接收的请求正在处理<br>2XX    Success（成功状态码）    请求正常处理完毕<br>3XX    Redirection（重定向状态码）    需要进行附加操作以完成请求<br>4XX    Client Error（客户端错误状态码）    服务器无法处理请求<br>5XX    Server Error（服务器错误状态码）    服务器处理请求出错</p><p>1XX 信息<br>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。<br>2XX 成功<br>200 OK<br>204 No Content  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。<br>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。<br>3XX 重定向<br>301Moved Permanently ：永久性重定向<br>302Found ：临时性重定向<br>303See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。<br>304Not Modiﬁed ：如果请求报文首部包含一些条件，例如：If-Match，If-Modiﬁed-Since，If-None- Match，If-Range，If-Unmodiﬁed-Since，如果不满足条件，则服务器会返回 304 状态码。<br>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的<br>POST 方法改成 GET 方法。<br>4XX 客户端错误<br>400Bad Request ：请求报文中存在语法错误。<br>401Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST  认证）。如果之前已进行过一次请求，则表示用户认证失败。<br>403 Forbidden ：请求被拒绝。<br>404 Not Found<br>5XX 服务器错误<br>500 Internal Server Error ：服务器正在执行请求时发生错误。<br>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。<br>四、HTTP 首部<br>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。各种首部字段及其含义如下（不需要全记，仅供查阅）：<br>通用首部字段</p><p>首部字段名    说明<br>Cache-Control    控制缓存的行为<br>Connection    控制不再转发给代理的首部字段、管理持久连接<br>Date    创建报文的日期时间<br>Pragma    报文指令<br>Trailer    报文末端的首部一览<br>Transfer-Encoding    指定报文主体的传输编码方式<br>Upgrade    升级为其他协议<br>Via    代理服务器的相关信息<br>Warning    错误通知</p><p>请求首部字段</p><p>首部字段名    说明<br>Accept    用户代理可处理的媒体类型<br>Accept-Charset    优先的字符集<br>Accept-Encoding    优先的内容编码<br>Accept-Language    优先的语言（自然语言）<br>Authorization    Web 认证信息<br>Expect    期待服务器的特定行为<br>From    用户的电子邮箱地址<br>Host    请求资源所在服务器<br>If-Match    比较实体标记（ETag）<br>If-Modiﬁed-Since    比较资源的更新时间<br>If-None-Match    比较实体标记（与 If-Match 相反）<br>If-Range    资源未更新时发送实体 Byte 的范围请求<br>If-Unmodiﬁed-Since    比较资源的更新时间（与 If-Modiﬁed-Since 相反）<br>Max-Forwards    最大传输逐跳数<br>Proxy-Authorization    代理服务器要求客户端的认证信息<br>Range    实体的字节范围请求<br>Referer    对请求中 URI 的原始获取方<br>TE    传输编码的优先级<br>User-Agent    HTTP 客户端程序的信息</p><p>响应首部字段</p><p>首部字段名    说明<br>Accept-Ranges    是否接受字节范围请求<br>Age    推算资源创建经过时间<br>ETag    资源的匹配信息<br>Location    令客户端重定向至指定 URI<br>Proxy-Authenticate    代理服务器对客户端的认证信息<br>Retry-After    对再次发起请求的时机要求<br>Server    HTTP 服务器的安装信息<br>Vary    代理服务器缓存的管理信息<br>WWW-Authenticate    服务器对客户端的认证信息</p><p>实体首部字段</p><p>首部字段名    说明<br>Allow    资源可支持的 HTTP 方法<br>Content-Encoding    实体主体适用的编码方式<br>Content-Language    实体主体的自然语言<br>Content-Length    实体主体的大小<br>Content-Location    替代对应资源的 URI<br>Content-MD5    实体主体的报文摘要<br>Content-Range    实体主体的位置范围<br>Content-Type    实体主体的媒体类型<br>Expires    实体主体过期的日期时间<br>Last-Modiﬁed    资源的最后修改日期时间<br>五、具体应用<br>连接管理</p><p>1.短连接与长连接<br>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。<br>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。<br>从  HTTP/1.1  开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用<br>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive 。<br>2.流水线<br>默认情况下，HTTP   请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。<br>Cookie<br>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。<br>Cookie   是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie  数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie   曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API  已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。<br>1.用途<br>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等）<br>浏览器行为跟踪（如跟踪分析用户行为等）<br>2.创建过程<br>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过  Cookie 请求首部字段发送给服务器。</p><p>3.分类<br>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。<br>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</p><p>4.作用域<br>Domain  标识指定了哪些主机可以接受  Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如developer.mozilla.org）。<br>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：<br>/docs<br>/docs/Web/<br>/docs/Web/HTTP</p><p>5.JavaScript</p><p>浏览器通过    属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><p>6.HttpOnly<br>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的<br>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><p>7.Secure<br>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。<br>8.Session<br>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>使用 Session 维护用户登录状态的过程如下：<br>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；<br>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。<br>9.浏览器禁用 Cookie<br>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。<br>10.Cookie 与 Session 选择<br>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选<br>Session；<br>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<br>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。<br>缓存<br>1.优点</p><p>缓解服务器压力；<br>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有  可能比源服务器来得近，例如浏览器缓存。<br>2.实现方法<br>让代理服务器进行缓存； 让客户端浏览器进行缓存。<br>3.Cache-Control<br>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。<br>3.1禁止进行缓存<br>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><p>3.2强制确认缓存<br>no-cache   指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><p>3.3私有缓存和公共缓存<br>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><p>3.4缓存过期机制<br>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。<br>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><p>在 HTTP/1.1 中，会优先处理 max-age 指令； 在 HTTP/1.0 中，max-age 指令会被忽略掉。<br>4.缓存验证</p><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如<br>有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新<br>ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modiﬁed。</p><p>Last-Modiﬁed    首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上  If-Modiﬁed-Since  来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modiﬁed 响应报文。</p><p>内容协商<br>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。<br>1.类型<br>1.1服务端驱动型<br>客户端设置特定的 HTTP 首部字段，例如  Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。<br>它存在以下问题：<br>服务器很难知道客户端浏览器的全部信息；<br>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；<br>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。<br>1.2代理驱动型<br>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。<br>2.Vary</p><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器   请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含<br>内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且<br>Accept-Language 与缓存中的对应的值相同时才会返回该缓存。<br>内容编码<br>内容编码将实体主体进行压缩，从而减少传输的数据量。常用的内容编码有：gzip、compress、deﬂate、identity。<br>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一<br>种，使用该算法对响应的消息主体进行压缩，并且发送  Content-Encoding  首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-<br>Encoding。<br>范围请求<br>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而   避免服务器重新发送所有数据。<br>1.Range<br>在请求报文中添加 Range 首部字段指定请求的范围。</p><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><p>2.Accept-Ranges<br>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><p>3.响应状态码<br>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。<br>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisﬁable 状态码。在不支持范围请求的情况下，服务器会返回 200 OK 状态码。<br>分块传输编码<br>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。多部分对象集合</p><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用  boundary  字段定义的分隔符进行分隔，每个部分都可以有首部字段。<br>例如，上传多个表单时可以使用如下方式：</p><p>虚拟主机<br>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。通信数据转发<br>1.代理<br>代理服务器接受客户端的请求，并且转发给其它服务器。使用代理的主要目的是：<br>缓存<br>负载均衡<br>网络访问控制访问日志记录<br>代理服务器分为正向代理和反向代理两种： 用户察觉得到正向代理的存在。</p><p>而反向代理一般位于内部网络中，用户察觉不到。</p><p>2.网关<br>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。<br>3.隧道<br>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。<br>六、HTTPS<br>HTTP 有以下安全性问题：<br>使用明文进行通信，内容可能会被窃听；<br>不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。<br>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说<br>HTTPS 使用了隧道进行通信。<br>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p>加密<br>1.对称密钥加密<br>对称密钥加密（Symmetric-Key   Encryption），加密和解密使用同一密钥。优点：运算速度快；<br>缺点：无法安全地将密钥传输给通信方。</p><p>2.非对称密钥加密<br>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。<br>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通   信内容后使用私有密钥解密。<br>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥   进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。<br>优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。</p><p>3.HTTPS 采用的加密方式<br>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p><p>认证<br>通过使用 证书 来对通信方进行认证。<br>数字证书认证机构（CA，Certiﬁcate Authority）是客户端与服务器双方都可信赖的第三方机构。<br>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。<br>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证， 如果验证通过，就可以开始通信了。</p><p>完整性保护<br>SSL 提供报文摘要功能来进行完整性保护。<br>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。<br>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。<br>HTTPS 的缺点<br>因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。<br>七、HTTP/2.0<br>HTTP/1.x 缺陷<br>HTTP/1.x 实现简单是以牺牲性能为代价的：<br>客户端需要使用多个连接才能实现并发和缩短延迟；<br>不会压缩请求和响应首部，从而导致不必要的网络流量；<br>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。<br>二进制分帧层</p><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。<br>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。  消息（Message）是与逻辑请求或响应对应的完整的一系列帧。<br>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重  新组装。</p><p>服务端推送<br>HTTP/2.0   在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p>首部压缩<br>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。<br>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huﬀman 编码对首部字段进行压缩。</p><p>八、HTTP/1.1 新特性<br>详细内容请见上文<br>默认是长连接支持流水线<br>支持同时打开多个 TCP 连接支持虚拟主机<br>新增状态码 100<br>支持分块传输编码<br>新增缓存处理指令 max-age<br>九、GET 和 POST 比较<br>作用<br>GET 用于获取资源，而 POST 用于传输实体主体。参数<br>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具<br>（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如<br>%E4%B8%AD%E6%96%87 ，而空格会转换为 %20 。POST 参数支持标准字符集。</p><p>会转换为</p><p>安全<br>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。<br>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。<br>安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。幂等性<br>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。<br>所有的安全方法也都是幂等的。<br>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。<br>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><p>DELETE    /idX/delete    HTTP/1.1    -&gt;    Returns    200 if idX exists<br>DELETE    /idX/delete    HTTP/1.1    -&gt;    Returns    404 as it just got deleted<br>DELETE    /idX/delete    HTTP/1.1    -&gt;    Returns    404<br>可缓存<br>如果要对响应进行缓存，需要满足以下条件：</p><p>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。<br>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。响应报文的 Cache-Control 首部字段没有指定不进行缓存。<br>XMLHttpRequest<br>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：<br>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 A JAX 中被大量使用。<br>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。<br>而 GET 方法 Header 和 Data 会一起发送。<br>参考资料<br>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014. MDN : HTTP<br>HTTP/2 简介htmlspecialchars<br>Diﬀerence between ﬁle URI and URL in java<br>How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement<br>浅谈 HTTP 中 Get 与 Post 的区别<br>Are http:// and www really necessary? HTTP (HyperText Transfer Protocol)<br>Web-VPN: Secure Proxies with SPDY &amp; Chrome File:HTTP persistent connection.svg<br>Proxy server<br>What Is This HTTPS/SSL Thing And Why Should You Care? What is SSL Oﬄoading?<br>Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption An Introduction to Mutual SSL Authentication<br>The Diﬀerence Between URLs and URIs Cookie 与 Session 的区别<br>COOKIE 和 SESSION 有什么区别<br>Cookie/Session 的机制与安全HTTPS 证书原理<br>What is the diﬀerence between a URI, a URL and a URN? XMLHttpRequest<br>XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST? Symmetric vs. Asymmetric Encryption – What are diﬀerences?<br>Web 性能优化与 HTTP/2<br>HTTP/2 简介</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三、Java 集合</title>
      <link href="//post/%E4%B8%89%E3%80%81Java%20%E9%9B%86%E5%90%88.html"/>
      <url>//post/%E4%B8%89%E3%80%81Java%20%E9%9B%86%E5%90%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h1 id="3-1-接口"><a href="#3-1-接口" class="headerlink" title="3.1 接口"></a>3.1 接口</h1><h2 id="常见接口"><a href="#常见接口" class="headerlink" title="常见接口"></a>常见接口</h2><ul><li>Map 接口和 Collection 接口是所有集合框架的父接口；</li><li>Collection 接口的子接口包括：Set 接口、List 接口和Queue接口；</li><li>Map 接口的实现类主要有：HashMap、TreeMap、LinkedHashMap、Hashtable、ConcurrentHashMap 以及 Properties 等；</li><li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li><li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 、Vector以及CopyOnWriteArrayList 等；</li><li>Queue接口的主要实现类有：ArrayDeque、ArrayBlockingQueue、LinkedBlockingQueue、PriorityQueue等；</li></ul><h2 id="List接口和Set接口的区别"><a href="#List接口和Set接口的区别" class="headerlink" title="List接口和Set接口的区别"></a>List接口和Set接口的区别</h2><ul><li>List 元素是有序的，可以重复；Set 元素是无序的，不可以重复。<h2 id="队列、Set、Map-区别"><a href="#队列、Set、Map-区别" class="headerlink" title="队列、Set、Map 区别"></a>队列、Set、Map 区别</h2></li><li>List 有序列表</li><li>Set无序集合</li><li>Map键值对的集合</li><li>Queue队列FlFO </li></ul><h1 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h1><ul><li>有顺序，可重复<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2></li><li>基于数组实现，无容量的限制。</li><li>在执行插入元素时可能要扩容，在删除元素时并不会减小数组的容量，在查找元素时要遍历数组，对于非null的元素采取equals的方式寻找。</li><li>是非线程安全的。</li><li>注意点：<ul><li>（1)ArrayList随机元素时间复杂度O(1)，插入删除操作需大量移动元素，效率较低</li><li>（2)为了节约内存，当新建容器为空时，会共享Object[] EMPTY_ELEMENTDATA = {}和 Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}空数组</li><li>（3)容器底层采用数组存储，每次扩容为1.5倍</li><li>（4)ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法，其实Arrays.copyof()内部也是调用System.arraycopy()。System.arraycopy()为Native方法</li><li>（5)两个ToArray方法</li></ul></li><li>Object[] toArray()方法。该方法有可能会抛出java.lang.ClassCastException异常</li><li><T> T[] toArray(T[] a)方法。该方法可以直接将ArrayList转换得到的Array进行整体向下转型<ul><li>（6)ArrayList可以存储null值</li><li>（7)ArrayList每次修改（增加、删除)容器时，都是修改自身的modCount；在生成迭代器时，迭代器会保存该modCount值，迭代器每次获取元素时，会比较自身的modCount与ArrayList的modCount是否相等，来判断容器是否已经被修改，如果被修改了则抛出异常（fast-fail机制)。</li></ul></li></ul><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Default initial capacity. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Shared empty array instance used for empty instances. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */</span><span class="token keyword">transient</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// non-private to simplify nested class access</span><span class="token comment" spellcheck="true">/** * The size of the ArrayList (the number of elements it contains). * * @serial */</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                           initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加-add-e"><a href="#添加-add-e" class="headerlink" title="添加 add(e)"></a>添加 add(e)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>即使初始化时指定大小 小于10个，添加元素时会调整大小，保证capacity不会少于10个。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// overflow-conscious code</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Arrays.copyOf底层是System.arrayCopy</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span>U<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span>U<span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> newType<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    T<span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span>newType <span class="token operator">==</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token operator">?</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span>        <span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>newType<span class="token punctuation">.</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> copy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="添加-add-index-e"><a href="#添加-add-index-e" class="headerlink" title="添加 add(index,e)"></a>添加 add(index,e)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                     size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">></span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除-remove-o"><a href="#删除-remove-o" class="headerlink" title="删除 remove(o)"></a>删除 remove(o)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除-remove-index"><a href="#删除-remove-index" class="headerlink" title="删除 remove(index)"></a>删除 remove(index)</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> size<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>E <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}/** * An optimized version of AbstractList.Itr */private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        return cursor != size;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        checkForComodification();        int i = cursor;        if (i &gt;= size)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i + 1;        return (E) elementData[lastRet = i];    }    public void remove() {        if (lastRet &lt; 0)            throw new IllegalStateException();        checkForComodification();        try {            ArrayList.this.remove(lastRet);            cursor = lastRet;            lastRet = -1;            expectedModCount = modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {        Objects.requireNonNull(consumer);        final int size = ArrayList.this.size;        int i = cursor;        if (i &gt;= size) {            return;        }        final Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length) {            throw new ConcurrentModificationException();        }        while (i != size &amp;&amp; modCount == expectedModCount) {            consumer.accept((E) elementData[i++]);        }        // update once at end of iteration to reduce heap write traffic        cursor = i;        lastRet = i - 1;        checkForComodification();    }    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return indexOf(o) &gt;= 0;}</code></pre><pre><code>public int indexOf(Object o) {    if (o == null) {        for (int i = 0; i &lt; size; i++)            if (elementData[i]==null)                return i;    } else {        for (int i = 0; i &lt; size; i++)            if (o.equals(elementData[i]))                return i;    }    return -1;}</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul><li>基于双向链表机制</li><li>在插入元素时，须创建一个新的Entry对象，并切换相应元素的前后元素的引用；在查找元素时，须遍历链表；在删除元素时，须遍历链表，找到要删除的元素，然后从链表上将此元素删除即可。</li><li>是非线程安全的。</li><li>注意：<ul><li>（1)LinkedList有两个构造参数，一个为无參构造，只是新建一个空对象，第二个为有参构造，新建一个空对象，然后把所有元素添加进去。</li><li>（2)LinkedList的存储单元为一个名为Node的内部类，包含pre指针，next指针，和item元素，实现为双向链表</li><li>（3)LinkedList的删除、添加操作时间复杂度为O(1)，查找时间复杂度为O(n)，查找函数有一定优化，容器会先判断查找的元素是离头部较近，还是尾部较近，来决定从头部开始遍历还是尾部开始遍历</li><li>（4)LinkedList实现了Deque接口，因此也可以作为栈、队列和双端队列来使用。</li><li>（5)LinkedList可以存储null值<h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul></li><li>transient int size = 0;<br>transient Node<E> first;<br>transient Node<E> last;<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3></li></ul><pre><code>public LinkedList() {}</code></pre><h3 id="添加-add-e-1"><a href="#添加-add-e-1" class="headerlink" title="添加 add(e)"></a>添加 add(e)</h3><pre><code>public boolean add(E e) {    linkLast(e);    return true;}</code></pre><ul><li>把一个元素添加到最后一个位置</li><li>void linkLast(E e) {<br>  final Node<E> l = last;<br>  final Node<E> newNode = new Node&lt;&gt;(l, e, null);<br>  last = newNode;<br>  if (l == null)<pre><code>  first = newNode;</code></pre>  else<pre><code>  l.next = newNode;</code></pre>  size++;<br>  modCount++;<br>}</li></ul><h3 id="添加-add-index-e-1"><a href="#添加-add-index-e-1" class="headerlink" title="添加 add(index,e)"></a>添加 add(index,e)</h3><pre><code>public void add(int index, E element) {    checkPositionIndex(index);    if (index == size)        linkLast(element);    else        linkBefore(element, node(index));}</code></pre><pre><code>- Node&lt;E&gt; node(int index) {// assert isElementIndex(index);if (index &lt; (size &gt;&gt; 1)) {    Node&lt;E&gt; x = first;    for (int i = 0; i &lt; index; i++)        x = x.next;    return x;} else {    Node&lt;E&gt; x = last;    for (int i = size - 1; i &gt; index; i--)        x = x.prev;    return x;}</code></pre><p>}</p><ul><li>void linkBefore(E e, Node<E> succ) {<br>  // assert succ != null;<br>  final Node<E> pred = succ.prev;<br>  final Node<E> newNode = new Node&lt;&gt;(pred, e, succ);<br>  succ.prev = newNode;<br>  if (pred == null)<pre><code>  first = newNode;</code></pre>  else<pre><code>  pred.next = newNode;</code></pre>  size++;<br>  modCount++;<br>}</li></ul><h3 id="删除-remove-o-1"><a href="#删除-remove-o-1" class="headerlink" title="删除 remove(o)"></a>删除 remove(o)</h3><pre><code>public boolean remove(Object o) {    if (o == null) {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (x.item == null) {                unlink(x);                return true;            }        }    } else {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (o.equals(x.item)) {                unlink(x);                return true;            }        }    }    return false;}</code></pre><ul><li><p>E unlink(Node<E> x) {<br>  // assert x != null;<br>  final E element = x.item;<br>  final Node<E> next = x.next;<br>  final Node<E> prev = x.prev;</p><p>  if (prev == null) {</p><pre><code>  first = next;</code></pre><p>  } else {</p><pre><code>  prev.next = next;  x.prev = null;</code></pre><p>  }</p><p>  if (next == null) {</p><pre><code>  last = prev;</code></pre><p>  } else {</p><pre><code>  next.prev = prev;  x.next = null;</code></pre><p>  }</p><p>  x.item = null;<br>  size–;<br>  modCount++;<br>  return element;<br>}</p></li></ul><h3 id="删除-remove-index-1"><a href="#删除-remove-index-1" class="headerlink" title="删除 remove(index)"></a>删除 remove(index)</h3><pre><code>public E remove(int index) {    checkElementIndex(index);    return unlink(node(index));}</code></pre><h3 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h3><pre><code>public E get(int index) {    checkElementIndex(index);    return node(index).item;}</code></pre><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><pre><code>public E set(int index, E element) {    checkElementIndex(index);    Node&lt;E&gt; x = node(index);    E oldVal = x.item;    x.item = element;    return oldVal;}</code></pre><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public ListIterator&lt;E&gt; listIterator(int index) {    checkPositionIndex(index);    return new ListItr(index);}</code></pre><pre><code>private class ListItr implements ListIterator&lt;E&gt; {    private Node&lt;E&gt; lastReturned;    private Node&lt;E&gt; next;    private int nextIndex;    private int expectedModCount = modCount;    ListItr(int index) {        // assert isPositionIndex(index);        next = (index == size) ? null : node(index);        nextIndex = index;    }    public boolean hasNext() {        return nextIndex &lt; size;    }    public E next() {        checkForComodification();        if (!hasNext())            throw new NoSuchElementException();        lastReturned = next;        next = next.next;        nextIndex++;        return lastReturned.item;    }    public boolean hasPrevious() {        return nextIndex &gt; 0;    }    public E previous() {        checkForComodification();        if (!hasPrevious())            throw new NoSuchElementException();        lastReturned = next = (next == null) ? last : next.prev;        nextIndex--;        return lastReturned.item;    }    public int nextIndex() {        return nextIndex;    }    public int previousIndex() {        return nextIndex - 1;    }    public void remove() {        checkForComodification();        if (lastReturned == null)            throw new IllegalStateException();        Node&lt;E&gt; lastNext = lastReturned.next;        unlink(lastReturned);        if (next == lastReturned)            next = lastNext;        else            nextIndex--;        lastReturned = null;        expectedModCount++;    }    public void set(E e) {        if (lastReturned == null)            throw new IllegalStateException();        checkForComodification();        lastReturned.item = e;    }    public void add(E e) {        checkForComodification();        lastReturned = null;        if (next == null)            linkLast(e);        else            linkBefore(e, next);        nextIndex++;        expectedModCount++;    }    public void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) {            action.accept(next.item);            lastReturned = next;            next = next.next;            nextIndex++;        }        checkForComodification();    }    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><h3 id="包含-1"><a href="#包含-1" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return indexOf(o) != -1;}</code></pre><pre><code>public int indexOf(Object o) {    int index = 0;    if (o == null) {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (x.item == null)                return index;            index++;        }    } else {        for (Node&lt;E&gt; x = first; x != null; x = x.next) {            if (o.equals(x.item))                return index;            index++;        }    }    return -1;}</code></pre><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul><li>基于synchronized实现的线程安全的ArrayList，但在插入元素时容量扩充的机制和ArrayList稍有不同，并可通过传入capacityIncrement来控制容量的扩充。<h3 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h3></li><li>protected Object[] elementData;<br>protected int elementCount;<br>protected int capacityIncrement;</li></ul><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public Vector(int initialCapacity) {    this(initialCapacity, 0);}</code></pre><pre><code>public Vector() {    this(10);}</code></pre><pre><code>public Vector(int initialCapacity, int capacityIncrement) {    super();    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    this.elementData = new Object[initialCapacity];    this.capacityIncrement = capacityIncrement;}</code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><pre><code>public synchronized boolean add(E e) {    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] = e;    return true;}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>public boolean remove(Object o) {    return removeElement(o);}</code></pre><pre><code>public synchronized boolean removeElement(Object obj) {    modCount++;    int i = indexOf(obj);    if (i &gt;= 0) {        removeElementAt(i);        return true;    }    return false;}</code></pre><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><pre><code>private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                     capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h3 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h3><pre><code>public synchronized E get(int index) {    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    return elementData(index);}</code></pre><h3 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h3><pre><code>public synchronized E set(int index, E element) {    if (index &gt;= elementCount)        throw new ArrayIndexOutOfBoundsException(index);    E oldValue = elementData(index);    elementData[index] = element;    return oldValue;}</code></pre><h3 id="包含-2"><a href="#包含-2" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return indexOf(o, 0) &gt;= 0;}</code></pre><pre><code>public synchronized int indexOf(Object o, int index) {    if (o == null) {        for (int i = index ; i &lt; elementCount ; i++)            if (elementData[i]==null)                return i;    } else {        for (int i = index ; i &lt; elementCount ; i++)            if (o.equals(elementData[i]))                return i;    }    return -1;}</code></pre><ul><li><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2></li><li><p>基于Vector实现，支持LIFO。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3></li></ul><pre><code>public class Stack&lt;E&gt; extends Vector&lt;E&gt; {}</code></pre><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><pre><code>public E push(E item) {    addElement(item);    return item;}</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><pre><code>public synchronized E pop() {    E  obj;    int len = size();    obj = peek();    removeElementAt(len - 1);    return obj;}</code></pre><h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><pre><code>public synchronized E peek() {    int len = size();    if (len == 0)        throw new EmptyStackException();    return elementAt(len - 1);}</code></pre><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><ul><li><p>是一个线程安全、并且在读操作时无锁的ArrayList。</p></li><li><p>很多时候，我们的系统应对的都是读多写少的并发场景。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p></li><li><p>优点</p><ul><li>1)采用读写分离方式，读的效率非常高</li><li>2)CopyOnWriteArrayList的迭代器是基于创建时的数据快照的，故数组的增删改不会影响到迭代器</li></ul></li><li><p>缺点</p><ul><li>1)内存占用高，每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC</li><li>2)只能保证数据的最终一致性，不能保证数据的实时一致性。写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据。</li></ul></li></ul><h3 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** The lock protecting all mutators */final transient ReentrantLock lock = new ReentrantLock();/** The array, accessed only via getArray/setArray. */private transient volatile Object[] array;</code></pre><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public CopyOnWriteArrayList() {    setArray(new Object[0]);}</code></pre><ul><li>final void setArray(Object[] a) {<br>  array = a;<br>}</li></ul><h3 id="添加（有锁，锁内重新创建数组"><a href="#添加（有锁，锁内重新创建数组" class="headerlink" title="添加（有锁，锁内重新创建数组)"></a>添加（有锁，锁内重新创建数组)</h3><ul><li>final Object[] getArray() {<br>  return array;<br>}</li></ul><pre><code>public boolean add(E e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    } finally {        lock.unlock();    }}</code></pre><h3 id="存在则添加（有锁，锁内重新创建数组"><a href="#存在则添加（有锁，锁内重新创建数组" class="headerlink" title="存在则添加（有锁，锁内重新创建数组)"></a>存在则添加（有锁，锁内重新创建数组)</h3><ul><li>先保存一份数组snapshot，如果snapshot中存在，则直接返回。</li><li>如果不存在，那么加锁，获取当前数组current，比较snapshot与current，遍历它们共同长度内的元素，如果发现current中某一个元素等于e，那么直接返回（当然current与snapshot相同就不必看了)；</li><li>之后再遍历current单独的部分，如果发现current中某一个元素等于e，那么直接返回；</li><li>此时可以去创建一个长度+1的新数组，将e加入。</li></ul><pre><code>public boolean addIfAbsent(E e) {    Object[] snapshot = getArray();    return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :        addIfAbsent(e, snapshot);}</code></pre><pre><code>private boolean addIfAbsent(E e, Object[] snapshot) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] current = getArray();        int len = current.length;        if (snapshot != current) {            // Optimize for lost race to another addXXX operation            int common = Math.min(snapshot.length, len);            for (int i = 0; i &lt; common; i++)</code></pre><ul><li>//如果snapshot与current元素不同但current与e相同，那么直接返回（扫描0到common)<pre><code>          if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))              return false;</code></pre><ul><li>// 如果current中存在e，那么直接返回（扫描commen到len)<pre><code>  if (indexOf(e, current, common, len) &gt;= 0)          return false;</code></pre>  }<br>  Object[] newElements = Arrays.copyOf(current, len + 1);<br>  newElements[len] = e;<br>  setArray(newElements);<br>  return true;<br>} finally {<br>  lock.unlock();<br>}<br>}</li></ul></li></ul><h3 id="删除（有锁，锁内重新创建数组"><a href="#删除（有锁，锁内重新创建数组" class="headerlink" title="删除（有锁，锁内重新创建数组)"></a>删除（有锁，锁内重新创建数组)</h3><pre><code>public E remove(int index) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        E oldValue = get(elements, index);        int numMoved = len - index - 1;        if (numMoved == 0)            setArray(Arrays.copyOf(elements, len - 1));        else {            Object[] newElements = new Object[len - 1];            System.arraycopy(elements, 0, newElements, 0, index);            System.arraycopy(elements, index + 1, newElements, index,                             numMoved);            setArray(newElements);        }        return oldValue;    } finally {        lock.unlock();    }}</code></pre><h3 id="获取（无锁"><a href="#获取（无锁" class="headerlink" title="获取（无锁)"></a>获取（无锁)</h3><pre><code>public E get(int index) {    return get(getArray(), index);}</code></pre><pre><code>private E get(Object[] a, int index) {    return (E) a[index];}</code></pre><h3 id="更新（有锁，锁内重新创建数组"><a href="#更新（有锁，锁内重新创建数组" class="headerlink" title="更新（有锁，锁内重新创建数组)"></a>更新（有锁，锁内重新创建数组)</h3><pre><code>public E set(int index, E element) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        E oldValue = get(elements, index);        if (oldValue != element) {            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len);            newElements[index] = element;            setArray(newElements);        } else {</code></pre><ul><li>// 为了保持“volatile”的语义，任何一个读操作都应该是一个写操作的结果，</li><li>也就是读操作看到的数据一定是某个写操作的结果（尽管写操作没有改变数据本身)。</li><li>所以这里即使不设置也没有问题，仅仅是为了一个语义上的补充（就如源码中的注释所言)<pre><code>      // Not quite a no-op; ensures volatile write semantics      setArray(elements);  }  return oldValue;</code></pre>  } finally {<pre><code>  lock.unlock();</code></pre>  }<br>}</li></ul><h3 id="包含（无锁"><a href="#包含（无锁" class="headerlink" title="包含（无锁)"></a>包含（无锁)</h3><pre><code>public boolean contains(Object o) {    Object[] elements = getArray();    return indexOf(o, elements, 0, elements.length) &gt;= 0;}</code></pre><pre><code>private static int indexOf(Object o, Object[] elements,                           int index, int fence) {    if (o == null) {        for (int i = index; i &lt; fence; i++)            if (elements[i] == null)                return i;    } else {        for (int i = index; i &lt; fence; i++)            if (o.equals(elements[i]))                return i;    }    return -1;}</code></pre><h3 id="遍历（遍历的是获取iterator时的数组快照"><a href="#遍历（遍历的是获取iterator时的数组快照" class="headerlink" title="遍历（遍历的是获取iterator时的数组快照)"></a>遍历（遍历的是获取iterator时的数组快照)</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return new COWIterator&lt;E&gt;(getArray(), 0);}</code></pre><pre><code>static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {    /** Snapshot of the array */    private final Object[] snapshot;    /** Index of element to be returned by subsequent call to next.  */    private int cursor;    private COWIterator(Object[] elements, int initialCursor) {        cursor = initialCursor;        snapshot = elements;    }    public boolean hasNext() {        return cursor &lt; snapshot.length;    }    public boolean hasPrevious() {        return cursor &gt; 0;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        if (! hasNext())            throw new NoSuchElementException();        return (E) snapshot[cursor++];    }    @SuppressWarnings(&quot;unchecked&quot;)    public E previous() {        if (! hasPrevious())            throw new NoSuchElementException();        return (E) snapshot[--cursor];    }    public int nextIndex() {        return cursor;    }    public int previousIndex() {        return cursor-1;    }    /**     * Not supported. Always throws UnsupportedOperationException.     * @throws UnsupportedOperationException always; {@code remove}     *         is not supported by this iterator.     */    public void remove() {        throw new UnsupportedOperationException();    }    /**     * Not supported. Always throws UnsupportedOperationException.     * @throws UnsupportedOperationException always; {@code set}     *         is not supported by this iterator.     */    public void set(E e) {        throw new UnsupportedOperationException();    }    /**     * Not supported. Always throws UnsupportedOperationException.     * @throws UnsupportedOperationException always; {@code add}     *         is not supported by this iterator.     */    public void add(E e) {        throw new UnsupportedOperationException();    }    @Override    public void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        Object[] elements = snapshot;        final int size = elements.length;        for (int i = cursor; i &lt; size; i++) {            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) elements[i];            action.accept(e);        }        cursor = size;    }}</code></pre><ul><li><h2 id="List实现类之间的区别"><a href="#List实现类之间的区别" class="headerlink" title="List实现类之间的区别"></a>List实现类之间的区别</h2><ul><li>(1) 对于需要快速插入，删除元素，应该使用LinkedList。</li><li>(2) 对于需要快速随机访问元素，应该使用ArrayList。</li><li>(3) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。</li></ul></li><li><p>对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector、CopyOnWriteArrayList)。</p></li></ul><ul><li><h1 id="3-3-Set"><a href="#3-3-Set" class="headerlink" title="3.3 Set"></a>3.3 Set</h1></li><li><p>没有顺序，不可重复</p><h2 id="HashSet（底层是HashMap"><a href="#HashSet（底层是HashMap" class="headerlink" title="HashSet（底层是HashMap)"></a>HashSet（底层是HashMap)</h2></li><li><p>Set不允许元素重复。</p></li><li><p>基于HashMap实现，无容量限制。</p></li><li><p>是非线程安全的。</p></li></ul><h3 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();</code></pre><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() {    map = new HashMap&lt;&gt;();}</code></pre><pre><code>public HashSet(int initialCapacity) {    map = new HashMap&lt;&gt;(initialCapacity);}</code></pre><pre><code>public HashSet(int initialCapacity, float loadFactor) {    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);}</code></pre><h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><pre><code>public boolean add(E e) {    return map.put(e, PRESENT)==null;}</code></pre><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><pre><code>public boolean remove(Object o) {    return map.remove(o)==PRESENT;}</code></pre><h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return map.keySet().iterator();}</code></pre><h3 id="包含-3"><a href="#包含-3" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return map.containsKey(o);}</code></pre><ul><li><h2 id="TreeSet（底层是TreeMap"><a href="#TreeSet（底层是TreeMap" class="headerlink" title="TreeSet（底层是TreeMap)"></a>TreeSet（底层是TreeMap)</h2></li><li><p>基于TreeMap实现，支持排序（自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序)。</p></li><li><p>是非线程安全的。</p></li></ul><h3 id="成员变量-5"><a href="#成员变量-5" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** * The backing map. */private transient NavigableMap&lt;E,Object&gt; m;// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object();</code></pre><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public TreeSet() {    this(new TreeMap&lt;E,Object&gt;());}</code></pre><pre><code>public TreeSet(Comparator&lt;? super E&gt; comparator) {    this(new TreeMap&lt;&gt;(comparator));}</code></pre><h3 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h3><pre><code>public boolean add(E e) {    return m.put(e, PRESENT)==null;}</code></pre><h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><pre><code>public boolean remove(Object o) {    return m.remove(o)==PRESENT;}</code></pre><h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return m.navigableKeySet().iterator();}</code></pre><h3 id="包含-4"><a href="#包含-4" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return m.containsKey(o);}</code></pre><h3 id="获取开头"><a href="#获取开头" class="headerlink" title="获取开头"></a>获取开头</h3><pre><code>public E first() {    return m.firstKey();}</code></pre><h3 id="获取结尾"><a href="#获取结尾" class="headerlink" title="获取结尾"></a>获取结尾</h3><pre><code>public E last() {    return m.lastKey();}</code></pre><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><pre><code>public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,                              E toElement,   boolean toInclusive) {    return new TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,                                   toElement,   toInclusive));}</code></pre><ul><li>默认是含头不含尾</li></ul><pre><code>public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {    return subSet(fromElement, true, toElement, false);}</code></pre><ul><li><h2 id="LinkedHashSet（继承自HashSet，底层是LinkedHashMap"><a href="#LinkedHashSet（继承自HashSet，底层是LinkedHashMap" class="headerlink" title="LinkedHashSet（继承自HashSet，底层是LinkedHashMap)"></a>LinkedHashSet（继承自HashSet，底层是LinkedHashMap)</h2></li><li><p>LinkedHashSet继承自HashSet，源码更少、更简单，唯一的区别是LinkedHashSet内部使用的是LinkHashMap。这样做的意义或者好处就是LinkedHashSet中的元素顺序是可以保证的，也就是说遍历序和插入序是一致的。</p><h3 id="类声明-1"><a href="#类声明-1" class="headerlink" title="类声明"></a>类声明</h3></li></ul><pre><code>public class LinkedHashSet&lt;E&gt;    extends HashSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable {}</code></pre><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public LinkedHashSet(int initialCapacity, float loadFactor) {    super(initialCapacity, loadFactor, true);}/** * Constructs a new, empty linked hash set with the specified initial * capacity and the default load factor (0.75). * * @param   initialCapacity   the initial capacity of the LinkedHashSet * @throws  IllegalArgumentException if the initial capacity is less *              than zero */public LinkedHashSet(int initialCapacity) {    super(initialCapacity, .75f, true);}/** * Constructs a new, empty linked hash set with the default initial * capacity (16) and load factor (0.75). */public LinkedHashSet() {    super(16, .75f, true);}</code></pre><ul><li>super指的是HashSet的default访问级别的构造方法</li></ul><pre><code>/** * Constructs a new, empty linked hash set.  (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param      initialCapacity   the initial capacity of the hash map * @param      loadFactor        the load factor of the hash map * @param      dummy             ignored (distinguishes this *             constructor from other int, float constructor.) * @throws     IllegalArgumentException if the initial capacity is less *             than zero, or if the load factor is nonpositive */HashSet(int initialCapacity, float loadFactor, boolean dummy) {    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);}</code></pre><h2 id="BitSet（位集，底层是long数组，用于替代List"><a href="#BitSet（位集，底层是long数组，用于替代List" class="headerlink" title="BitSet（位集，底层是long数组，用于替代List)"></a>BitSet（位集，底层是long数组，用于替代List<Boolean>)</h2><ul><li><p>BitSet是位操作的对象，值只有0或1即false和true，内部维护了一个long数组，初始只有一个long，所以BitSet最小的size是64（8个字节64个位，可以存储64个数字)，当随着存储的元素越来越多，BitSet内部会动态扩充，最终内部是由N个long来存储，这些针对操作都是透明的。</p></li><li><p>默认情况下，BitSet的所有位都是false即0。</p></li><li><p>不是线程安全的。</p></li><li><p>用1位来表示一个数据是否出现过，0为没有出现过，1表示出现过。使用的时候既可根据某一个是否为0表示，此数是否出现过。</p></li><li><p>一个1GB的空间，有8<em>1024</em>1024<em>1024 = 8.58</em>10^9bit，也就是1GB的空间可以表示85亿多个数。</p></li><li><p>常见的应用是那些需要对海量数据进行一些统计工作的时候，比如日志分析、用户数统计等等，如统计40亿个数据中没有出现的数据，将40亿个不同数据进行排序，海量数据去重等等。</p></li><li><p>JDK选择long数组作为BitSet的内部存储结构是出于性能的考虑，因为BitSet提供and和or这种操作，需要对两个BitSet中的所有bit位做and或者or，实现的时候需要遍历所有的数组元素。使用long能够使得循环的次数降到最低，所以Java选择使用long数组作为BitSet的内部存储结构。<br>BitSet()</p><pre><code>    创建一个新的位 set。</code></pre><p>BitSet(int nbits)</p><pre><code>    创建一个位 set，它的初始大小足以显式表示索引范围在 0 到 nbits-1 的位。</code></pre><p>   void    and(BitSet set)</p><pre><code>    对此目标位 set 和参数位 set 执行逻辑与操作。</code></pre><p>   void    andNot(BitSet set)</p><pre><code>    清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。</code></pre><p>   int    cardinality()</p><pre><code>    返回此 BitSet 中设置为 true 的位数。</code></pre><p>   void    clear()</p><pre><code>    将此 BitSet 中的所有位设置为 false。</code></pre><p>   void    clear(int bitIndex)</p><pre><code>    将索引指定处的位设置为 false。</code></pre><p>   void    clear(int fromIndex, int toIndex)</p><pre><code>    将指定的 fromIndex（包括)到指定的 toIndex（不包括)范围内的位设置为 false。</code></pre><p>   Object    clone()</p><pre><code>    复制此 BitSet，生成一个与之相等的新 BitSet。</code></pre><p>   boolean    equals(Object obj)</p><pre><code>    将此对象与指定的对象进行比较。</code></pre><p>   void    flip(int bitIndex)</p><pre><code>    将指定索引处的位设置为其当前值的补码。</code></pre><p>   void    flip(int fromIndex, int toIndex)</p><pre><code>    将指定的 fromIndex（包括)到指定的 toIndex（不包括)范围内的每个位设置为其当前值的补码。</code></pre><p>   boolean    get(int bitIndex)</p><pre><code>    返回指定索引处的位值。</code></pre><p>   BitSet    get(int fromIndex, int toIndex)</p><pre><code>    返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括)到 toIndex（不包括)范围内的位组成。</code></pre><p>   int    hashCode()</p><pre><code>    返回此位 set 的哈希码值。</code></pre><p>   boolean    intersects(BitSet set)</p><pre><code>    如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为true，则返回 ture。</code></pre><p>   boolean    isEmpty()</p><pre><code>    如果此 BitSet 中没有包含任何设置为 true 的位，则返回 ture。</code></pre><p>   int    length()</p><pre><code>    返回此 BitSet 的“逻辑大小”：BitSet 中最高设置位的索引加 1。</code></pre><p>   int    nextClearBit(int fromIndex)</p><pre><code>    返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。</code></pre><p>   int    nextSetBit(int fromIndex)</p><pre><code>    返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。</code></pre><p>   void    or(BitSet set)</p><pre><code>    对此位 set 和位 set 参数执行逻辑或操作。</code></pre><p>   void    set(int bitIndex)</p><pre><code>    将指定索引处的位设置为 true。</code></pre><p>   void    set(int bitIndex, boolean value)</p><pre><code>    将指定索引处的位设置为指定的值。</code></pre><p>   void    set(int fromIndex, int toIndex)</p><pre><code>    将指定的 fromIndex（包括)到指定的 toIndex（不包括)范围内的位设置为 true。</code></pre><p>   void    set(int fromIndex, int toIndex, boolean value)</p><pre><code>    将指定的 fromIndex（包括)到指定的 toIndex（不包括)范围内的位设置为指定的值。</code></pre><p>   int    size()</p><pre><code>    返回此 BitSet 表示位值时实际使用空间的位数。</code></pre><p>   String    toString()</p><pre><code>    返回此位 set 的字符串表示形式。</code></pre><p>   void    xor(BitSet set)</p><pre><code>    对此位 set 和位 set 参数执行逻辑异或操作。</code></pre></li></ul><h3 id="去重示例"><a href="#去重示例" class="headerlink" title="去重示例"></a>去重示例</h3><pre><code>public static void containChars(String str) {    BitSet used = new BitSet();    for (int i = 0; i &lt; str.length(); i++)        used.set(str.charAt(i)); // set bit for char      StringBuilder sb = new StringBuilder();    sb.append(&quot;[&quot;);    int size = used.size();    for (int i = 0; i &lt; size; i++) {        if (used.get(i)) {            sb.append((char) i);        }    }    sb.append(&quot;]&quot;);    System.out.println(sb.toString());}public static void main(String[] args) {    containChars(&quot;abcdfab&quot;);}</code></pre><ul><li>[abcdf]</li></ul><h3 id="排序示例"><a href="#排序示例" class="headerlink" title="排序示例"></a>排序示例</h3><pre><code>public static void sortArray(int[] array) {    BitSet bitSet = new BitSet(2 &lt;&lt; 13);    // 虽然可以自动扩容，但尽量在构造时指定估算大小,默认为64      System.out.println(&quot;BitSet size: &quot; + bitSet.size());    for (int i = 0; i &lt; array.length; i++) {        bitSet.set(array[i]);    }    //剔除重复数字后的元素个数      int bitLen = bitSet.cardinality();    //进行排序，即把bit为true的元素复制到另一个数组      int[] orderedArray = new int[bitLen];    int k = 0;    for (int i = bitSet.nextSetBit(0); i &gt;= 0; i = bitSet.nextSetBit(i + 1)) {        orderedArray[k++] = i;    }    System.out.println(&quot;After ordering: &quot;);    for (int i = 0; i &lt; bitLen; i++) {        System.out.print(orderedArray[i] + &quot;\t&quot;);    }}public static void main(String[] args) {    int[] array = new int[]{423, 700, 9999, 2323, 356, 6400, 1, 2, 3, 2, 2, 2, 2};    sortArray(array);}</code></pre><ul><li>BitSet size: 16384</li><li>After ordering: </li><li>1    2    3    356    423    700    2323    6400    9999    </li></ul><h2 id="CopyOnWriteArraySet（底层是CopyOnWriteArrayList"><a href="#CopyOnWriteArraySet（底层是CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArraySet（底层是CopyOnWriteArrayList)"></a>CopyOnWriteArraySet（底层是CopyOnWriteArrayList)</h2><ul><li>基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法。</li><li>在每次add的时候都要进行数组的遍历，因此其性能会略低于CopyOnWriteArrayList。<h3 id="成员变量-6"><a href="#成员变量-6" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>private final CopyOnWriteArrayList&lt;E&gt; al;</code></pre><h3 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public CopyOnWriteArraySet() {    al = new CopyOnWriteArrayList&lt;E&gt;();}</code></pre><h3 id="添加-3"><a href="#添加-3" class="headerlink" title="添加"></a>添加</h3><pre><code>public boolean add(E e) {    return al.addIfAbsent(e);}</code></pre><h3 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h3><pre><code>public boolean remove(Object o) {    return al.remove(o);}</code></pre><h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return al.iterator();}</code></pre><h3 id="包含-5"><a href="#包含-5" class="headerlink" title="包含"></a>包含</h3><pre><code>public boolean contains(Object o) {    return al.contains(o);}</code></pre><ul><li><h1 id="3-4-Queue"><a href="#3-4-Queue" class="headerlink" title="3.4 Queue"></a>3.4 Queue</h1></li><li><p>先进先出”（FIFO—first in first out)的线性表</p></li><li><p>LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</p></li><li><p>Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList)。</p></li><li></li><li><p>Deque既可以作为栈使用，也可以作为队列使用。<br>  Queue Method    Equivalent Deque Method    说明<br>  add(e)    addLast(e)    向队尾插入元素，失败则抛出异常<br>  remove()    removeFirst()    获取并删除队首元素，失败则抛出异常</p></li></ul><p>element()    getFirst()    获取但不删除队首元素，失败则抛出异常<br>offer(e)    offerLast(e)    向队尾插入元素，失败则返回false<br>poll()    pollFirst()    获取并删除队首元素，失败则返回null<br>peek()    peekFirst()    获取但不删除队首元素，失败则返回null</p><p>Stack Method    Equivalent Deque Method    说明<br>push(e)    addFirst(e)    向栈顶插入元素，失败则抛出异常<br>无    offerFirst(e)    向栈顶插入元素，失败则返回false<br>pop()    removeFirst()    获取并删除栈顶元素，失败则抛出异常<br>无    pollFirst()    获取并删除栈顶元素，失败则返回null<br>peek()    peekFirst()    获取但不删除栈顶元素，失败则抛出异常<br>无    peekFirst()    获取但不删除栈顶元素，失败则返回null</p><ul><li><p>ArrayDeque和LinkedList是Deque的两个通用实现。</p></li><li></li></ul><h2 id="1-ArrayDeque（底层是循环数组，有界队列"><a href="#1-ArrayDeque（底层是循环数组，有界队列" class="headerlink" title="1)ArrayDeque（底层是循环数组，有界队列)"></a>1)ArrayDeque（底层是循环数组，有界队列)</h2><ul><li>head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。<h3 id="成员变量-7"><a href="#成员变量-7" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>transient Object[] elements; // non-private to simplify nested class accesstransient int head;transient int tail;private static final int MIN_INITIAL_CAPACITY = 8;</code></pre><h3 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public ArrayDeque() {    elements = new Object[16];}</code></pre><pre><code>public ArrayDeque(int numElements) {    allocateElements(numElements);}</code></pre><pre><code>/** * Allocates empty array to hold the given number of elements. * * @param numElements  the number of elements to hold */private void allocateElements(int numElements) {    int initialCapacity = MIN_INITIAL_CAPACITY;    // Find the best power of two to hold elements.    // Tests &quot;&lt;=&quot; because arrays aren&#39;t kept full.    if (numElements &gt;= initialCapacity) {        initialCapacity = numElements;        initialCapacity |= (initialCapacity &gt;&gt;&gt;  1);        initialCapacity |= (initialCapacity &gt;&gt;&gt;  2);        initialCapacity |= (initialCapacity &gt;&gt;&gt;  4);        initialCapacity |= (initialCapacity &gt;&gt;&gt;  8);        initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);        initialCapacity++;        if (initialCapacity &lt; 0)   // Too many elements, must back off            initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements    }    elements = new Object[initialCapacity];}</code></pre><ul><li><h3 id="扩容-2"><a href="#扩容-2" class="headerlink" title="扩容"></a>扩容</h3></li></ul><pre><code>/** * Doubles the capacity of this deque.  Call only when full, i.e., * when head and tail have wrapped around to become equal. */private void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // number of elements to the right of p    int newCapacity = n &lt;&lt; 1;    if (newCapacity &lt; 0)        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);    System.arraycopy(elements, 0, a, r, p);    elements = a;    head = 0;    tail = n;}</code></pre><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><pre><code>public boolean offer(E e) {    return offerLast(e);}</code></pre><pre><code>public boolean offerLast(E e) {    addLast(e);    return true;}</code></pre><pre><code>public void addLast(E e) {    if (e == null)        throw new NullPointerException();    elements[tail] = e;    if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)        doubleCapacity();}</code></pre><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><pre><code>public E poll() {    return pollFirst();}</code></pre><pre><code>public E pollFirst() {    int h = head;    @SuppressWarnings(&quot;unchecked&quot;)    E result = (E) elements[h];    // Element is null if deque empty    if (result == null)        return null;    elements[h] = null;     // Must null out slot    head = (h + 1) &amp; (elements.length - 1);    return result;}</code></pre><h3 id="peek-1"><a href="#peek-1" class="headerlink" title="peek"></a>peek</h3><pre><code>public E peek() {    return peekFirst();}</code></pre><pre><code>public E peekFirst() {    // elements[head] is null if deque empty    return (E) elements[head];}</code></pre><ul><li><h2 id="ConcurrentLinkedQueue（底层是链表，基于CAS的非阻塞队列，无界队列"><a href="#ConcurrentLinkedQueue（底层是链表，基于CAS的非阻塞队列，无界队列" class="headerlink" title="ConcurrentLinkedQueue（底层是链表，基于CAS的非阻塞队列，无界队列)"></a>ConcurrentLinkedQueue（底层是链表，基于CAS的非阻塞队列，无界队列)</h2></li><li><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法（非阻塞)来实现。</p></li><li><p>1 . 使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。 </p></li><li><ol start="2"><li>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。 </li></ol></li><li><ol start="3"><li>以批处理方式来更新head/tail，从整体上减少入队 / 出队操作的开销。</li></ol></li><li><ol start="4"><li>ConcurrentLinkedQueue的迭代器是弱一致性的，这在并发容器中是比较普遍的现象，主要是指在一个线程在遍历队列结点而另一个线程尝试对某个队列结点进行修改的话不会抛出ConcurrentModificationException，这也就造成在遍历某个尚未被修改的结点时，在next方法返回时可以看到该结点的修改，但在遍历后再对该结点修改时就看不到这种变化。</li></ol></li><li><ol><li>在入队时最后一个结点中的next域为null</li></ol></li><li><ol start="2"><li>队列中的所有未删除结点的item域不能为null且从head都可以在O(N)时间内遍历到</li></ol></li><li><ol start="3"><li>对于要删除的结点，不是将其引用直接置为空，而是将其的item域先置为null(迭代器在遍历是会跳过item为null的结点)</li></ol></li><li><ol start="4"><li>允许head和tail滞后更新，也就是上文提到的head/tail并非总是指向队列的头 / 尾节点（这主要是为了减少CAS指令执行的次数，但同时会增加volatile读的次数，但是这种消耗较小)。具体而言就是，当在队列中插入一个元素是，会检测tail和最后一个结点之间的距离是否在两个结点及以上(内部称之为hop)；而在出队时，对head的检测就是与队列的第一个结点的距离是否达到两个，有则将head指向第一个结点并将head原来指向的结点的next域指向自己，这样就能断开与队列的联系从而帮助GC</li></ol></li><li><p>head节点并不是总指向第一个结点，tail也并不是总指向最后一个节点。</p></li><li><p>源码过于复杂，可以先跳过。</p></li></ul><h3 id="成员变量-8"><a href="#成员变量-8" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail;</code></pre><h3 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public ConcurrentLinkedQueue() {    head = tail = new Node&lt;E&gt;(null);}</code></pre><ul><li>Node#CAS操作</li><li>在obj的offset位置比较object field和期望的值，如果相同则更新。这个方法的操作应该是原子的，因此提供了一种不可中断的方式更新object field。</li></ul><ul><li><p>如果node的next值为cmp，则将其更新为val</p></li><li><p>boolean casNext(Node<E> cmp, Node<E> val) {<br>  return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);<br>}</p></li><li><p>boolean casItem(E cmp, E val) {<br>  return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);<br>}</p></li></ul><pre><code>private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {    return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);}</code></pre><ul><li>void lazySetNext(Node<E> val) {<br>  UNSAFE.putOrderedObject(this, nextOffset, val);<br>}</li></ul><h3 id="offer（无锁"><a href="#offer（无锁" class="headerlink" title="offer（无锁)"></a>offer（无锁)</h3><pre><code>/** * Inserts the specified element at the tail of this queue. * As the queue is unbounded, this method will never return {@code false}. * * @return {@code true} (as specified by {@link Queue#offer}) * @throws NullPointerException if the specified element is null */public boolean offer(E e) {    checkNotNull(e);    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);    for (Node&lt;E&gt; t = tail, p = t;;) {        Node&lt;E&gt; q = p.next;</code></pre><ul><li>// q/p.next/tail.next为null，则说明p是尾节点，则插入<pre><code>  if (q == null) {      // CAS插入 p.next = newNode，多线程环境下只有一个线程可以设置成功</code></pre></li><li>// 此时 tail.next = newNode<pre><code>      if (p.casNext(null, newNode)) {</code></pre></li><li>// CAS成功说明新节点已经放入链表 </li><li>// 如果p不为t，说明当前线程是之前CAS失败后又重试CAS成功的，tail = newNode<pre><code>          if (p != t) // hop two nodes at a time</code></pre></li><li>casTail(t, newNode);  // Failure is OK.<pre><code>         return true;     }     // Lost CAS race to another thread; re-read next } else if (p == q)</code></pre></li><li>//多线程操作时候，由于poll时候会把老的head变为自引用，然后head的next变为新head，所以这里需要重新找新的head，因为新的head后面的节点才是激活的节点<pre><code>      // p = head , t = tail</code></pre></li><li>p = (t != (t = tail)) ? t : head;<pre><code>  else</code></pre></li><li>// 对上一次CAS失败的线程而言，t.next/p.next/tail.next/q 不是null了</li><li>// 副作用是p = q，p和q都指向了尾节点，进入第三次循环<pre><code>      p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code></pre>  }<br>}</li></ul><h3 id="poll（无锁"><a href="#poll（无锁" class="headerlink" title="poll（无锁)"></a>poll（无锁)</h3><pre><code>public E poll() {    restartFromHead:    for (;;) {        for (Node&lt;E&gt; h = head, p = h, q;;) {</code></pre><ul><li><p>// 保存当前节点的值</p><pre><code>      E item = p.item;      // 当前节点有值则CAS置为null, p.item = null      if (item != null &amp;&amp; p.casItem(item, null)) {</code></pre></li><li><p>// CAS成功代表当前节点已经从链表中移除</p></li><li><pre><code>          if (p != h) // hop two nodes at a time              updateHead(h, ((q = p.next) != null) ? q : p);          return item;      } // 当前队列为空时则返回null      else if ((q = p.next) == null) {          updateHead(h, p);          return null;      } // 自引用了，则重新找新的队列头节点      else if (p == q)          continue restartFromHead;      else          p = q;  }</code></pre><p>  }<br>}</p></li><li><p>final void updateHead(Node<E> h, Node<E> p) {<br>  if (h != p &amp;&amp; casHead(h, p))</p><pre><code>  h.lazySetNext(h);</code></pre><p>}</p></li></ul><h3 id="peek（无锁"><a href="#peek（无锁" class="headerlink" title="peek（无锁)"></a>peek（无锁)</h3><pre><code>public E peek() {    restartFromHead:    for (;;) {        for (Node&lt;E&gt; h = head, p = h, q;;) {            E item = p.item;            if (item != null || (q = p.next) == null) {                updateHead(h, p);                return item;            }            else if (p == q)                continue restartFromHead;            else                p = q;        }    }}</code></pre><h3 id="size（遍历计算大小，效率低"><a href="#size（遍历计算大小，效率低" class="headerlink" title="size（遍历计算大小，效率低)"></a>size（遍历计算大小，效率低)</h3><pre><code>public int size() {    int count = 0;    for (Node&lt;E&gt; p = first(); p != null; p = succ(p))        if (p.item != null)            // Collection.size() spec says to max out            if (++count == Integer.MAX_VALUE)                break;    return count;}</code></pre><ul><li><h3 id="ConcurrentLinkedDeque（底层是双向链表，基于CAS的非阻塞队列，无界队列"><a href="#ConcurrentLinkedDeque（底层是双向链表，基于CAS的非阻塞队列，无界队列" class="headerlink" title="ConcurrentLinkedDeque（底层是双向链表，基于CAS的非阻塞队列，无界队列)"></a>ConcurrentLinkedDeque（底层是双向链表，基于CAS的非阻塞队列，无界队列)</h3><h2 id="2-PriorityQueue（底层是数组，逻辑上是小顶堆，无界队列"><a href="#2-PriorityQueue（底层是数组，逻辑上是小顶堆，无界队列" class="headerlink" title="2)PriorityQueue（底层是数组，逻辑上是小顶堆，无界队列)"></a>2)PriorityQueue（底层是数组，逻辑上是小顶堆，无界队列)</h2></li><li><p>PriorityQueue底层实现的数据结构是“堆”，堆具有以下两个性质：</p></li><li><p>任意一个节点的值总是不大于（最大堆)或者不小于（最小堆)其父节点的值；堆是一棵完全二叉树</p><ul><li><p>基于数组实现的二叉堆，对于数组中任意位置的n上元素，其左孩子在[2n+1]位置上，右孩子[2(n+1)]位置，它的父亲则在[(n-1)/2]上，而根的位置则是[0]。</p></li><li><p>1)时间复杂度：remove()方法和add()方法时间复杂度为O(logn)，remove(Object obj)和contains()方法需要O(n)时间复杂度，取队头则需要O(1)时间</p></li><li><p>2)在初始化阶段会执行建堆函数，最终建立的是最小堆，每次出队和入队操作不能保证队列元素的有序性，只能保证队头元素和新插入元素的有序性，如果需要有序输出队列中的元素，则只要调用Arrays.sort()方法即可</p></li><li><p>3)可以使用Iterator的迭代器方法输出队列中元素</p></li><li><p>4)PriorityQueue是非同步的，要实现同步需要调用java.util.concurrent包下的PriorityBlockingQueue类来实现同步</p></li><li><p>5)在队列中不允许使用null元素</p></li><li><p>6)PriorityQueue默认是一个小顶堆，然而可以通过传入自定义的Comparator函数来实现大顶堆</p></li></ul></li><li><p>替代：用TreeMap复杂度太高，有没有更好的方法。hash方法，但是队列不是定长的，如果改变了大小要rehash代价太大，还有什么方法？用堆实现，那每次get put复杂度是多少（lgN)</p><h3 id="成员变量-9"><a href="#成员变量-9" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>transient Object[] queue; // non-private to simplify nested class access/** * The number of elements in the priority queue. */private int size = 0;/** * The comparator, or null if priority queue uses elements&#39; * natural ordering. */private final Comparator&lt;? super E&gt; comparator;/** * The number of times this priority queue has been * &lt;i&gt;structurally modified&lt;/i&gt;.  See AbstractList for gory details. */transient int modCount = 0; // non-private to simplify nested class access</code></pre><h3 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public PriorityQueue() {    this(DEFAULT_INITIAL_CAPACITY, null);}/** * Creates a {@code PriorityQueue} with the specified initial * capacity that orders its elements according to their * {@linkplain Comparable natural ordering}. * * @param initialCapacity the initial capacity for this priority queue * @throws IllegalArgumentException if {@code initialCapacity} is less *         than 1 */public PriorityQueue(int initialCapacity) {    this(initialCapacity, null);}/** * Creates a {@code PriorityQueue} with the default initial capacity and * whose elements are ordered according to the specified comparator. * * @param  comparator the comparator that will be used to order this *         priority queue.  If {@code null}, the {@linkplain Comparable *         natural ordering} of the elements will be used. * @since 1.8 */public PriorityQueue(Comparator&lt;? super E&gt; comparator) {    this(DEFAULT_INITIAL_CAPACITY, comparator);}/** * Creates a {@code PriorityQueue} with the specified initial capacity * that orders its elements according to the specified comparator. * * @param  initialCapacity the initial capacity for this priority queue * @param  comparator the comparator that will be used to order this *         priority queue.  If {@code null}, the {@linkplain Comparable *         natural ordering} of the elements will be used. * @throws IllegalArgumentException if {@code initialCapacity} is *         less than 1 */public PriorityQueue(int initialCapacity,                     Comparator&lt;? super E&gt; comparator) {    // Note: This restriction of at least one is not actually needed,    // but continues for 1.5 compatibility    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.queue = new Object[initialCapacity];    this.comparator = comparator;}</code></pre><h3 id="扩容-3"><a href="#扩容-3" class="headerlink" title="扩容"></a>扩容</h3><ul><li>Double size if small; else grow by 50%</li></ul><pre><code>private void grow(int minCapacity) {    int oldCapacity = queue.length;    // Double size if small; else grow by 50%    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?                                     (oldCapacity + 2) :                                     (oldCapacity &gt;&gt; 1));    // overflow-conscious code    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    queue = Arrays.copyOf(queue, newCapacity);}</code></pre><pre><code>private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><h3 id="offer-1"><a href="#offer-1" class="headerlink" title="offer"></a>offer</h3><pre><code>public boolean offer(E e) {    if (e == null)        throw new NullPointerException();    modCount++;    int i = size;    if (i &gt;= queue.length)        grow(i + 1);    size = i + 1;    if (i == 0)        queue[0] = e;    else        siftUp(i, e);    return true;}</code></pre><pre><code>private void siftUp(int k, E x) {    if (comparator != null)        siftUpUsingComparator(k, x);    else        siftUpComparable(k, x);}</code></pre><pre><code>private void siftUpUsingComparator(int k, E x) {    while (k &gt; 0) {        int parent = (k - 1) &gt;&gt;&gt; 1;        Object e = queue[parent];        if (comparator.compare(x, (E) e) &gt;= 0)            break;        queue[k] = e;        k = parent;    }    queue[k] = x;}</code></pre><pre><code>private void siftUpComparable(int k, E x) {    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;    while (k &gt; 0) {        int parent = (k - 1) &gt;&gt;&gt; 1;        Object e = queue[parent];        if (key.compareTo((E) e) &gt;= 0)            break;        queue[k] = e;        k = parent;    }    queue[k] = key;}</code></pre><h3 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h3><pre><code>public E poll() {    if (size == 0)        return null;    int s = --size;    modCount++;    E result = (E) queue[0];    E x = (E) queue[s];    queue[s] = null;    if (s != 0)        siftDown(0, x);    return result;}</code></pre><pre><code>private void siftDown(int k, E x) {    if (comparator != null)        siftDownUsingComparator(k, x);    else        siftDownComparable(k, x);}</code></pre><pre><code>private void siftDownUsingComparator(int k, E x) {    int half = size &gt;&gt;&gt; 1;    while (k &lt; half) {        int child = (k &lt;&lt; 1) + 1;        Object c = queue[child];        int right = child + 1;        if (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; 0)            c = queue[child = right];        if (comparator.compare(x, (E) c) &lt;= 0)            break;        queue[k] = c;        k = child;    }    queue[k] = x;}</code></pre><pre><code>private void siftDownComparable(int k, E x) {    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;    int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf    while (k &lt; half) {        int child = (k &lt;&lt; 1) + 1; // assume left child is least        Object c = queue[child];        int right = child + 1;        if (right &lt; size &amp;&amp;            ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)            c = queue[child = right];        if (key.compareTo((E) c) &lt;= 0)            break;        queue[k] = c;        k = child;    }    queue[k] = key;}</code></pre><h3 id="peek-2"><a href="#peek-2" class="headerlink" title="peek"></a>peek</h3><pre><code>public E peek() {    return (size == 0) ? null : (E) queue[0];}</code></pre><ul><li><h2 id="3-BlockingQueue"><a href="#3-BlockingQueue" class="headerlink" title="3)BlockingQueue"></a>3)BlockingQueue</h2></li><li><p>对于许多多线程问题，都可以通过使用一个或多个队列以优雅的方式将其形式化</p></li><li><p>生产者线程向队列插入元素，消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。</p></li><li><p>比如转账</p></li><li><p>一个线程将转账指令放入队列</p></li><li><p>一个线程从队列中取出指令执行转账，只有这个线程可以访问银行对象的内部。因此不需要同步</p></li><li><p>当试图向队列中添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列导致线程阻塞</p></li><li><p>在协调多个线程之间的合作时，阻塞队列是很有用的。</p></li><li><p>工作者线程可以周期性地将中间结果放入阻塞队列，其他工作者线程取出中间结果并进一步修改。队列会自动平衡负载，大概第一个线程集比第二个运行的慢，那么第二个线程集在等待结果时会阻塞，反之亦然</p><ul><li>1)LinkedBlockingQueue的容量是没有上边界的，是一个双向队列</li><li>2)ArrayBlockingQueue在构造时需要指定容量，并且有一个参数来指定是否需要公平策略</li><li>3)PriorityBlockingQueue是一个带优先级的队列，元素按照它们的优先级顺序被移走。该队列没有容量上限。</li><li>4)DelayQueue包含实现了Delayed接口的对象</li><li>5)TransferQueue接口允许生产者线程等待，直到消费者准备就绪可以接收一个元素。如果生产者调用transfer方法，那么这个调用会阻塞，直到插入的元素被消费者取出之后才停止阻塞。</li></ul></li><li><p>LinkedTransferQueue类实现了这个接口</p></li><li></li></ul><h2 id="ArrayBlockingQueue（底层是数组，阻塞队列，一把锁两个Condition，有界同步队列"><a href="#ArrayBlockingQueue（底层是数组，阻塞队列，一把锁两个Condition，有界同步队列" class="headerlink" title="ArrayBlockingQueue（底层是数组，阻塞队列，一把锁两个Condition，有界同步队列)"></a>ArrayBlockingQueue（底层是数组，阻塞队列，一把锁两个Condition，有界同步队列)</h2><ul><li>基于数组、先进先出、线程安全的集合类，特点是可实现指定时间的阻塞读写，并且容量是可限制的。<h3 id="成员变量-10"><a href="#成员变量-10" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>/** The queued items */final Object[] items;/** items index for next take, poll, peek or remove */int takeIndex;/** items index for next put, offer, or add */int putIndex;/** Number of elements in the queue */int count;/* * Concurrency control uses the classic two-condition algorithm * found in any textbook. *//** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull;/** * Shared state for currently active iterators, or null if there * are known not to be any.  Allows queue operations to update * iterator state. */transient Itrs itrs = null;</code></pre><h3 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public ArrayBlockingQueue(int capacity) {    this(capacity, false);}/** * Creates an {@code ArrayBlockingQueue} with the given (fixed) * capacity and the specified access policy. * * @param capacity the capacity of this queue * @param fair if {@code true} then queue accesses for threads blocked *        on insertion or removal, are processed in FIFO order; *        if {@code false} the access order is unspecified. * @throws IllegalArgumentException if {@code capacity &lt; 1} */public ArrayBlockingQueue(int capacity, boolean fair) {    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();}</code></pre><h3 id="put（有锁，队列满则阻塞"><a href="#put（有锁，队列满则阻塞" class="headerlink" title="put（有锁，队列满则阻塞)"></a>put（有锁，队列满则阻塞)</h3><pre><code>public void put(E e) throws InterruptedException {    checkNotNull(e);    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == items.length)            notFull.await();        enqueue(e);    } finally {        lock.unlock();    }}</code></pre><pre><code>private void enqueue(E x) {    // assert lock.getHoldCount() == 1;    // assert items[putIndex] == null;    final Object[] items = this.items;    items[putIndex] = x;    if (++putIndex == items.length)        putIndex = 0;    count++;    notEmpty.signal();}</code></pre><h3 id="take（有锁，队列空则阻塞"><a href="#take（有锁，队列空则阻塞" class="headerlink" title="take（有锁，队列空则阻塞)"></a>take（有锁，队列空则阻塞)</h3><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0)            notEmpty.await();        return dequeue();    } finally {        lock.unlock();    }}</code></pre><pre><code>private E dequeue() {    // assert lock.getHoldCount() == 1;    // assert items[takeIndex] != null;    final Object[] items = this.items;    @SuppressWarnings(&quot;unchecked&quot;)    E x = (E) items[takeIndex];    items[takeIndex] = null;    if (++takeIndex == items.length)        takeIndex = 0;    count--;    if (itrs != null)        itrs.elementDequeued();    notFull.signal();    return x;}</code></pre><h3 id="offer（有锁，最多阻塞一段时间"><a href="#offer（有锁，最多阻塞一段时间" class="headerlink" title="offer（有锁，最多阻塞一段时间)"></a>offer（有锁，最多阻塞一段时间)</h3><pre><code>public boolean offer(E e, long timeout, TimeUnit unit)    throws InterruptedException {    checkNotNull(e);    long nanos = unit.toNanos(timeout);    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == items.length) {            if (nanos &lt;= 0)                return false;            nanos = notFull.awaitNanos(nanos);        }        enqueue(e);        return true;    } finally {        lock.unlock();    }}</code></pre><h3 id="poll（有锁，最多阻塞一段时间"><a href="#poll（有锁，最多阻塞一段时间" class="headerlink" title="poll（有锁，最多阻塞一段时间)"></a>poll（有锁，最多阻塞一段时间)</h3><pre><code>public E poll(long timeout, TimeUnit unit) throws InterruptedException {    long nanos = unit.toNanos(timeout);    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0) {            if (nanos &lt;= 0)                return null;            nanos = notEmpty.awaitNanos(nanos);        }        return dequeue();    } finally {        lock.unlock();    }}</code></pre><h3 id="peek（有锁"><a href="#peek（有锁" class="headerlink" title="peek（有锁)"></a>peek（有锁)</h3><pre><code>public E peek() {    final ReentrantLock lock = this.lock;    lock.lock();    try {        return itemAt(takeIndex); // null when queue is empty    } finally {        lock.unlock();    }</code></pre><ul><li>final E itemAt(int i) {<br>  return (E) items[i];<br>}</li></ul><h3 id="遍历（构造迭代器加锁，遍历迭代器也加锁"><a href="#遍历（构造迭代器加锁，遍历迭代器也加锁" class="headerlink" title="遍历（构造迭代器加锁，遍历迭代器也加锁)"></a>遍历（构造迭代器加锁，遍历迭代器也加锁)</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}</code></pre><pre><code>private class Itr implements Iterator&lt;E&gt; {    /** Index to look for new nextItem; NONE at end */    private int cursor;    /** Element to be returned by next call to next(); null if none */    private E nextItem;    /** Index of nextItem; NONE if none, REMOVED if removed elsewhere */    private int nextIndex;    /** Last element returned; null if none or not detached. */    private E lastItem;    /** Index of lastItem, NONE if none, REMOVED if removed elsewhere */    private int lastRet;    /** Previous value of takeIndex, or DETACHED when detached */    private int prevTakeIndex;    /** Previous value of iters.cycles */    private int prevCycles;    /** Special index value indicating &quot;not available&quot; or &quot;undefined&quot; */    private static final int NONE = -1;    /**     * Special index value indicating &quot;removed elsewhere&quot;, that is,     * removed by some operation other than a call to this.remove().     */    private static final int REMOVED = -2;    /** Special value for prevTakeIndex indicating &quot;detached mode&quot; */    private static final int DETACHED = -3;    Itr() {        // assert lock.getHoldCount() == 0;        lastRet = NONE;        final ReentrantLock lock = ArrayBlockingQueue.this.lock;        lock.lock();        try {            if (count == 0) {                // assert itrs == null;                cursor = NONE;                nextIndex = NONE;                prevTakeIndex = DETACHED;            } else {                final int takeIndex = ArrayBlockingQueue.this.takeIndex;                prevTakeIndex = takeIndex;                nextItem = itemAt(nextIndex = takeIndex);                cursor = incCursor(takeIndex);                if (itrs == null) {                    itrs = new Itrs(this);                } else {                    itrs.register(this); // in this order                    itrs.doSomeSweeping(false);                }                prevCycles = itrs.cycles;                // assert takeIndex &gt;= 0;                // assert prevTakeIndex == takeIndex;                // assert nextIndex &gt;= 0;                // assert nextItem != null;            }        } finally {            lock.unlock();        }    }</code></pre><ul><li><p>}</p></li><li></li></ul><h2 id="LinkedBlockingQueue（底层是链表，阻塞队列，两把锁，各自对应一个Condition，无界同步队列"><a href="#LinkedBlockingQueue（底层是链表，阻塞队列，两把锁，各自对应一个Condition，无界同步队列" class="headerlink" title="LinkedBlockingQueue（底层是链表，阻塞队列，两把锁，各自对应一个Condition，无界同步队列)"></a>LinkedBlockingQueue（底层是链表，阻塞队列，两把锁，各自对应一个Condition，无界同步队列)</h2><ul><li>另一种BlockingQueue的实现，基于链表，没有容量限制。</li><li>由于出队只操作队头，入队只操作队尾，这里巧妙地使用了两把锁，对于put和offer入队操作使用一把锁，对于take和poll出队操作使用一把锁，避免了出队、入队时互相竞争锁的现象，因此LinkedBlockingQueue在高并发读写都多的情况下，性能会较ArrayBlockingQueue好很多，在遍历以及删除的情况下则要两把锁都要锁住。</li><li>多CPU情况下可以在同一时刻既消费又生产。<h3 id="成员变量-11"><a href="#成员变量-11" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>/** The capacity bound, or Integer.MAX_VALUE if none */private final int capacity;/** Current number of elements */private final AtomicInteger count = new AtomicInteger();/** * Head of linked list. * Invariant: head.item == null */transient Node&lt;E&gt; head;/** * Tail of linked list. * Invariant: last.next == null */private transient Node&lt;E&gt; last;/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition();</code></pre><h3 id="构造方法-12"><a href="#构造方法-12" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public LinkedBlockingQueue() {    this(Integer.MAX_VALUE);}/** * Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if {@code capacity} is not greater *         than zero */public LinkedBlockingQueue(int capacity) {    if (capacity &lt;= 0) throw new IllegalArgumentException();    this.capacity = capacity;    last = head = new Node&lt;E&gt;(null);}</code></pre><h3 id="put（加putLock锁，队列满则阻塞"><a href="#put（加putLock锁，队列满则阻塞" class="headerlink" title="put（加putLock锁，队列满则阻塞)"></a>put（加putLock锁，队列满则阻塞)</h3><pre><code>/** * Inserts the specified element at the tail of this queue, waiting if * necessary for space to become available. * * @throws InterruptedException {@inheritDoc} * @throws NullPointerException {@inheritDoc} */public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    // Note: convention in all put/take/etc is to preset local var    // holding count negative to indicate failure unless set.    int c = -1;    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    final AtomicInteger count = this.count;    putLock.lockInterruptibly();    try {        /*         * Note that count is used in wait guard even though it is         * not protected by lock. This works because count can         * only decrease at this point (all other puts are shut         * out by lock), and we (or some other waiting put) are         * signalled if it ever changes from capacity. Similarly         * for all other uses of count in other wait guards.         */        while (count.get() == capacity) {</code></pre><ul><li>// 阻塞，直至有剩余空间<pre><code>      notFull.await();  }  enqueue(node);  c = count.getAndIncrement();  if (c + 1 &lt; capacity)</code></pre></li><li>// 还有剩余空间时，唤醒其他生产者<pre><code>      notFull.signal();</code></pre>  } finally {<pre><code>  putLock.unlock();</code></pre>  }<br>  if (c == 0)</li><li>// c是放入当前元素之前队列的容量，现在新添加一个元素，那么唤醒消费者进行消费</li><li>signalNotEmpty();<br>}</li></ul><pre><code>private void enqueue(Node&lt;E&gt; node) {    // assert putLock.isHeldByCurrentThread();    // assert last.next == null;    last = last.next = node;}</code></pre><pre><code>private void signalNotEmpty() {    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try {</code></pre><ul><li>// 唤醒消费线程<pre><code>  notEmpty.signal();</code></pre>  } finally {<pre><code>  takeLock.unlock();</code></pre>  }<br>}</li></ul><h3 id="take（加takeLock锁，队列空则阻塞"><a href="#take（加takeLock锁，队列空则阻塞" class="headerlink" title="take（加takeLock锁，队列空则阻塞)"></a>take（加takeLock锁，队列空则阻塞)</h3><pre><code>public E take() throws InterruptedException {    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock;    takeLock.lockInterruptibly();    try {        while (count.get() == 0) {</code></pre><pre><code>- // 队列空则阻塞        notEmpty.await();    }    x = dequeue();    c = count.getAndDecrement();    if (c &gt; 1)</code></pre><ul><li>// 还有元素则唤醒其他消费者<pre><code>      notEmpty.signal();</code></pre>  } finally {<pre><code>  takeLock.unlock();</code></pre>  }<br>  if (c == capacity)</li><li>// c是消费当前元素之前队列的容量，现在的容量是c-1，可以继续放入元素，唤醒生产者进行生产<pre><code>  signalNotFull();</code></pre>  return x;<br>}</li></ul><pre><code>private E dequeue() {    // assert takeLock.isHeldByCurrentThread();    // assert head.item == null;    Node&lt;E&gt; h = head;    Node&lt;E&gt; first = h.next;    h.next = h; // help GC    head = first;    E x = first.item;    first.item = null;    return x;}</code></pre><pre><code>private void signalNotFull() {    final ReentrantLock putLock = this.putLock;    putLock.lock();    try {</code></pre><ul><li>// 唤醒生产者<pre><code>  notFull.signal();</code></pre>  } finally {<pre><code>  putLock.unlock();</code></pre>  }<br>}</li></ul><h3 id="peek（加takeLock锁"><a href="#peek（加takeLock锁" class="headerlink" title="peek（加takeLock锁)"></a>peek（加takeLock锁)</h3><pre><code>public E peek() {    if (count.get() == 0)        return null;    final ReentrantLock takeLock = this.takeLock;    takeLock.lock();    try {        Node&lt;E&gt; first = head.next;        if (first == null)            return null;        else            return first.item;    } finally {        takeLock.unlock();    }}</code></pre><h3 id="remove（加两把锁"><a href="#remove（加两把锁" class="headerlink" title="remove（加两把锁)"></a>remove（加两把锁)</h3><pre><code>/** * Locks to prevent both puts and takes. */void fullyLock() {    putLock.lock();    takeLock.lock();}/** * Unlocks to allow both puts and takes. */void fullyUnlock() {    takeLock.unlock();    putLock.unlock();}</code></pre><pre><code>public boolean remove(Object o) {    if (o == null) return false;    fullyLock();    try {        for (Node&lt;E&gt; trail = head, p = trail.next;             p != null;             trail = p, p = p.next) {            if (o.equals(p.item)) {                unlink(p, trail);                return true;            }        }        return false;    } finally {        fullyUnlock();    }}</code></pre><h3 id="遍历（加两把锁"><a href="#遍历（加两把锁" class="headerlink" title="遍历（加两把锁)"></a>遍历（加两把锁)</h3><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}private class Itr implements Iterator&lt;E&gt; {    /*     * Basic weakly-consistent iterator.  At all times hold the next     * item to hand out so that if hasNext() reports true, we will     * still have it to return even if lost race with a take etc.     */    private Node&lt;E&gt; current;    private Node&lt;E&gt; lastRet;    private E currentElement;    Itr() {        fullyLock();        try {            current = head.next;            if (current != null)                currentElement = current.item;        } finally {            fullyUnlock();        }    }    public boolean hasNext() {        return current != null;    }    /**     * Returns the next live successor of p, or null if no such.     *     * Unlike other traversal methods, iterators need to handle both:     * - dequeued nodes (p.next == p)     * - (possibly multiple) interior removed nodes (p.item == null)     */    private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) {        for (;;) {            Node&lt;E&gt; s = p.next;            if (s == p)                return head.next;            if (s == null || s.item != null)                return s;            p = s;        }    }    public E next() {        fullyLock();        try {            if (current == null)                throw new NoSuchElementException();            E x = currentElement;            lastRet = current;            current = nextNode(current);            currentElement = (current == null) ? null : current.item;            return x;        } finally {            fullyUnlock();        }    }    public void remove() {        if (lastRet == null)            throw new IllegalStateException();        fullyLock();        try {            Node&lt;E&gt; node = lastRet;            lastRet = null;            for (Node&lt;E&gt; trail = head, p = trail.next;                 p != null;                 trail = p, p = p.next) {                if (p == node) {                    unlink(p, trail);                    break;                }            }        } finally {            fullyUnlock();        }    }}</code></pre><ul><li><h3 id="LinkedBlockingDeque（底层是双向链表，阻塞队列，一把锁两个Condition，无界同步队列"><a href="#LinkedBlockingDeque（底层是双向链表，阻塞队列，一把锁两个Condition，无界同步队列" class="headerlink" title="LinkedBlockingDeque（底层是双向链表，阻塞队列，一把锁两个Condition，无界同步队列)"></a>LinkedBlockingDeque（底层是双向链表，阻塞队列，一把锁两个Condition，无界同步队列)</h3></li><li><p>LinkedBlockingDeque是一个基于链表的双端阻塞队列。和LinkedBlockingQueue类似，区别在于该类实现了Deque接口，而LinkedBlockingQueue实现了Queue接口。</p></li><li><p>LinkedBlockingDeque内部只有一把锁以及该锁上关联的两个条件，所以可以推断同一时刻只有一个线程可以在队头或者队尾执行入队或出队操作（类似于ArrayBlockingQueue)。可以发现这点和LinkedBlockingQueue不同，LinkedBlockingQueue可以同时有两个线程在两端执行操作。</p></li><li><p>LinkedBlockingDeque和LinkedBlockingQueue的相同点在于： </p></li><li><ol><li>基于链表 </li></ol></li><li><ol start="2"><li>容量可选，不设置的话，就是Int的最大值</li></ol></li><li><p>和LinkedBlockingQueue的不同点在于： </p></li><li><ol><li>双端链表和单链表 </li></ol></li><li><ol start="2"><li>不存在哨兵节点 </li></ol></li><li><ol start="3"><li>一把锁+两个条件</li></ol></li><li><p>LinkedBlockingDeque和ArrayBlockingQueue的相同点在于：使用一把锁+两个条件维持队列的同步。</p></li><li></li></ul><h2 id="PriorityBlockingQueue（底层是数组，出队时队空则阻塞；无界队列，不存在队满情况，一把锁一个Condition"><a href="#PriorityBlockingQueue（底层是数组，出队时队空则阻塞；无界队列，不存在队满情况，一把锁一个Condition" class="headerlink" title="PriorityBlockingQueue（底层是数组，出队时队空则阻塞；无界队列，不存在队满情况，一把锁一个Condition)"></a>PriorityBlockingQueue（底层是数组，出队时队空则阻塞；无界队列，不存在队满情况，一把锁一个Condition)</h2><ul><li>支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。<h3 id="成员变量-12"><a href="#成员变量-12" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>private static final int DEFAULT_INITIAL_CAPACITY = 11;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The * priority queue is ordered by comparator, or by the elements&#39; * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d.  The element with the * lowest value is in queue[0], assuming the queue is nonempty. */private transient Object[] queue;/** * The number of elements in the priority queue. */private transient int size;/** * The comparator, or null if priority queue uses elements&#39; * natural ordering. */private transient Comparator&lt;? super E&gt; comparator;/** * Lock used for all public operations */private final ReentrantLock lock;/** * Condition for blocking when empty */private final Condition notEmpty;/** * Spinlock for allocation, acquired via CAS. */private transient volatile int allocationSpinLock;/** * A plain PriorityQueue used only for serialization, * to maintain compatibility with previous versions * of this class. Non-null only during serialization/deserialization. */private PriorityQueue&lt;E&gt; q;</code></pre><h3 id="构造方法-13"><a href="#构造方法-13" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public PriorityBlockingQueue() {    this(DEFAULT_INITIAL_CAPACITY, null);}/** * Creates a {@code PriorityBlockingQueue} with the specified * initial capacity that orders its elements according to their * {@linkplain Comparable natural ordering}. * * @param initialCapacity the initial capacity for this priority queue * @throws IllegalArgumentException if {@code initialCapacity} is less *         than 1 */public PriorityBlockingQueue(int initialCapacity) {    this(initialCapacity, null);}/** * Creates a {@code PriorityBlockingQueue} with the specified initial * capacity that orders its elements according to the specified * comparator. * * @param initialCapacity the initial capacity for this priority queue * @param  comparator the comparator that will be used to order this *         priority queue.  If {@code null}, the {@linkplain Comparable *         natural ordering} of the elements will be used. * @throws IllegalArgumentException if {@code initialCapacity} is less *         than 1 */public PriorityBlockingQueue(int initialCapacity,                             Comparator&lt;? super E&gt; comparator) {    if (initialCapacity &lt; 1)        throw new IllegalArgumentException();    this.lock = new ReentrantLock();    this.notEmpty = lock.newCondition();    this.comparator = comparator;    this.queue = new Object[initialCapacity];}</code></pre><h3 id="扩容（基于CAS-Lock，CAS控制创建新的数组原子执行，Lock控制数组替换原子执行"><a href="#扩容（基于CAS-Lock，CAS控制创建新的数组原子执行，Lock控制数组替换原子执行" class="headerlink" title="扩容（基于CAS+Lock，CAS控制创建新的数组原子执行，Lock控制数组替换原子执行)"></a>扩容（基于CAS+Lock，CAS控制创建新的数组原子执行，Lock控制数组替换原子执行)</h3><pre><code>private void tryGrow(Object[] array, int oldCap) {    lock.unlock(); // must release and then re-acquire main lock    Object[] newArray = null;    if (allocationSpinLock == 0 &amp;&amp;        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,                                 0, 1)) {        try {            int newCap = oldCap + ((oldCap &lt; 64) ?                                   (oldCap + 2) : // grow faster if small                                   (oldCap &gt;&gt; 1));            if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow                int minCap = oldCap + 1;                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)                    throw new OutOfMemoryError();                newCap = MAX_ARRAY_SIZE;            }            if (newCap &gt; oldCap &amp;&amp; queue == array)                newArray = new Object[newCap];        } finally {            allocationSpinLock = 0;        }    }    if (newArray == null) // back off if another thread is allocating        Thread.yield();    lock.lock();    if (newArray != null &amp;&amp; queue == array) {        queue = newArray;        System.arraycopy(array, 0, newArray, 0, oldCap);    }}</code></pre><h3 id="put（有锁"><a href="#put（有锁" class="headerlink" title="put（有锁)"></a>put（有锁)</h3><pre><code>public void put(E e) {    offer(e); // never need to block}</code></pre><pre><code>public boolean offer(E e) {    if (e == null)        throw new NullPointerException();    final ReentrantLock lock = this.lock;    lock.lock();    int n, cap;    Object[] array;    while ((n = size) &gt;= (cap = (array = queue).length))        tryGrow(array, cap);    try {        Comparator&lt;? super E&gt; cmp = comparator;        if (cmp == null)            siftUpComparable(n, e, array);        else            siftUpUsingComparator(n, e, array, cmp);        size = n + 1;        notEmpty.signal();    } finally {        lock.unlock();    }    return true;}</code></pre><h3 id="take（有锁"><a href="#take（有锁" class="headerlink" title="take（有锁)"></a>take（有锁)</h3><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    E result;    try {        while ( (result = dequeue()) == null)            notEmpty.await();    } finally {        lock.unlock();    }    return result;}</code></pre><pre><code>private E dequeue() {    int n = size - 1;    if (n &lt; 0)        return null;    else {        Object[] array = queue;        E result = (E) array[0];        E x = (E) array[n];        array[n] = null;        Comparator&lt;? super E&gt; cmp = comparator;        if (cmp == null)            siftDownComparable(0, x, array, n);        else            siftDownUsingComparator(0, x, array, n, cmp);        size = n;        return result;    }}</code></pre><h3 id="peek（有锁-1"><a href="#peek（有锁-1" class="headerlink" title="peek（有锁)"></a>peek（有锁)</h3><pre><code>public E peek() {    final ReentrantLock lock = this.lock;    lock.lock();    try {        return (size == 0) ? null : (E) queue[0];    } finally {        lock.unlock();    }}</code></pre><ul><li><h2 id="DelayQueue（底层是PriorityQueue，无界阻塞队列，过期元素方可移除，基于Lock"><a href="#DelayQueue（底层是PriorityQueue，无界阻塞队列，过期元素方可移除，基于Lock" class="headerlink" title="DelayQueue（底层是PriorityQueue，无界阻塞队列，过期元素方可移除，基于Lock)"></a>DelayQueue（底层是PriorityQueue，无界阻塞队列，过期元素方可移除，基于Lock)</h2></li></ul><pre><code>public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;    implements BlockingQueue&lt;E&gt; {    private final transient ReentrantLock lock = new ReentrantLock();    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</code></pre><ul><li>DelayQueue队列中每个元素都有个过期时间，并且队列是个优先级队列，当从队列获取元素时候，只有过期元素才会出队列。</li><li>每个元素都必须实现Delayed接口</li></ul><pre><code>public interface Delayed extends Comparable&lt;Delayed&gt; {    /**     * Returns the remaining delay associated with this object, in the     * given time unit.     *     * @param unit the time unit     * @return the remaining delay; zero or negative values indicate     * that the delay has already elapsed     */    long getDelay(TimeUnit unit);}</code></pre><ul><li><p>getDelay方法返回对象的残留延迟，负值表示延迟结束</p></li><li><p>元素只有在延迟用完的时候才能从DelayQueue移出。还必须实现Comparable接口。</p></li><li><p>一个典型场景是重试机制的实现，比如当调用接口失败后，把当前调用信息放入delay=10s的元素，然后把元素放入队列，那么这个队列就是一个重试队列，一个线程通过take方法获取需要重试的接口，take返回则接口进行重试，失败则再次放入队列，同时也可以在元素加上重试次数。</p><h3 id="成员变量-13"><a href="#成员变量-13" class="headerlink" title="成员变量"></a>成员变量</h3></li></ul><pre><code>private final transient ReentrantLock lock = new ReentrantLock();private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();private Thread leader = null;private final Condition available = lock.newCondition();</code></pre><h3 id="构造方法-14"><a href="#构造方法-14" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public DelayQueue() {}</code></pre><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><pre><code>public void put(E e) {    offer(e);}</code></pre><pre><code>public boolean offer(E e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        q.offer(e);        if (q.peek() == e) {            leader = null;</code></pre><ul><li>// 通知最先等待的线程<pre><code>      available.signal();  }  return true;</code></pre>  } finally {<pre><code>  lock.unlock();</code></pre>  }<br>}</li></ul><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><ul><li>获取并移除队列首元素，如果队列没有过期元素则等待。<ul><li>第一次调用take时候由于队列空，所以调用（2)把当前线程放入available的条件队列等待，当执行offer并且添加的元素就是队首元素时候就会通知最先等待的线程激活，循环重新获取队首元素，这时候first假如不空，则调用getdelay方法看该元素海剩下多少时间就过期了，如果delay&lt;=0则说明已经过期，则直接出队返回。否则看leader是否为null，不为null则说明是其他线程也在执行take则把该线程放入条件队列，否则是当前线程执行的take方法，则调用(5) await直到剩余过期时间到（这期间该线程会释放锁，所以其他线程可以offer添加元素，也可以take阻塞自己)，剩余过期时间到后，该线程会重新竞争得到锁，重新进入循环。</li><li>（6)说明当前take返回了元素，如果当前队列还有元素则调用singal激活条件队列里面可能有的等待线程。leader那么为null，那么是第一次调用take获取过期元素的线程，第一次调用的线程调用设置等待时间的await方法等待数据过期，后面调用take的线程则调用await直到signal。</li></ul></li></ul><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        for (;;) {</code></pre><pre><code>- // 1)获取但不移除队首元素        E first = q.peek();        if (first == null)- // 2)无元素，则阻塞             available.await();        else {            long delay = first.getDelay(NANOSECONDS);- // 3)有元素，且已经过期，则移除            if (delay &lt;= 0)                return q.poll();            first = null; // don&#39;t retain ref while waiting- // 4)            if (leader != null)                available.await();            else {                Thread thisThread = Thread.currentThread();- // 5)                leader = thisThread;                try {</code></pre><ul><li>// 继续阻塞延迟的时间<pre><code>                  available.awaitNanos(delay);              } finally {                  if (leader == thisThread)                      leader = null;              }          }      }  }</code></pre>  } finally {<pre><code>  if (leader == null &amp;&amp; q.peek() != null)      available.signal();  lock.unlock();</code></pre>  }<br>}</li></ul><h3 id="peek-3"><a href="#peek-3" class="headerlink" title="peek"></a>peek</h3><h2 id="SynchronousQueue（只存储一个元素，阻塞队列，基于CAS"><a href="#SynchronousQueue（只存储一个元素，阻塞队列，基于CAS" class="headerlink" title="SynchronousQueue（只存储一个元素，阻塞队列，基于CAS)"></a>SynchronousQueue（只存储一个元素，阻塞队列，基于CAS)</h2><ul><li><p>实现了BlockingQueue，是一个阻塞队列。</p></li><li><p>一个只存储一个元素的的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入一直处于阻塞状态，吞吐量高于LinkedBlockingQueue。</p></li><li><p>SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。</p></li><li><p>// 如果为 true，则等待线程以 FIFO 的顺序竞争访问；否则顺序是未指定的。  </p></li><li><p>// SynchronousQueue<Integer> sc =new SynchronousQueue&lt;&gt;(true);//fair -  </p></li><li><p>SynchronousQueue<Integer> sc = new SynchronousQueue&lt;&gt;(); // 默认不指定的话是false，不公平的  </p></li></ul><h2 id="4-TransferQueue（特殊的BlockingQueue"><a href="#4-TransferQueue（特殊的BlockingQueue" class="headerlink" title="4)TransferQueue（特殊的BlockingQueue)"></a>4)TransferQueue（特殊的BlockingQueue)</h2><ul><li>生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费（不仅仅是添加到队列里就完事)</li><li>当我们不想生产者过度生产消息时，TransferQueue可能非常有用，可避免发生OutOfMemory错误。在这样的设计中，消费者的消费能力将决定生产者产生消息的速度。</li></ul><pre><code>public interface TransferQueue&lt;E&gt; extends BlockingQueue&lt;E&gt; {</code></pre><pre><code>    /**</code></pre><ul><li><ul><li>立即转交一个元素给消费者，如果此时队列没有消费者，那就false</li></ul></li><li>*/</li><li>boolean tryTransfer(E e);</li></ul><pre><code>    /**</code></pre><ul><li><ul><li>转交一个元素给消费者，如果此时队列没有消费者，那就阻塞</li></ul></li><li>*/</li><li>void transfer(E e) throws InterruptedException;</li></ul><pre><code>    /**</code></pre><ul><li><ul><li>带超时的tryTransfer</li></ul></li><li>*/</li><li>boolean tryTransfer(E e, long timeout, TimeUnit unit)</li><li>throws InterruptedException;</li></ul><pre><code>    /**</code></pre><ul><li><ul><li>是否有消费者等待接收数据，瞬时状态，不一定准</li></ul></li><li>*/</li><li>boolean hasWaitingConsumer();</li></ul><pre><code>    /**</code></pre><ul><li><ul><li>返回还有多少个等待的消费者，跟上面那个一样，都是一种瞬时状态，不一定准</li></ul></li><li>*/</li><li>int getWaitingConsumerCount();</li><li>}</li><li></li></ul><h3 id="LinkedTransferQueue（底层是链表，阻塞队列，无界同步队列"><a href="#LinkedTransferQueue（底层是链表，阻塞队列，无界同步队列" class="headerlink" title="LinkedTransferQueue（底层是链表，阻塞队列，无界同步队列)"></a>LinkedTransferQueue（底层是链表，阻塞队列，无界同步队列)</h3><ul><li>LinkedTransferQueue实现了TransferQueue接口，这个接口继承了BlockingQueue。之前BlockingQueue是队列满时再入队会阻塞，而这个接口实现的功能是队列不满时也可以阻塞，实现一种有阻塞的入队功能。</li><li>LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式)和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。</li><li></li></ul><h2 id="5-Queue实现类之间的区别"><a href="#5-Queue实现类之间的区别" class="headerlink" title="5)Queue实现类之间的区别"></a>5)Queue实现类之间的区别</h2><ul><li>非线程安全的：ArrayDeque、LinkedList、PriorityQueue</li><li>线程安全的：ConcurrentLinkedQueue、ConcurrentLinkedDeque、ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue</li><li>线程安全的又分为阻塞队列和非阻塞队列，阻塞队列提供了put、take等会阻塞当前线程的方法，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，也有offer、poll等阻塞一段时间候返回的方法；</li><li>非阻塞队列是使用CAS机制保证offer、poll等可以线程安全地入队出队，并且不需要加锁，不会阻塞当前线程，比如ConcurrentLinkedQueue、ConcurrentLinkedDeque。</li></ul><h3 id="ArrayBlockingQueue和LinkedBlockingQueue-区别"><a href="#ArrayBlockingQueue和LinkedBlockingQueue-区别" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue 区别"></a>ArrayBlockingQueue和LinkedBlockingQueue 区别</h3><ul><li><ol><li>队列中锁的实现不同</li></ol></li><li><p>ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；</p></li><li><p>LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock</p></li><li><ol start="2"><li>底层实现不同</li></ol></li><li><p>前者基于数组，后者基于链表</p></li><li><ol start="3"><li>队列边界不同</li></ol></li><li><p>ArrayBlockingQueue实现的队列中必须指定队列的大小，是有界队列</p></li><li><p>LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE，是无界队列</p></li><li></li></ul><h1 id="3-5-Map"><a href="#3-5-Map" class="headerlink" title="3.5 Map"></a>3.5 Map</h1><h2 id="HashMap（底层是数组-链表-红黑树，无序键值对集合，非线程安全"><a href="#HashMap（底层是数组-链表-红黑树，无序键值对集合，非线程安全" class="headerlink" title="HashMap（底层是数组+链表/红黑树，无序键值对集合，非线程安全)"></a>HashMap（底层是数组+链表/红黑树，无序键值对集合，非线程安全)</h2><ul><li><p>基于哈希表实现，链地址法。</p></li><li><p>loadFactor默认为0.75，threshold（阈)为12，并创建一个大小为16的Entry数组。</p></li><li><p>在遍历时是无序的，如需有序，建议使用TreeMap。</p></li><li><p>采用数组方式存储key、value构成的Entry对象，无容量限制。</p></li><li><p>基于key hash寻找Entry对象存放在数组中的位置，对于hash冲突采用链表/红黑树的方式来解决。</p></li><li><p>HashMap在插入元素时可能会扩大数组的容量，在扩大容量时需要重新计算hash，并复制对象到新的数组中。</p></li><li><p>是非线程安全的。</p></li><li><p>// 1. 哈希冲突时采用链表法的类，一个哈希桶多于8个元素改为TreeNode</p></li><li><p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</p></li><li><p>// 2. 哈希冲突时采用红黑树存储的类，一个哈希桶少于6个元素改为Node</p></li><li><p>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;</p></li><li><p>某个桶对应的链表过长的话搜索效率低，改为红黑树效率会提高。</p></li><li><p>为何按位与而不是取摸 hashmap的iterator读取时是否会读到另一个线程put的数据 红黑树；hashmap报ConcurrentModificationException的情况</p></li><li><p>Hash冲突中链表结构的数量大于8个，则调用树化转为红黑树结构，红黑树查找稍微快些；红黑树结构的数量小于6个时，则转为链表结构</p></li><li><p>如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长)；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了)，对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</p><ul><li>一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法)，Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</li><li>哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值)，即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</li></ul></li><li><p>Map#Entry（接口)</p></li></ul><pre><code>interface Entry&lt;K,V&gt; {    K getKey();    V getValue();    V setValue(V value);    boolean equals(Object o);    int hashCode();    public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() {        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)            (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());    }    public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() {        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)            (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue());    }    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) {        Objects.requireNonNull(cmp);        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)            (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());    }    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) {        Objects.requireNonNull(cmp);        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable)            (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue());    }}</code></pre><ul><li>HashMap#Node（Map.Entry的实现，链表的基本元素)</li></ul><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }    public final K getKey()        { return key; }    public final V getValue()      { return value; }    public final String toString() { return key + &quot;=&quot; + value; }    public final int hashCode() {        return Objects.hashCode(key) ^ Objects.hashCode(value);    }    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    public final boolean equals(Object o) {        if (o == this)            return true;        if (o instanceof Map.Entry) {            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        }        return false;    }}</code></pre><ul><li><p>HashMap#TreeNode（Map.Entry的实现，红黑树的基本元素)</p></li><li><p>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {<br>  TreeNode&lt;K,V&gt; parent;  // red-black tree links<br>  TreeNode&lt;K,V&gt; left;<br>  TreeNode&lt;K,V&gt; right;<br>  TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion<br>  boolean red;<br>  TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {</p><pre><code>  super(hash, key, val, next);</code></pre><p>  }</p></li><li><p>//…</p></li><li><p>}</p></li><li><p>LinkedHashMap#Entry</p></li><li><p>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {<br>  Entry&lt;K,V&gt; before, after;<br>  Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</p><pre><code>  super(hash, key, value, next);</code></pre><p>  }<br>}</p></li><li></li></ul><h3 id="成员变量-14"><a href="#成员变量-14" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><pre><code>/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table;/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;/** * The number of key-value mappings contained in this map. */transient int size;/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash).  This field is used to make iterators on Collection-views of * the HashMap fail-fast.  (See ConcurrentModificationException). */transient int modCount;/** * The next size value at which to resize (capacity * load factor). * * @serial */// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)</code></pre><pre><code>// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*装载因子)int threshold;/** * The load factor for the hash table. * * @serial */final float loadFactor;</code></pre><ul><li>AbstractMap</li><li>transient Set<K>        keySet;<br>transient Collection<V> values;</li></ul><h3 id="构造方法-15"><a href="#构造方法-15" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>注意哪怕是指定了初始容量，也不会直接初始化table，而是在第一次put时调用resize来初始化table，resize里会将threshold视为初始容量。</li></ul><pre><code>public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                           loadFactor);    this.loadFactor = loadFactor;</code></pre><pre><code>// 阈值为不小于容量的2的幂次    this.threshold = tableSizeFor(initialCapacity);}public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted}</code></pre><ul><li><h3 id="tableSizeFor（找到大于等于initialCapacity的最小的2的幂次以及原因"><a href="#tableSizeFor（找到大于等于initialCapacity的最小的2的幂次以及原因" class="headerlink" title="tableSizeFor（找到大于等于initialCapacity的最小的2的幂次以及原因)"></a>tableSizeFor（找到大于等于initialCapacity的最小的2的幂次以及原因)</h3></li></ul><pre><code>/** * Returns a power of two size for the given target capacity. */static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><ul><li><h3 id="hash（hash算法，算法比较高效、均匀"><a href="#hash（hash算法，算法比较高效、均匀" class="headerlink" title="hash（hash算法，算法比较高效、均匀)"></a>hash（hash算法，算法比较高效、均匀)</h3><ul><li>static final int hash(Object key) {<br>int h;<br>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}</li></ul></li><li><p>key的hash值高16位不变，低16位与高16位异或作为key的最终hash值。（h &gt;&gt;&gt; 16，表示无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变。) </p></li><li><p>保证了对象的hashCode的高16位的变化能反应到低16位中，</p></li></ul><h3 id="hash-to-index"><a href="#hash-to-index" class="headerlink" title="hash to index"></a>hash to index</h3><ul><li><p>如何根据hash值计算index？（put和get中的代码)</p></li><li><p>n = table.length;</p><ul><li><p>index = (n-1)&amp; hash;</p></li><li><p>当n总是2的n次方时，hash &amp; (n-1)运算等价于h%n，但是&amp;比%具有更高的效率。</p></li></ul></li></ul><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}</code></pre><ul><li><p>// onlyIfAbsent如果为true，只有在hashmap没有该key的时候才添加</p></li><li><p>// evict如果为false，hashmap为创建模式；只有在使用Map集合作为构造器创建LinkedHashMap或HashMap时才会为false。</p></li><li><p>// 这两个参数均为实现java8的新接口而设置</p></li><li><p>Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {<br>  return new Node&lt;&gt;(hash, key, value, next);<br>}</p></li><li><p>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</p><pre><code>         boolean evict) {</code></pre><p>  Node&lt;K,V&gt;[] tab; // table</p></li><li><p>Node&lt;K,V&gt; p;  // node pointer</p></li><li><p>int n, i; // n 为length, i 为 node index<br>  if ((tab = table) == null || (n = tab.length) == 0)</p><pre><code>  n = (tab = resize()).length;</code></pre><ul><li>// index处没有元素，则直接放入新节点<br>if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>  tab[i] = newNode(hash, key, value, null);<br>else {</li></ul></li><li><p>// index处有元素</p><pre><code>  Node&lt;K,V&gt; e; </code></pre></li><li><p>K k;</p><pre><code>  if (p.hash == hash &amp;&amp;      ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</code></pre></li><li><p>// 假如key是相同的，那么替换value即可</p><pre><code>      e = p;  else if (p instanceof TreeNode)</code></pre></li><li><p>// key不同，但如果p是红黑树根节点，那么将新节点放入红黑树</p><pre><code>      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);  else {</code></pre></li><li><p>// key不同，但如果p是链表头节点，那么判断链表中是否有该节点，如没有，则将新节点插入到链表尾部</p><pre><code>      for (int binCount = 0; ; ++binCount) {          if ((e = p.next) == null) {              p.next = newNode(hash, key, value, null);</code></pre><ul><li>// 插入后如果发现已经链表长度已经适合转为红黑树了，则转换<pre><code>          if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st              treeifyBin(tab, hash);          break;      }      // 链表中某元素key和key相同，则替换value即可      if (e.hash == hash &amp;&amp;          ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))          break;      p = e;  }</code></pre>  }<br>  if (e != null) { // existing mapping for key<pre><code>  V oldValue = e.value;  if (!onlyIfAbsent || oldValue == null)      e.value = value;  afterNodeAccess(e);  return oldValue;</code></pre>  }<br>}</li></ul><p>  ++modCount;</p></li><li><p>  if (++size &gt; threshold)</p><pre><code>  resize();</code></pre><p>  afterNodeInsertion(evict);<br>  return null;<br>}</p></li><li></li></ul><h3 id="扩容-resize"><a href="#扩容-resize" class="headerlink" title="扩容 resize"></a>扩容 resize</h3><ul><li><p>// 扩容函数，如果hash桶为空，初始化默认大小，否则双倍扩容</p></li><li><p>// 注意！！因为扩容为2的倍数，根据hash桶的计算方法，元素哈希值不变</p></li><li><p>// 所以元素在新的hash桶的下标，要不跟旧的hash桶下标一致，要不增加1倍。</p></li><li><p>cap：capacity</p></li><li><p>thr：threshold</p><ul><li>final Node&lt;K,V&gt;[] resize() {<br>Node&lt;K,V&gt;[] oldTab = table;<br>int oldCap = (oldTab == null) ? 0 : oldTab.length;<br>int oldThr = threshold;<br>int newCap, newThr = 0;<br>if (oldCap &gt; 0) {<br>  if (oldCap &gt;= MAXIMUM_CAPACITY) {<pre><code>  threshold = Integer.MAX_VALUE;  return oldTab;</code></pre>  }<br>  else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;<pre><code>       oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  newThr = oldThr &lt;&lt; 1; // double threshold</code></pre>}<br>else if (oldThr &gt; 0) // initial capacity was placed in threshold<br>  newCap = oldThr;<br>else {               // zero initial threshold signifies using defaults<br>  newCap = DEFAULT_INITIAL_CAPACITY;<br>  newThr = (int)(DEFAULT_LOAD_FACTOR <em> DEFAULT_INITIAL_CAPACITY);<br>}<br>if (newThr == 0) {<br>  float ft = (float)newCap </em> loadFactor;<br>  newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?<pre><code>        (int)ft : Integer.MAX_VALUE);</code></pre>}<br>threshold = newThr;<br>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];<br>table = newTab;</li></ul></li><li></li><li><p>if (oldTab != null) {<br>  for (int j = 0; j &lt; oldCap; ++j) {</p><pre><code>  Node&lt;K,V&gt; e;  if ((e = oldTab[j]) != null) {</code></pre></li><li><p>// j位置原本元素存在</p><pre><code>          oldTab[j] = null;          if (e.next == null)</code></pre></li><li><p>// 如果该位置没有形成链表，则再次计算index，放入新table</p></li><li><p>// 假设扩容前的table大小为2的N次方，有上述put方法解析可知，元素的table索引为其hash值的后N位确定</p></li><li><p>那么扩容后的table大小即为2的N+1次方，则其中元素的table索引为其hash值的后N+1位确定，比原来多了一位</p></li><li><p>因此，table中的元素只有两种情况：</p></li><li><p>元素hash值第N+1位为0：不需要进行位置调整</p><ul><li>元素hash值第N+1位为1：调整至原索引的两倍位置<pre><code>          newTab[e.hash &amp; (newCap - 1)] = e;      else if (e instanceof TreeNode)</code></pre></li></ul></li><li><p>// 如果该位置形成了红黑树，则split</p><pre><code>              ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);          else { // preserve order</code></pre></li><li><p>// 如果该位置形成了链表，则分成两个链表，分别放在0<del>oldCap,oldCap</del>oldCap*2位置处</p><pre><code>              Node&lt;K,V&gt; loHead = null, loTail = null;              Node&lt;K,V&gt; hiHead = null, hiTail = null;              Node&lt;K,V&gt; next;              do {                  next = e.next;</code></pre></li><li><p>// 用于确定元素hash值第N+1位是否为0：</p></li><li><p>若为0，则使用loHead与loTail，将元素移至新table的原索引处</p></li><li><p>若不为0，则使用hiHead与hiHead，将元素移至新table的两倍索引处</p><pre><code>                  if ((e.hash &amp; oldCap) == 0) {                      if (loTail == null)                          loHead = e;                      else                          loTail.next = e;                      loTail = e;                  }                  else {                      if (hiTail == null)                          hiHead = e;                      else                          hiTail.next = e;                      hiTail = e;                  }              } while ((e = next) != null);              if (loTail != null) {                  loTail.next = null;                  newTab[j] = loHead;              }              if (hiTail != null) {                  hiTail.next = null;                  newTab[j + oldCap] = hiHead;              }          }      }  }</code></pre><p>  }<br>  return newTab;<br>}</p><h3 id="get（O-logn"><a href="#get（O-logn" class="headerlink" title="get（O(logn))"></a>get（O(logn))</h3></li></ul><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><pre><code>- final Node&lt;K,V&gt; getNode(int hash, Object key) {Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;    (first = tab[(n - 1) &amp; hash]) != null) {</code></pre><ul><li>// table不为空，且hash对应index元素不为空</li><li>// 如果index位置就是我们要找的key，则直接返回<pre><code>  if (first.hash == hash &amp;&amp; // always check first node      ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))      return first;</code></pre></li><li>// 如果不是，则从链表或红黑树的角度继续找<pre><code>  if ((e = first.next) != null) {      if (first instanceof TreeNode)          return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);      do {          if (e.hash == hash &amp;&amp;              ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))              return e;      } while ((e = e.next) != null);  }</code></pre>  }<br>  return null;<br>}<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3></li></ul><pre><code>public V remove(Object key) {    Node&lt;K,V&gt; e;    return (e = removeNode(hash(key), key, null, false, true)) == null ?        null : e.value;}</code></pre><ul><li>value=null,matchValue=false,movable=true<ul><li>final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,<pre><code>                 boolean matchValue, boolean movable) {</code></pre>Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;<br>if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;<br>  (p = tab[index = (n - 1) &amp; hash]) != null) {<br>  Node&lt;K,V&gt; node = null, e; K k; V v;</li><li>// 1) 如果hash 对应index即为我们要找的key，则找到<br>  if (p.hash == hash &amp;&amp;<pre><code>  ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))  node = p;</code></pre></li><li>// 2) 从链表或红黑树的角度继续找<br>  else if ((e = p.next) != null) {<pre><code>  if (p instanceof TreeNode)      node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);  else {      do {          if (e.hash == hash &amp;&amp;              ((k = e.key) == key ||               (key != null &amp;&amp; key.equals(k)))) {              node = e;              break;          }          p = e;      } while ((e = e.next) != null);  }</code></pre>  }</li></ul></li><li>// 找到后，根据找到的位置不同 相应地进行删除<pre><code>  if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                       (value != null &amp;&amp; value.equals(v)))) {      if (node instanceof TreeNode)          ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);      else if (node == p)          tab[index] = node.next;      else          p.next = node.next;      ++modCount;      --size;      afterNodeRemoval(node);      return node;  }</code></pre>  }<br>  return null;<br>}</li></ul><h3 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h3><pre><code>public boolean containsKey(Object key) {    return getNode(hash(key), key) != null;}</code></pre><h3 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h3><pre><code>public boolean containsValue(Object value) {    Node&lt;K,V&gt;[] tab; V v;    if ((tab = table) != null &amp;&amp; size &gt; 0) {        for (int i = 0; i &lt; tab.length; ++i) {            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {                if ((v = e.value) == value ||                    (value != null &amp;&amp; value.equals(v)))                    return true;            }        }    }    return false;}</code></pre><ul><li><h3 id="a-链表转红黑树-treeifyBin"><a href="#a-链表转红黑树-treeifyBin" class="headerlink" title="a)链表转红黑树 treeifyBin"></a>a)链表转红黑树 treeifyBin</h3></li></ul><pre><code>/** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><ul><li>b)红黑树转链表 TreeNode#untreeify</li><li>final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {<br>  Node&lt;K,V&gt; hd = null, tl = null;<br>  for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {<pre><code>  Node&lt;K,V&gt; p = map.replacementNode(q, null);  if (tl == null)      hd = p;  else      tl.next = p;  tl = p;</code></pre>  }<br>  return hd;<br>}</li></ul><h3 id="c-红黑树-查找"><a href="#c-红黑树-查找" class="headerlink" title="c)红黑树 查找"></a>c)红黑树 查找</h3><ul><li>final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) {<br>  return ((parent != null) ? root() : this).find(h, k, null);<br>}</li></ul><pre><code>/** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) {    TreeNode&lt;K,V&gt; p = this;    do {        int ph, dir; K pk;        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;        if ((ph = p.hash) &gt; h)            p = pl;        else if (ph &lt; h)            p = pr;        else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))            return p;        else if (pl == null)            p = pr;        else if (pr == null)            p = pl;        else if ((kc != null ||                  (kc = comparableClassFor(k)) != null) &amp;&amp;                 (dir = compareComparables(kc, k, pk)) != 0)            p = (dir &lt; 0) ? pl : pr;        else if ((q = pr.find(h, k, kc)) != null)            return q;        else            p = pl;    } while (p != null);    return null;}</code></pre><h3 id="d-红黑树-添加"><a href="#d-红黑树-添加" class="headerlink" title="d)红黑树 添加"></a>d)红黑树 添加</h3><ul><li><p>final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</p><pre><code>                         int h, K k, V v) {</code></pre><p>  Class&lt;?&gt; kc = null;<br>  boolean searched = false;<br>  TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;<br>  for (TreeNode&lt;K,V&gt; p = root;;) {</p><pre><code>  int dir, ph; K pk;  if ((ph = p.hash) &gt; h)      dir = -1;  else if (ph &lt; h)      dir = 1;  else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))      return p;  else if ((kc == null &amp;&amp;            (kc = comparableClassFor(k)) == null) ||           (dir = compareComparables(kc, k, pk)) == 0) {      if (!searched) {          TreeNode&lt;K,V&gt; q, ch;          searched = true;          if (((ch = p.left) != null &amp;&amp;               (q = ch.find(h, k, kc)) != null) ||              ((ch = p.right) != null &amp;&amp;               (q = ch.find(h, k, kc)) != null))              return q;      }      dir = tieBreakOrder(k, pk);  }  TreeNode&lt;K,V&gt; xp = p;  if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {      Node&lt;K,V&gt; xpn = xp.next;      TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);      if (dir &lt;= 0)          xp.left = x;      else          xp.right = x;      xp.next = x;      x.parent = x.prev = xp;      if (xpn != null)          ((TreeNode&lt;K,V&gt;)xpn).prev = x;      moveRootToFront(tab, balanceInsertion(root, x));      return null;  }</code></pre><p>  }<br>}</p></li></ul><h3 id="e-红黑树-删除"><a href="#e-红黑树-删除" class="headerlink" title="e)红黑树 删除"></a>e)红黑树 删除</h3><pre><code>/** * Removes the given node, that must be present before this call. * This is messier than typical red-black deletion code because we * cannot swap the contents of an interior node with a leaf * successor that is pinned by &quot;next&quot; pointers that are accessible * independently during traversal. So instead we swap the tree * linkages. If the current tree appears to have too few nodes, * the bin is converted back to a plain bin. (The test triggers * somewhere between 2 and 6 nodes, depending on tree structure). */final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,                          boolean movable) {    int n;    if (tab == null || (n = tab.length) == 0)        return;    int index = (n - 1) &amp; hash;    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;    if (pred == null)        tab[index] = first = succ;    else        pred.next = succ;    if (succ != null)        succ.prev = pred;    if (first == null)        return;    if (root.parent != null)        root = root.root();    if (root == null || root.right == null ||        (rl = root.left) == null || rl.left == null) {        tab[index] = first.untreeify(map);  // too small        return;    }    TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;    if (pl != null &amp;&amp; pr != null) {        TreeNode&lt;K,V&gt; s = pr, sl;        while ((sl = s.left) != null) // find successor            s = sl;        boolean c = s.red; s.red = p.red; p.red = c; // swap colors        TreeNode&lt;K,V&gt; sr = s.right;        TreeNode&lt;K,V&gt; pp = p.parent;        if (s == pr) { // p was s&#39;s direct parent            p.parent = s;            s.right = p;        }        else {            TreeNode&lt;K,V&gt; sp = s.parent;            if ((p.parent = sp) != null) {                if (s == sp.left)                    sp.left = p;                else                    sp.right = p;            }            if ((s.right = pr) != null)                pr.parent = s;        }        p.left = null;        if ((p.right = sr) != null)            sr.parent = p;        if ((s.left = pl) != null)            pl.parent = s;        if ((s.parent = pp) == null)            root = s;        else if (p == pp.left)            pp.left = s;        else            pp.right = s;        if (sr != null)            replacement = sr;        else            replacement = p;    }    else if (pl != null)        replacement = pl;    else if (pr != null)        replacement = pr;    else        replacement = p;    if (replacement != p) {        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;        if (pp == null)            root = replacement;        else if (p == pp.left)            pp.left = replacement;        else            pp.right = replacement;        p.left = p.right = p.parent = null;    }    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);    if (replacement == p) {  // detach        TreeNode&lt;K,V&gt; pp = p.parent;        p.parent = null;        if (pp != null) {            if (p == pp.left)                pp.left = null;            else if (p == pp.right)                pp.right = null;        }    }    if (movable)        moveRootToFront(tab, r);}</code></pre><h3 id="f-红黑树-遍历"><a href="#f-红黑树-遍历" class="headerlink" title="f)红黑树 遍历"></a>f)红黑树 遍历</h3><ul><li>使用next指针，类似链表方式，便可遍历红黑树。</li></ul><h3 id="遍历（先迭代table，再迭代bucket-gt-链表-红黑树"><a href="#遍历（先迭代table，再迭代bucket-gt-链表-红黑树" class="headerlink" title="遍历（先迭代table，再迭代bucket-&gt;链表/红黑树)"></a>遍历（先迭代table，再迭代bucket-&gt;链表/红黑树)</h3><h4 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h4><ul><li>keySet().iterator()</li></ul><pre><code>public Set&lt;K&gt; keySet() {    Set&lt;K&gt; ks = keySet;    if (ks == null) {        ks = new KeySet();        keySet = ks;    }    return ks;}</code></pre><pre><code>final class KeySet extends AbstractSet&lt;K&gt; {    public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }}</code></pre><ul><li>KeyIterator实现了Iterator接口，并继承了HashIterator。前者仅适用于KeySet的迭代，后者适合所有基于HashMap的迭代。</li><li>HashMap#HashIterator</li></ul><pre><code>abstract class HashIterator {    Node&lt;K,V&gt; next;        // next entry to return    Node&lt;K,V&gt; current;     // current entry    int expectedModCount;  // for fast-fail    int index;             // current slot    HashIterator() {        expectedModCount = modCount;        Node&lt;K,V&gt;[] t = table;        current = next = null;        index = 0;        if (t != null &amp;&amp; size &gt; 0) { // advance to first entry            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        }    }    public final boolean hasNext() {        return next != null;    }    final Node&lt;K,V&gt; nextNode() {        Node&lt;K,V&gt;[] t;        Node&lt;K,V&gt; e = next;        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        if (e == null)            throw new NoSuchElementException();</code></pre><pre><code>// next的next为空的话，则继续遍历table，否则就返回next的next（链表或红黑树的下一个节点)        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);        }        return e;    }    public final void remove() {        Node&lt;K,V&gt; p = current;        if (p == null)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        current = null;        K key = p.key;        removeNode(hash(key), key, null, false, false);        expectedModCount = modCount;    }}</code></pre><ul><li>HashMap#KeyIterator</li></ul><pre><code>final class KeyIterator extends HashIterator    implements Iterator&lt;K&gt; {    public final K next() { return nextNode().key; }}</code></pre><h4 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h4><pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;}</code></pre><ul><li>使用的是该迭代器：</li></ul><pre><code>final class EntryIterator extends HashIterator    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {    public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }}</code></pre><h3 id="多线程环境下的问题"><a href="#多线程环境下的问题" class="headerlink" title="多线程环境下的问题"></a>多线程环境下的问题</h3><ul><li><p>1.8中hashmap的确不会因为多线程put导致死循环（1.7代码中会这样子)，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用ConcurrentHashMap。</p></li><li><p>数据丢失：当多线程put的时候，当index相同而又同时达到链表的末尾时，另一个线程put的数据会把之前线程put的数据覆盖掉，就会产生数据丢失。</p></li><li><p>if ((e = p.next) == null) {</p><pre><code>            p.next = newNode(hash, key, value, null);</code></pre></li><li><p>}</p></li></ul><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><ul><li>Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阈值)时，同样会自动增长。</li><li>Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。</li><li>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</li><li>Hashtable#Entry</li></ul><pre><code>private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Entry&lt;K,V&gt; next;    protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) {        this.hash = hash;        this.key =  key;        this.value = value;        this.next = next;    }    @SuppressWarnings(&quot;unchecked&quot;)    protected Object clone() {        return new Entry&lt;&gt;(hash, key, value,                              (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));    }    // Map.Entry Ops    public K getKey() {        return key;    }    public V getValue() {        return value;    }    public V setValue(V value) {        if (value == null)            throw new NullPointerException();        V oldValue = this.value;        this.value = value;        return oldValue;    }    public boolean equals(Object o) {        if (!(o instanceof Map.Entry))            return false;        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;        return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;           (value==null ? e.getValue()==null : value.equals(e.getValue()));    }    public int hashCode() {        return hash ^ Objects.hashCode(value);    }    public String toString() {        return key.toString()+&quot;=&quot;+value.toString();    }}</code></pre><h3 id="成员变量-15"><a href="#成员变量-15" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** * The hash table data. */private transient Entry&lt;?,?&gt;[] table;/** * The total number of entries in the hash table. */private transient int count;/** * The table is rehashed when its size exceeds this threshold.  (The * value of this field is (int)(capacity * loadFactor).) * * @serial */private int threshold;/** * The load factor for the hashtable. * * @serial */private float loadFactor;/** * The number of times this Hashtable has been structurally modified * Structural modifications are those that change the number of entries in * the Hashtable or otherwise modify its internal structure (e.g., * rehash).  This field is used to make iterators on Collection-views of * the Hashtable fail-fast.  (See ConcurrentModificationException). */private transient int modCount = 0;</code></pre><h3 id="构造方法-16"><a href="#构造方法-16" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public Hashtable(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                           initialCapacity);    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);    if (initialCapacity==0)        initialCapacity = 1;    this.loadFactor = loadFactor;    table = new Entry&lt;?,?&gt;[initialCapacity];    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);}/** * Constructs a new, empty hashtable with the specified initial capacity * and default load factor (0.75). * * @param     initialCapacity   the initial capacity of the hashtable. * @exception IllegalArgumentException if the initial capacity is less *              than zero. */public Hashtable(int initialCapacity) {    this(initialCapacity, 0.75f);}/** * Constructs a new, empty hashtable with a default initial capacity (11) * and load factor (0.75). */public Hashtable() {    this(11, 0.75f);}</code></pre><ul><li>11？</li><li>Hashtable 的容量增加逻辑是乘2+1，保证奇数。<ul><li>在应用数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数n，则至少有(n-1)/n数量的桶是利用不到的。<h3 id="hash-to-index-1"><a href="#hash-to-index-1" class="headerlink" title="hash to index"></a>hash to index</h3></li></ul></li><li>int hash = key.hashCode();<br>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</li><li>取与之后一定是一个非负数</li><li>0x7FFFFFFF is 0111 1111 1111 1111 1111 1111 1111 1111 : all 1 except the sign bit.</li><li>(hash &amp; 0x7FFFFFFF) will result in a positive integer.</li><li>(hash &amp; 0x7FFFFFFF) % tab.length will be in the range of the tab length.<h3 id="put（有锁-1"><a href="#put（有锁-1" class="headerlink" title="put（有锁)"></a>put（有锁)</h3></li></ul><pre><code>public synchronized V put(K key, V value) {    // Make sure the value is not null    if (value == null) {        throw new NullPointerException();    }    // Makes sure the key is not already in the hashtable.    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];    for(; entry != null ; entry = entry.next) {        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {            V old = entry.value;            entry.value = value;            return old;        }    }    addEntry(hash, key, value, index);    return null;}</code></pre><pre><code>private void addEntry(int hash, K key, V value, int index) {    modCount++;    Entry&lt;?,?&gt; tab[] = table;    if (count &gt;= threshold) {        // Rehash the table if the threshold is exceeded        rehash();        tab = table;        hash = key.hashCode();        index = (hash &amp; 0x7FFFFFFF) % tab.length;    }    // Creates the new entry.    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];    tab[index] = new Entry&lt;&gt;(hash, key, value, e);    count++;}</code></pre><h3 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容 rehash"></a>扩容 rehash</h3><pre><code>- protected void rehash() {int oldCapacity = table.length;Entry&lt;?,?&gt;[] oldMap = table;// overflow-conscious codeint newCapacity = (oldCapacity &lt;&lt; 1) + 1;if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {    if (oldCapacity == MAX_ARRAY_SIZE)        // Keep running with MAX_ARRAY_SIZE buckets        return;    newCapacity = MAX_ARRAY_SIZE;}Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];modCount++;threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);table = newMap;for (int i = oldCapacity ; i-- &gt; 0 ;) {    for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) {        Entry&lt;K,V&gt; e = old;        old = old.next;        // 所有元素重新散列        int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;        e.next = (Entry&lt;K,V&gt;)newMap[index];        newMap[index] = e;    }}</code></pre><p>}</p><h3 id="get（有锁"><a href="#get（有锁" class="headerlink" title="get（有锁)"></a>get（有锁)</h3><pre><code>public synchronized V get(Object key) {    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {            return (V)e.value;        }    }    return null;}</code></pre><ul><li><h3 id="remove（有锁"><a href="#remove（有锁" class="headerlink" title="remove（有锁)"></a>remove（有锁)</h3></li></ul><pre><code>public synchronized V remove(Object key) {    Entry&lt;?,?&gt; tab[] = table;    int hash = key.hashCode();    int index = (hash &amp; 0x7FFFFFFF) % tab.length;    @SuppressWarnings(&quot;unchecked&quot;)    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];    for(Entry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) {        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {            modCount++;            if (prev != null) {                prev.next = e.next;            } else {                tab[index] = e.next;            }            count--;            V oldValue = e.value;            e.value = null;            return oldValue;        }    }    return null;}</code></pre><ul><li><h2 id="LinkedHashMap（底层是-数组-链表-红黑树-环形双向链表，继承自HashMap"><a href="#LinkedHashMap（底层是-数组-链表-红黑树-环形双向链表，继承自HashMap" class="headerlink" title="LinkedHashMap（底层是(数组+链表/红黑树)+环形双向链表，继承自HashMap)"></a>LinkedHashMap（底层是(数组+链表/红黑树)+环形双向链表，继承自HashMap)</h2></li><li><p>LinkedHashMap是key键有序的HashMap的一种实现。它除了使用哈希表这个数据结构，使用环形双向链表来保证key的顺序。</p></li><li><p>HashMap是无序的，也就是说，迭代HashMap所得到的元素顺序并不是它们最初放置到HashMap的顺序。HashMap的这一缺点往往会造成诸多不便，因为在有些场景中，我们确需要用到一个可以保持插入顺序的Map。庆幸的是，JDK为我们解决了这个问题，它为HashMap提供了一个子类 —— LinkedHashMap。虽然LinkedHashMap增加了时间和空间上的开销，但是它通过维护一个额外的双向链表保证了迭代顺序。特别地，该迭代顺序可以是插入顺序，也可以是访问顺序。因此，根据链表中元素的顺序可以将LinkedHashMap分为：保持插入顺序的LinkedHashMap 和 保持访问顺序（LRU，get后调整链表序，最新获取的放在最后)的LinkedHashMap，其中LinkedHashMap的默认实现是按插入顺序排序的。</p></li><li><p>特点：</p></li><li><p>一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。</p><ul><li>但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性</li></ul></li><li><p>实现原理：</p></li><li><p>将所有Entry节点链入一个双向链表的HashMap。在LinkedHashMap中，所有put进来的Entry都保存在哈希表中，但由于它又额外定义了一个以head为头结点的双向链表，因此对于每次put进来Entry，除了将其保存到哈希表上外，还会将其插入到双向链表的尾部。</p></li><li><p>LinkedHashMap#Entry</p></li><li><p>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {<br>  Entry&lt;K,V&gt; before, after;<br>  Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</p><pre><code>  super(hash, key, value, next);</code></pre><p>  }<br>}</p></li></ul><h3 id="成员变量-16"><a href="#成员变量-16" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail;/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * * @serial */final boolean accessOrder;</code></pre><h3 id="构造方法-17"><a href="#构造方法-17" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public LinkedHashMap(int initialCapacity, float loadFactor) {    super(initialCapacity, loadFactor);    accessOrder = false;}/** * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance * with the specified initial capacity and a default load factor (0.75). * * @param  initialCapacity the initial capacity * @throws IllegalArgumentException if the initial capacity is negative */public LinkedHashMap(int initialCapacity) {    super(initialCapacity);    accessOrder = false;}/** * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance * with the default initial capacity (16) and load factor (0.75). */public LinkedHashMap() {    super();    accessOrder = false;}</code></pre><pre><code>/** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. * * @param  initialCapacity the initial capacity * @param  loadFactor      the load factor * @param  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order * @throws IllegalArgumentException if the initial capacity is negative *         or the load factor is nonpositive */public LinkedHashMap(int initialCapacity,                     float loadFactor,                     boolean accessOrder) {    super(initialCapacity, loadFactor);    this.accessOrder = accessOrder;}</code></pre><h3 id="put-2"><a href="#put-2" class="headerlink" title="put"></a>put</h3><ul><li>同HashMap，但重写了afterNodeInsertion。</li><li>void afterNodeInsertion(boolean evict) { // possibly remove eldest<br>  LinkedHashMap.Entry&lt;K,V&gt; first;<br>  if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {<pre><code>  K key = first.key;  removeNode(hash(key), key, null, false, true);</code></pre>  }<br>}</li><li>//可以自行重写该方法</li><li>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {<br>  return false;<br>}</li></ul><pre><code>public class LRUHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt;{</code></pre><pre><code>        private final int MAX_CACHE_SIZE;</code></pre><pre><code>        public BaseLRUCache(int cacheSize) {</code></pre><ul><li><p>super(cacheSize, 0.75f, true);</p></li><li><p>MAX_CACHE_SIZE = cacheSize;</p></li><li><p>}</p></li><li><p>@Override</p></li><li><p>protected boolean removeEldestEntry(Map.Entry eldest) {</p></li><li><p>return size() &gt; MAX_CACHE_SIZE;</p></li><li><p>}</p></li></ul><ul><li>}<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3></li></ul><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    if ((e = getNode(hash(key), key)) == null)        return null;    if (accessOrder)        afterNodeAccess(e);    return e.value;}</code></pre><ul><li>void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last<br>  LinkedHashMap.Entry&lt;K,V&gt; last;<br>  if (accessOrder &amp;&amp; (last = tail) != e) {<pre><code>  LinkedHashMap.Entry&lt;K,V&gt; p =      (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;  p.after = null;  if (b == null)      head = a;  else      b.after = a;  if (a != null)      a.before = b;  else      last = b;  if (last == null)      head = p;  else {      p.before = last;      last.after = p;  }  tail = p;  ++modCount;</code></pre>  }<br>}<h3 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3></li><li>同HashMap，但重写了afterNodeRemoval。</li><li>void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink<br>  LinkedHashMap.Entry&lt;K,V&gt; p =<pre><code>  (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</code></pre>  p.before = p.after = null;<br>  if (b == null)<pre><code>  head = a;</code></pre>  else<pre><code>  b.after = a;</code></pre>  if (a == null)<pre><code>  tail = b;</code></pre>  else<pre><code>  a.before = b;</code></pre>}</li></ul><h3 id="遍历（迭代环形双向链表"><a href="#遍历（迭代环形双向链表" class="headerlink" title="遍历（迭代环形双向链表)"></a>遍历（迭代环形双向链表)</h3><h4 id="entrySet-1"><a href="#entrySet-1" class="headerlink" title="entrySet"></a>entrySet</h4><pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;    return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;}</code></pre><ul><li>它使用的是该迭代器：</li></ul><pre><code>abstract class LinkedHashIterator {    LinkedHashMap.Entry&lt;K,V&gt; next;    LinkedHashMap.Entry&lt;K,V&gt; current;    int expectedModCount;    LinkedHashIterator() {        next = head;        expectedModCount = modCount;        current = null;    }    public final boolean hasNext() {        return next != null;    }    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() {        LinkedHashMap.Entry&lt;K,V&gt; e = next;        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        if (e == null)            throw new NoSuchElementException();        current = e;        next = e.after;        return e;    }    public final void remove() {        Node&lt;K,V&gt; p = current;        if (p == null)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        current = null;        K key = p.key;        removeNode(hash(key), key, null, false, false);        expectedModCount = modCount;    }}</code></pre><pre><code>final class LinkedEntryIterator extends LinkedHashIterator    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {    public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }}</code></pre><h2 id="TreeMap（底层是红黑树"><a href="#TreeMap（底层是红黑树" class="headerlink" title="TreeMap（底层是红黑树)"></a>TreeMap（底层是红黑树)</h2><ul><li><p>支持排序的Map实现。</p></li><li><p>基于红黑树实现，无容量限制。</p></li><li><p>是非线程安全的。</p></li><li><p>TreeMap是根据key进行排序的，它的排序和定位需要依赖比较器或覆写Comparable接口，也因此不需要key覆写hashCode方法和equals方法，就可以排除掉重复的key，而HashMap的key则需要通过覆写hashCode方法和equals方法来确保没有重复的key</p></li><li><p>TreeMap的查询、插入、删除效率均没有HashMap高，一般只有要对key排序时才使用TreeMap。</p></li><li><p>TreeMap的key不能为null，而HashMap的key可以为null。</p></li><li><p>TreeMap#Entry</p></li></ul><pre><code>static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    K key;    V value;    Entry&lt;K,V&gt; left;    Entry&lt;K,V&gt; right;    Entry&lt;K,V&gt; parent;    boolean color = BLACK;    /**     * Make a new cell with given key, value, and parent, and with     * {@code null} child links, and BLACK color.     */    Entry(K key, V value, Entry&lt;K,V&gt; parent) {        this.key = key;        this.value = value;        this.parent = parent;    }    /**     * Returns the key.     *     * @return the key     */    public K getKey() {        return key;    }    /**     * Returns the value associated with the key.     *     * @return the value associated with the key     */    public V getValue() {        return value;    }    /**     * Replaces the value currently associated with the key with the given     * value.     *     * @return the value associated with the key before this method was     *         called     */    public V setValue(V value) {        V oldValue = this.value;        this.value = value;        return oldValue;    }    public boolean equals(Object o) {        if (!(o instanceof Map.Entry))            return false;        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;        return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());    }    public int hashCode() {        int keyHash = (key==null ? 0 : key.hashCode());        int valueHash = (value==null ? 0 : value.hashCode());        return keyHash ^ valueHash;    }    public String toString() {        return key + &quot;=&quot; + value;    }}</code></pre><h3 id="成员变量-17"><a href="#成员变量-17" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>private final Comparator&lt;? super K&gt; comparator;private transient Entry&lt;K,V&gt; root;/** * The number of entries in the tree */private transient int size = 0;/** * The number of structural modifications to the tree. */private transient int modCount = 0;</code></pre><h3 id="构造方法-18"><a href="#构造方法-18" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public TreeMap() {    comparator = null;}</code></pre><pre><code>public TreeMap(Comparator&lt;? super K&gt; comparator) {    this.comparator = comparator;}</code></pre><h3 id="put-3"><a href="#put-3" class="headerlink" title="put"></a>put</h3><pre><code>public V put(K key, V value) {    Entry&lt;K,V&gt; t = root;    if (t == null) {        compare(key, key); // type (and possibly null) check        root = new Entry&lt;&gt;(key, value, null);        size = 1;        modCount++;        return null;    }    int cmp;    Entry&lt;K,V&gt; parent;    // split comparator and comparable paths    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) {        do {            parent = t;            cmp = cpr.compare(key, t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        } while (t != null);    }    else {        if (key == null)            throw new NullPointerException();        @SuppressWarnings(&quot;unchecked&quot;)            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;        do {            parent = t;            cmp = k.compareTo(t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        } while (t != null);    }    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);    if (cmp &lt; 0)        parent.left = e;    else        parent.right = e;    fixAfterInsertion(e);    size++;    modCount++;    return null;}</code></pre><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><pre><code>public V get(Object key) {    Entry&lt;K,V&gt; p = getEntry(key);    return (p==null ? null : p.value);}</code></pre><ul><li><p>final Entry&lt;K,V&gt; getEntry(Object key) {<br>  // Offload comparator-based version for sake of performance<br>  if (comparator != null)</p><pre><code>  return getEntryUsingComparator(key);</code></pre><p>  if (key == null)</p><pre><code>  throw new NullPointerException();</code></pre><p>  @SuppressWarnings(“unchecked”)</p><pre><code>  Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</code></pre><p>  Entry&lt;K,V&gt; p = root;<br>  while (p != null) {</p><pre><code>  int cmp = k.compareTo(p.key);  if (cmp &lt; 0)      p = p.left;  else if (cmp &gt; 0)      p = p.right;  else      return p;</code></pre><p>  }<br>  return null;<br>}</p></li><li><p>final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {<br>  @SuppressWarnings(“unchecked”)</p><pre><code>  K k = (K) key;</code></pre><p>  Comparator&lt;? super K&gt; cpr = comparator;<br>  if (cpr != null) {</p><pre><code>  Entry&lt;K,V&gt; p = root;  while (p != null) {      int cmp = cpr.compare(k, p.key);      if (cmp &lt; 0)          p = p.left;      else if (cmp &gt; 0)          p = p.right;      else          return p;  }</code></pre><p>  }<br>  return null;<br>}</p></li></ul><h3 id="remove-2"><a href="#remove-2" class="headerlink" title="remove"></a>remove</h3><pre><code>public V remove(Object key) {    Entry&lt;K,V&gt; p = getEntry(key);    if (p == null)        return null;    V oldValue = p.value;    deleteEntry(p);    return oldValue;}</code></pre><pre><code>private void deleteEntry(Entry&lt;K,V&gt; p) {    modCount++;    size--;    // If strictly internal, copy successor&#39;s element to p and then make p    // point to successor.    if (p.left != null &amp;&amp; p.right != null) {        Entry&lt;K,V&gt; s = successor(p);        p.key = s.key;        p.value = s.value;        p = s;    } // p has 2 children    // Start fixup at replacement node, if it exists.    Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);    if (replacement != null) {        // Link replacement to parent        replacement.parent = p.parent;        if (p.parent == null)            root = replacement;        else if (p == p.parent.left)            p.parent.left  = replacement;        else            p.parent.right = replacement;        // Null out links so they are OK to use by fixAfterDeletion.        p.left = p.right = p.parent = null;        // Fix replacement        if (p.color == BLACK)            fixAfterDeletion(replacement);    } else if (p.parent == null) { // return if we are the only node.        root = null;    } else { //  No children. Use self as phantom replacement and unlink.        if (p.color == BLACK)            fixAfterDeletion(p);        if (p.parent != null) {            if (p == p.parent.left)                p.parent.left = null;            else if (p == p.parent.right)                p.parent.right = null;            p.parent = null;        }    }}</code></pre><h3 id="containsKey-1"><a href="#containsKey-1" class="headerlink" title="containsKey"></a>containsKey</h3><pre><code>public boolean containsKey(Object key) {    return getEntry(key) != null;}</code></pre><h3 id="containsValue-1"><a href="#containsValue-1" class="headerlink" title="containsValue"></a>containsValue</h3><pre><code>public boolean containsValue(Object value) {    for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e))        if (valEquals(value, e.value))            return true;    return false;}</code></pre><ul><li><p>final Entry&lt;K,V&gt; getFirstEntry() {<br>  Entry&lt;K,V&gt; p = root;<br>  if (p != null)</p><pre><code>  while (p.left != null)      p = p.left;</code></pre><p>  return p;<br>}</p></li><li><p>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {<br>  if (t == null)</p><pre><code>  return null;</code></pre><p>  else if (t.right != null) {</p><pre><code>  Entry&lt;K,V&gt; p = t.right;  while (p.left != null)      p = p.left;  return p;</code></pre><p>  } else {</p><pre><code>  Entry&lt;K,V&gt; p = t.parent;  Entry&lt;K,V&gt; ch = t;  while (p != null &amp;&amp; ch == p.right) {      ch = p;      p = p.parent;  }  return p;</code></pre><p>  }<br>}</p><ul><li>static final boolean valEquals(Object o1, Object o2) {<br>return (o1==null ? o2==null : o1.equals(o2));<br>}</li></ul></li></ul><h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {    EntrySet es = entrySet;    return (es != null) ? es : (entrySet = new EntrySet());}</code></pre><pre><code>class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {    public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {        return new EntryIterator(getFirstEntry());    }</code></pre><ul><li>}</li></ul><pre><code>abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {    Entry&lt;K,V&gt; next;    Entry&lt;K,V&gt; lastReturned;    int expectedModCount;    PrivateEntryIterator(Entry&lt;K,V&gt; first) {        expectedModCount = modCount;        lastReturned = null;        next = first;    }    public final boolean hasNext() {        return next != null;    }    final Entry&lt;K,V&gt; nextEntry() {        Entry&lt;K,V&gt; e = next;        if (e == null)            throw new NoSuchElementException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        next = successor(e);        lastReturned = e;        return e;    }    final Entry&lt;K,V&gt; prevEntry() {        Entry&lt;K,V&gt; e = next;        if (e == null)            throw new NoSuchElementException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        next = predecessor(e);        lastReturned = e;        return e;    }    public void remove() {        if (lastReturned == null)            throw new IllegalStateException();        if (modCount != expectedModCount)            throw new ConcurrentModificationException();        // deleted entries are replaced by their successors        if (lastReturned.left != null &amp;&amp; lastReturned.right != null)            next = lastReturned;        deleteEntry(lastReturned);        expectedModCount = modCount;        lastReturned = null;    }}</code></pre><pre><code>final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {    EntryIterator(Entry&lt;K,V&gt; first) {        super(first);    }    public Map.Entry&lt;K,V&gt; next() {        return nextEntry();    }}</code></pre><ul><li><h2 id="ConcurrentHashMap（底层是数组-链表-红黑树，基于CAS-synchronized"><a href="#ConcurrentHashMap（底层是数组-链表-红黑树，基于CAS-synchronized" class="headerlink" title="ConcurrentHashMap（底层是数组+链表/红黑树，基于CAS+synchronized)"></a>ConcurrentHashMap（底层是数组+链表/红黑树，基于CAS+synchronized)</h2></li><li><p>JDK1.7前：分段锁</p></li><li><p>基于currentLevel划分出了多个Segment来对key-value进行存储，从而避免每次put操作都得锁住整个数组。在默认的情况下，最佳情况下可以允许16个线程并发无阻塞地操作集合对象，尽可能地减少并发时的阻塞现象。</p></li><li><p>put、remove会加锁。get和containsKey不会加锁。</p></li><li><p>计算size：在不加锁的情况下遍历所有的段，读取其count以及modCount，这两个属性都是volatile类型的，并进行统计，再遍历一次所有的段，比较modCount是否有改变。如有改变，则再尝试两次机上动作。</p></li><li><p>如执行了三次上述动作，仍然有问题，则遍历所有段，分别进行加锁，然后进行计算，计算完毕后释放所有锁，从而完成计算动作。</p></li><li><p>JDK1.8后：CAS+synchronized</p></li><li><p>bin是桶 bucket的意思</p></li><li><p>ConcurrentHashMap是延迟初始化的，只有在插入数据时，整个HashMap才被初始化为2的次方大小个桶（bin)，每个bin包含哈希值相同的一系列Node（一般含有0或1个Node)。每个bin的第一个Node作为这个bin的锁，Hash值为零或者负的将被忽略；</p></li><li><p>每个bin的第一个Node插入用到CAS原理，这是在ConcurrentHashMap中最常发生的操作，其余的插入、删除、替换操作对bin中的第一个Node加锁，进行操作</p></li><li><p>ConcurrentHashMap的size()函数一般比较少用，同时为了提高增删查改的效率，容器并未在内部保存一个size值，而且采用每次调用size()函数时累加各个bin中Node的个数计算得到，而且这一过程不加锁，即得到的size值不一定是最新的。</p></li><li></li><li><p>ConcurrentHashMap#Node</p></li><li><p>Node是最核心的内部类，它包装了key-value键值对，所有插入ConcurrentHashMap的数据都包装在这里面。它与HashMap中的定义很相似，但是但是有一些差别：它对value和next属性设置了volatile属性；’它不允许调用setValue方法直接改变Node的value域；它增加了find方法辅助map.get()方法。</p></li></ul><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    volatile V val; // value和next是volatile的    volatile Node&lt;K,V&gt; next;    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.val = val;        this.next = next;    }    public final K getKey()       { return key; }    public final V getValue()     { return val; }    public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }    public final String toString(){ return key + &quot;=&quot; + val; }    public final V setValue(V value) {        throw new UnsupportedOperationException();    }    public final boolean equals(Object o) {        Object k, v, u; Map.Entry&lt;?,?&gt; e;        return ((o instanceof Map.Entry) &amp;&amp;                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp;                (v = e.getValue()) != null &amp;&amp;                (k == key || k.equals(key)) &amp;&amp;                (v == (u = val) || v.equals(u)));    }    /**     * Virtualized support for map.get(); overridden in subclasses.     */    Node&lt;K,V&gt; find(int h, Object k) {        Node&lt;K,V&gt; e = this;        if (k != null) {            do {                K ek;                if (e.hash == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                    return e;            } while ((e = e.next) != null);        }        return null;    }}</code></pre><ul><li>ConcurrentHashMap#TreeNode</li><li>当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap继承自Node类，而并非HashMap中的继承自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。</li></ul><pre><code>static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    TreeNode&lt;K,V&gt; parent;  // red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion    boolean red;    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next,             TreeNode&lt;K,V&gt; parent) {        super(hash, key, val, next);        this.parent = parent;    }    Node&lt;K,V&gt; find(int h, Object k) {        return findTreeNode(h, k, null);    }    /**     * Returns the TreeNode (or null if not found) for the given key     * starting at given root.     */    final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) {        if (k != null) {            TreeNode&lt;K,V&gt; p = this;            do  {                int ph, dir; K pk; TreeNode&lt;K,V&gt; q;                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;                if ((ph = p.hash) &gt; h)                    p = pl;                else if (ph &lt; h)                    p = pr;                else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))                    return p;                else if (pl == null)                    p = pr;                else if (pr == null)                    p = pl;                else if ((kc != null ||                          (kc = comparableClassFor(k)) != null) &amp;&amp;                         (dir = compareComparables(kc, k, pk)) != 0)                    p = (dir &lt; 0) ? pl : pr;                else if ((q = pr.findTreeNode(h, k, kc)) != null)                    return q;                else                    p = pl;            } while (p != null);        }        return null;    }}</code></pre><ul><li><p>ConcurrentHashMap#TreeBin</p></li><li><p>这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。</p></li><li><p>可以看到在构造TreeBin节点时，仅仅指定了它的hash值为TREEBIN常量，这也就是个标识位；同时也看到我们熟悉的红黑树构造方法。</p></li></ul><pre><code>/** * TreeNodes used at the heads of bins. TreeBins do not hold user * keys or values, but instead point to list of TreeNodes and * their root. They also maintain a parasitic read-write lock * forcing writers (who hold bin lock) to wait for readers (who do * not) to complete before tree restructuring operations. */static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; {    TreeNode&lt;K,V&gt; root;    volatile TreeNode&lt;K,V&gt; first;    volatile Thread waiter;    volatile int lockState;    // values for lockState    static final int WRITER = 1; // set while holding write lock    static final int WAITER = 2; // set when waiting for write lock    static final int READER = 4; // increment value for setting read lock    /**     * Tie-breaking utility for ordering insertions when equal     * hashCodes and non-comparable. We don&#39;t require a total     * order, just a consistent insertion rule to maintain     * equivalence across rebalancings. Tie-breaking further than     * necessary simplifies testing a bit.     */    static int tieBreakOrder(Object a, Object b) {        int d;        if (a == null || b == null ||            (d = a.getClass().getName().             compareTo(b.getClass().getName())) == 0)            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?                 -1 : 1);        return d;    }    /**     * Creates bin with initial set of nodes headed by b.     */    TreeBin(TreeNode&lt;K,V&gt; b) {        super(TREEBIN, null, null, null);        this.first = b;        TreeNode&lt;K,V&gt; r = null;        for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) {            next = (TreeNode&lt;K,V&gt;)x.next;            x.left = x.right = null;            if (r == null) {                x.parent = null;                x.red = false;                r = x;            }            else {                K k = x.key;                int h = x.hash;                Class&lt;?&gt; kc = null;                for (TreeNode&lt;K,V&gt; p = r;;) {                    int dir, ph;                    K pk = p.key;                    if ((ph = p.hash) &gt; h)                        dir = -1;                    else if (ph &lt; h)                        dir = 1;                    else if ((kc == null &amp;&amp;                              (kc = comparableClassFor(k)) == null) ||                             (dir = compareComparables(kc, k, pk)) == 0)                        dir = tieBreakOrder(k, pk);                        TreeNode&lt;K,V&gt; xp = p;                    if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {                        x.parent = xp;                        if (dir &lt;= 0)                            xp.left = x;                        else                            xp.right = x;                        r = balanceInsertion(r, x);                        break;                    }                }            }        }        this.root = r;        assert checkInvariants(root);    }</code></pre><ul><li><p>}</p></li><li></li><li><p>ConcurrentHashMap#ForwardingNode</p></li></ul><pre><code>/** * A node inserted at head of bins during transfer operations. */static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) {        super(MOVED, null, null, null);        this.nextTable = tab;    }    Node&lt;K,V&gt; find(int h, Object k) {        // loop to avoid arbitrarily deep recursion on forwarding nodes        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {            Node&lt;K,V&gt; e; int n;            if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)                return null;            for (;;) {                int eh; K ek;                if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                    return e;                if (eh &lt; 0) {                    if (e instanceof ForwardingNode) {                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                        continue outer;                    }                    else                        return e.find(h, k);                }                if ((e = e.next) == null)                    return null;            }        }    }}</code></pre><ul><li></li><li><p>ConcurrentHashMap#ReservationNode</p></li></ul><pre><code>/** * A place-holder node used in computeIfAbsent and compute */static final class ReservationNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    ReservationNode() {        super(RESERVED, null, null, null);    }    Node&lt;K,V&gt; find(int h, Object k) {        return null;    }}</code></pre><ul><li><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3></li><li><p>hash值大于等于0，则是链表节点，Node</p></li><li><p>hash值为-1   MOVED，则是forwarding nodes，存储nextTable的引用。只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。</p></li><li><p>hash值为-2   TREEBIN，则是红黑树根，TreeBin类型</p></li><li><p>hash值为-3   RESERVED，则是reservation nodes，</p></li><li><p>static final int MOVED     = -1; // hash for forwarding nodes<br>static final int TREEBIN   = -2; // hash for roots of trees<br>static final int RESERVED  = -3; // hash for transient reservations</p></li><li></li></ul><h3 id="成员变量-18"><a href="#成员变量-18" class="headerlink" title="成员变量"></a>成员变量</h3><pre><code>/** * The largest possible table capacity.  This value must be * exactly 1&lt;&lt;30 to stay within Java array allocation and indexing * bounds for power of two table sizes, and is further required * because the top two bits of 32bit hash fields are used for * control purposes. */private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The default initial table capacity.  Must be a power of 2 * (i.e., at least 1) and at most MAXIMUM_CAPACITY. */private static final int DEFAULT_CAPACITY = 16;/** * The largest possible (non-power of two) array size. * Needed by toArray and related methods. */static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;/** * The load factor for this table. Overrides of this value in * constructors affect only the initial table capacity.  The * actual floating point value isn&#39;t normally used -- it is * simpler to use expressions such as {@code n - (n &gt;&gt;&gt; 2)} for * the associated resizing threshold. */private static final float LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2, and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * The value should be at least 4 * TREEIFY_THRESHOLD to avoid * conflicts between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;/** * Minimum number of rebinnings per transfer step. Ranges are * subdivided to allow multiple resizer threads.  This value * serves as a lower bound to avoid resizers encountering * excessive memory contention.  The value should be at least * DEFAULT_CAPACITY. */private static final int MIN_TRANSFER_STRIDE = 16;/** * The number of bits used for generation stamp in sizeCtl. * Must be at least 6 for 32bit arrays. */private static int RESIZE_STAMP_BITS = 16;/** * The maximum number of threads that can help resize. * Must fit in 32 - RESIZE_STAMP_BITS bits. */private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;/** * The bit shift for recording size stamp in sizeCtl. */private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;/* * Encodings for Node hash fields. See above for explanation. */static final int MOVED     = -1; // hash for forwarding nodesstatic final int TREEBIN   = -2; // hash for roots of treesstatic final int RESERVED  = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash/** Number of CPUS, to place bounds on some sizings */static final int NCPU = Runtime.getRuntime().availableProcessors();</code></pre><pre><code>/** * The array of bins. Lazily initialized upon first insertion. * Size is always a power of two. Accessed directly by iterators. */transient volatile Node&lt;K,V&gt;[] table;/** * The next table to use; non-null only while resizing. */private transient volatile Node&lt;K,V&gt;[] nextTable;/** * Base counter value, used mainly when there is no contention, * but also as a fallback during table initialization * races. Updated via CAS. */private transient volatile long baseCount;/** * Table initialization and resizing control.  When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads).  Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table.</code></pre><ul><li>负数代表正在进行初始化或扩容操作</li><li>-1代表正在初始化</li><li>-N 表示有N-1个线程正在进行扩容操作</li></ul><pre><code>正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，这一点类似于扩容阈值的概念。还后面可以看到，它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。 */private transient volatile int sizeCtl;/** * The next table index (plus one) to split while resizing. */private transient volatile int transferIndex;/** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */private transient volatile int cellsBusy;/** * Table of counter cells. When non-null, size is a power of 2. */private transient volatile CounterCell[] counterCells;// viewsprivate transient KeySetView&lt;K,V&gt; keySet;private transient ValuesView&lt;K,V&gt; values;private transient EntrySetView&lt;K,V&gt; entrySet;</code></pre><h3 id="构造方法-19"><a href="#构造方法-19" class="headerlink" title="构造方法"></a>构造方法</h3><pre><code>public ConcurrentHashMap() {}/** * Creates a new, empty map with an initial table size * accommodating the specified number of elements without the need * to dynamically resize. * * @param initialCapacity The implementation performs internal * sizing to accommodate this many elements. * @throws IllegalArgumentException if the initial capacity of * elements is negative */public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}/** * Creates a new map with the same mappings as the given map. * * @param m the map */public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.sizeCtl = DEFAULT_CAPACITY;    putAll(m);}/** * Creates a new, empty map with an initial table size based on * the given number of elements ({@code initialCapacity}) and * initial table density ({@code loadFactor}). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements, * given the specified load factor. * @param loadFactor the load factor (table density) for * establishing the initial table size * @throws IllegalArgumentException if the initial capacity of * elements is negative or the load factor is nonpositive * * @since 1.6 */public ConcurrentHashMap(int initialCapacity, float loadFactor) {    this(initialCapacity, loadFactor, 1);}/** * Creates a new, empty map with an initial table size based on * the given number of elements ({@code initialCapacity}), table * density ({@code loadFactor}), and number of concurrently * updating threads ({@code concurrencyLevel}). * * @param initialCapacity the initial capacity. The implementation * performs internal sizing to accommodate this many elements, * given the specified load factor. * @param loadFactor the load factor (table density) for * establishing the initial table size * @param concurrencyLevel the estimated number of concurrently * updating threads. The implementation may use this value as * a sizing hint. * @throws IllegalArgumentException if the initial capacity is * negative or the load factor or concurrencyLevel are * nonpositive */public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) {    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins        initialCapacity = concurrencyLevel;   // as estimated threads    long size = (long)(1.0 + (long)initialCapacity / loadFactor);    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?        MAXIMUM_CAPACITY : tableSizeFor((int)size);    this.sizeCtl = cap;}</code></pre><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><pre><code>private static final sun.misc.Unsafe U;</code></pre><ul><li>Unsafe类的几个CAS方法，可以原子性地修改对象的某个属性值</li></ul><pre><code>/** * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently * holding &lt;tt&gt;expected&lt;/tt&gt;. * @return &lt;tt&gt;true&lt;/tt&gt; if successful */public final native boolean compareAndSwapObject(Object o, long offset,                                                 Object expected,                                                 Object x);/** * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently * holding &lt;tt&gt;expected&lt;/tt&gt;. * @return &lt;tt&gt;true&lt;/tt&gt; if successful */public final native boolean compareAndSwapInt(Object o, long offset,                                              int expected,                                              int x);/** * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently * holding &lt;tt&gt;expected&lt;/tt&gt;. * @return &lt;tt&gt;true&lt;/tt&gt; if successful */public final native boolean compareAndSwapLong(Object o, long offset,                                               long expected,                                               long x);</code></pre><pre><code>/** * Fetches a reference value from a given Java variable, with volatile * load semantics. Otherwise identical to {@link #getObject(Object, long)} */public native Object getObjectVolatile(Object o, long offset);/** * Stores a reference value into a given Java variable, with * volatile store semantics. Otherwise identical to {@link #putObject(Object, long, Object)} */public native void    putObjectVolatile(Object o, long offset, Object x);</code></pre><ul><li>Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。<h3 id="三个核心方法"><a href="#三个核心方法" class="headerlink" title="三个核心方法"></a>三个核心方法</h3></li><li>ConcurrentHashMap定义了三个原子操作，用于对指定位置的节点进行操作。正是这些原子操作保证了ConcurrentHashMap的线程安全。    </li><li>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {<br>  return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);<br>}</li></ul><p>static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,<br>                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {<br>    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);<br>}</p><p>static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {<br>    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);<br>}</p><ul><li><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3></li><li><p>对于ConcurrentHashMap来说，调用它的构造方法仅仅是设置了一些参数而已。而整个table的初始化是在向ConcurrentHashMap中插入元素的时候发生的。如调用put、computeIfAbsent、compute、merge等方法的时候，调用时机是检查table==null。</p></li><li><p>初始化方法主要应用了关键属性sizeCtl 如果这个值&lt;0，表示其他线程正在进行初始化，就放弃这个操作。在这也可以看出ConcurrentHashMap的初始化只能由一个线程完成。如果获得了初始化权限，就用CAS方法将sizeCtl置为-1，防止其他线程进入。初始化数组后，将sizeCtl的值改为0.75*n。</p></li></ul><pre><code>private final Node&lt;K,V&gt;[] initTable() {    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) {        if ((sc = sizeCtl) &lt; 0)            Thread.yield(); // lost initialization race; just spin</code></pre><pre><code>- // 利用CAS方法把sizectl的值置为-1 表示本线程正在进行初始化      else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {        try {            if ((tab = table) == null || tab.length == 0) {                int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                @SuppressWarnings(&quot;unchecked&quot;)                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                table = tab = nt;- // 相当于0.75*n 设置一个扩容的阈值                  sc = n - (n &gt;&gt;&gt; 2);            }        } finally {            sizeCtl = sc;        }        break;    }}return tab;</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><ul><li><h3 id="spread（hash"><a href="#spread（hash" class="headerlink" title="spread（hash)"></a>spread（hash)</h3></li><li><p>h是某个对象的hashCode返回值</p><ul><li>static final int spread(int h) {<br>return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;<br>}</li></ul></li><li><p>static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash</p></li><li><p>类似于Hashtable+HashMap的hash实现，Hashtable中也是和一个魔法值取与，保证结果一定为正数；HashMap中也是将hashCode与其移动低n位的结果再取异或，保证了对象的hashCode的高16位的变化能反应到低16位中，</p><h3 id="size相关"><a href="#size相关" class="headerlink" title="size相关"></a>size相关</h3><h4 id="成员变量-19"><a href="#成员变量-19" class="headerlink" title="成员变量"></a>成员变量</h4></li><li><p>@sun.misc.Contended static final class CounterCell {<br>  volatile long value;<br>  CounterCell(long x) { value = x; }<br>}</p></li></ul><pre><code>/** * Base counter value, used mainly when there is no contention, * but also as a fallback during table initialization * races. Updated via CAS. */private transient volatile long baseCount;</code></pre><pre><code>/** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */private transient volatile int cellsBusy;/** * Table of counter cells. When non-null, size is a power of 2. */private transient volatile CounterCell[] counterCells;</code></pre><ul><li>每个CounterCell都对应一个bucket，CounterCell中的long值就是对应bucket的binCount。</li><li>计算总大小就是将所有bucket的binCount求和，而每个binCount都存储在CounterCell#value中，每当put或者remove时都会更新节点所在bucket对应的CounterCell#value。</li></ul><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><ul><li>没有直接返回baseCount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。</li></ul><pre><code>public int size() {    long n = sumCount();    return ((n &lt; 0L) ? 0 :            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :            (int)n);}</code></pre><ul><li><p>在baseCount基础上再加上所有counterCell的值求和。</p></li><li><p>而在addCount时，会先尝试CAS更新baseCount，如果有冲突，则再尝试CAS更新随机的一个counterCell中的value，这样求和就是正确的size了。</p></li><li><p>final long sumCount() {<br>  CounterCell[] as = counterCells; </p></li><li><p>CounterCell a;<br>  long sum = baseCount;<br>  if (as != null) {</p><pre><code>  for (int i = 0; i &lt; as.length; ++i) {      if ((a = as[i]) != null)</code></pre></li><li><p>// 所有counter的值求和  </p><pre><code>          sum += a.value;  }</code></pre><p>  }<br>  return sum;<br>}</p></li><li></li></ul><h3 id="put（若bucket第一个结点插入则使用CAS，否则加锁"><a href="#put（若bucket第一个结点插入则使用CAS，否则加锁" class="headerlink" title="put（若bucket第一个结点插入则使用CAS，否则加锁)"></a>put（若bucket第一个结点插入则使用CAS，否则加锁)</h3><pre><code>public V put(K key, V value) {    return putVal(key, value, false);}</code></pre><ul><li>整体流程就是首先定义不允许key或value为null的情况放入 。对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在table中的位置。<ul><li>1)如果这个位置是空的，那么直接放入，而且不需要加锁操作。</li><li>2)如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。</li></ul></li><li>a)如果是MOVED节点，则表示正在扩容，帮助进行扩容</li><li>b)如果是链表节点(hash &gt;=0),则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到hash值与key值都与新加入节点是一致的情况，则只需要更新value值即可。否则依次向后遍历，直到链表尾插入这个结点。 如果加入这个节点以后链表长度大于8，就把这个链表转换成红黑树。</li><li>c)如果这个节点的类型已经是树节点的话，直接调用树节点的插入方法进行插入新的值。<ul><li>3)addCount 增加计数值</li></ul></li></ul><pre><code>/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) {    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;</code></pre><ul><li>// 死循环，只有插入成功时才会跳出<br>  for (Node&lt;K,V&gt;[] tab = table;;) {<pre><code>  Node&lt;K,V&gt; f; int n, i, fh;  if (tab == null || (n = tab.length) == 0)</code></pre><ul><li>// table为空则初始化（延迟初始化)<pre><code>  tab = initTable();</code></pre>  else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</li></ul></li><li>// hash to index后正好为空，则CAS放入；如果失败那么进入下次循环继续尝试<pre><code>      if (casTabAt(tab, i, null,                   new Node&lt;K,V&gt;(hash, key, value, null)))          break;                   // no lock when adding to empty bin  }</code></pre></li><li>// 如果index处非空，且hash为MOVED（表示该节点是ForwardingNode)，则表示有其它线程正在扩容，则一起进行扩容操作。        </li><li>else if ((fh = f.hash) == MOVED)<pre><code>      tab = helpTransfer(tab, f);</code></pre></li><li>// 如果index处非空，且为链表节点或树节点<pre><code>  else {      V oldVal = null;</code></pre></li><li>// 对某个bucket上执行添加操作仅需要锁住第一个Node即可（可以保证不会多线程同时对某个bucket进行写入)<pre><code>      synchronized (f) {          if (tabAt(tab, i) == f) {</code></pre><ul><li>// 1) 如果是链表节点，那么插入到链表中<pre><code>          if (fh &gt;= 0) {</code></pre></li></ul></li><li>// binCount是该bucket中元素个数<pre><code>                  binCount = 1;                  for (Node&lt;K,V&gt; e = f;; ++binCount) {                      K ek;                      if (e.hash == hash &amp;&amp;                          ((ek = e.key) == key ||                           (ek != null &amp;&amp; key.equals(ek)))) {                          oldVal = e.val;                          if (!onlyIfAbsent)                              e.val = value;                          break;                      }                      Node&lt;K,V&gt; pred = e;                      if ((e = e.next) == null) {                          pred.next = new Node&lt;K,V&gt;(hash, key,                                                    value, null);                          break;                      }                  }              }</code></pre><ul><li>// 2)如果是红黑树树根，那么插入到红黑树中<pre><code>          else if (f instanceof TreeBin) {              Node&lt;K,V&gt; p;              binCount = 2;              if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                             value)) != null) {                  oldVal = p.val;                  if (!onlyIfAbsent)                      p.val = value;              }          }      }  }</code></pre></li></ul></li><li>// 插入节点/释放锁之后，如果大小合适调整为红黑树，那么将链表转为红黑树<pre><code>      if (binCount != 0) {          if (binCount &gt;= TREEIFY_THRESHOLD)              treeifyBin(tab, i);          if (oldVal != null)              return oldVal;          break;      }  }</code></pre>  }</li><li>// 将当前ConcurrentHashMap的元素数量+1 ，如果超过阈值，那么进行扩容<br>  addCount(1L, binCount);<br>  return null;<br>}<h3 id="treeifyBin（有锁，数组较小则扩容，较大则转为红黑树"><a href="#treeifyBin（有锁，数组较小则扩容，较大则转为红黑树" class="headerlink" title="treeifyBin（有锁，数组较小则扩容，较大则转为红黑树)"></a>treeifyBin（有锁，数组较小则扩容，较大则转为红黑树)</h3></li></ul><pre><code>private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {    Node&lt;K,V&gt; b; int n, sc;    if (tab != null) {</code></pre><pre><code>- // 如果数组长度n小于阈值MIN_TREEIFY_CAPACITY，默认是64，则会调用tryPresize方法把数组长度扩大到原来的两倍，并触发transfer方法，重新调整节点的位置    if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        tryPresize(n &lt;&lt; 1);    else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {        synchronized (b) {            if (tabAt(tab, index) == b) {                TreeNode&lt;K,V&gt; hd = null, tl = null;                for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {                    TreeNode&lt;K,V&gt; p =                        new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,                                          null, null);                    if ((p.prev = tl) == null)                        hd = p;                    else                        tl.next = p;                    tl = p;                }                setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));            }        }    }}</code></pre><p>}</p><ul><li>tryPreSize</li></ul><pre><code>/** * Tries to presize table to accommodate the given number of elements. * * @param size number of elements (doesn&#39;t need to be perfectly accurate) */private final void tryPresize(int size) {    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc = sizeCtl) &gt;= 0) {        Node&lt;K,V&gt;[] tab = table; int n;        if (tab == null || (n = tab.length) == 0) {            n = (sc &gt; c) ? sc : c;            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {                try {                    if (table == tab) {                        @SuppressWarnings(&quot;unchecked&quot;)                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; 2);                    }                } finally {                    sizeCtl = sc;                }            }        }        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)            break;        else if (tab == table) {            int rs = resizeStamp(n);            if (sc &lt; 0) {                Node&lt;K,V&gt;[] nt;                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            }            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);        }    }}</code></pre><ul><li><h3 id="扩容-4"><a href="#扩容-4" class="headerlink" title="扩容"></a>扩容</h3><h4 id="tryPresize"><a href="#tryPresize" class="headerlink" title="tryPresize"></a>tryPresize</h4></li><li><p>tryPresize在putAll以及treeifyBin中调用</p></li></ul><pre><code>private final void tryPresize(int size) {</code></pre><pre><code>- // c是扩容之后预计表的大小int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :    tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);int sc;</code></pre><ul><li>// 没有正在初始化或扩容<br>  while ((sc = sizeCtl) &gt;= 0) {<pre><code>  Node&lt;K,V&gt;[] tab = table; int n;  if (tab == null || (n = tab.length) == 0) {      n = (sc &gt; c) ? sc : c;</code></pre><ul><li>// 期间没有其他线程对表操作，则CAS将SIZECTL状态置为-1，表示正在进行初始化<pre><code>  if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {      try {          if (table == tab) {              @SuppressWarnings(&quot;unchecked&quot;)              Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];              table = nt;</code></pre></li><li>// 即0.75*n<pre><code>              sc = n - (n &gt;&gt;&gt; 2);          }      } finally {          sizeCtl = sc;      }  }</code></pre>  }</li></ul></li><li>// 若欲扩容值不大于原阈值，或现有容量&gt;=最值，则do nothing<pre><code>  else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)      break;</code></pre><ul><li>// table不为空，且在此期间其他线程未修改table<br>  else if (tab == table) {<pre><code>  int rs = resizeStamp(n);  if (sc &lt; 0) {      Node&lt;K,V&gt;[] nt;      if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||          sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||          transferIndex &lt;= 0)          break;      if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</code></pre></li><li>// 协助扩容<pre><code>          transfer(tab, nt);  }  else if (U.compareAndSwapInt(this, SIZECTL, sc,                               (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</code></pre></li></ul></li><li>// 发起扩容<pre><code>          transfer(tab, null);  }</code></pre>  }<br>}</li></ul><h4 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h4><ul><li>x=1，check=bucketCount</li></ul><pre><code>private final void addCount(long x, int check) {</code></pre><ul><li>// 计数值加x</li><li>// 利用CAS方法更新baseCount的值<br>  CounterCell[] as; long b, s;<br>  if ((as = counterCells) != null ||<pre><code>  !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {</code></pre></li><li>// 如果CAS更新baseCount失败或者counterCells不为空，那么尝试CAS更新当前线程的hashCode对应的bucket的value<pre><code>  CounterCell a; long v; int m;  boolean uncontended = true;</code></pre><ul><li>if (as == null || (m = as.length - 1) &lt; 0 ||<pre><code> (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended =   U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {</code></pre></li><li>// 如果两次CAS都失败了，那么调用fullAddCount方法<pre><code>  fullAddCount(x, uncontended);  return;</code></pre>  }<br>  if (check &lt;= 1)<pre><code>  return;</code></pre>  s = sumCount();<br>}</li></ul></li><li>// 以上与扩容无关，如果check值大于等于0 则需要检查是否需要进行扩容操作<br>  if (check &gt;= 0) {<pre><code>  Node&lt;K,V&gt;[] tab, nt; int n, sc;</code></pre></li><li>while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;<pre><code>         (n = tab.length) &lt; MAXIMUM_CAPACITY) {      int rs = resizeStamp(n);</code></pre></li><li>// 如果sizeCtl是小于0的，说明有其他线程正在执行扩容操作，nextTable一定不为空<pre><code>      if (sc &lt; 0) {          if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||              sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||              transferIndex &lt;= 0)              break;</code></pre></li><li>// 协助扩容<ul><li>if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))<pre><code>        transfer(tab, nt);}</code></pre></li><li>// 当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null <pre><code>else if (U.compareAndSwapInt(this, SIZECTL, sc,                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</code></pre></li></ul></li><li>// 发起扩容<pre><code>          transfer(tab, null);      s = sumCount();  }</code></pre>  }<br>}</li></ul><pre><code>private final void fullAddCount(long x, boolean wasUncontended) {    int h;    if ((h = ThreadLocalRandom.getProbe()) == 0) {        ThreadLocalRandom.localInit();      // force initialization        h = ThreadLocalRandom.getProbe();        wasUncontended = true;    }    boolean collide = false;                // True if last slot nonempty    for (;;) {        CounterCell[] as; CounterCell a; int n; long v;        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) {            if ((a = as[(n - 1) &amp; h]) == null) {                if (cellsBusy == 0) {            // Try to attach new Cell                    CounterCell r = new CounterCell(x); // Optimistic create                    if (cellsBusy == 0 &amp;&amp;                        U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {                        boolean created = false;                        try {               // Recheck under lock                            CounterCell[] rs; int m, j;                            if ((rs = counterCells) != null &amp;&amp;                                (m = rs.length) &gt; 0 &amp;&amp;                                rs[j = (m - 1) &amp; h] == null) {                                rs[j] = r;                                created = true;                            }                        } finally {                            cellsBusy = 0;                        }                        if (created)                            break;                        continue;           // Slot is now non-empty                    }                }                collide = false;            }            else if (!wasUncontended)       // CAS already known to fail                wasUncontended = true;      // Continue after rehash            else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))                break;            else if (counterCells != as || n &gt;= NCPU)                collide = false;            // At max size or stale            else if (!collide)                collide = true;            else if (cellsBusy == 0 &amp;&amp;                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {                try {                    if (counterCells == as) {// Expand table unless stale                        CounterCell[] rs = new CounterCell[n &lt;&lt; 1];                        for (int i = 0; i &lt; n; ++i)                            rs[i] = as[i];                        counterCells = rs;                    }                } finally {                    cellsBusy = 0;                }                collide = false;                continue;                   // Retry with expanded table            }            h = ThreadLocalRandom.advanceProbe(h);        }        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {            boolean init = false;            try {                           // Initialize table                if (counterCells == as) {                    CounterCell[] rs = new CounterCell[2];                    rs[h &amp; 1] = new CounterCell(x);                    counterCells = rs;                    init = true;                }            } finally {                cellsBusy = 0;            }            if (init)                break;        }        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))            break;                          // Fall back on using base    }}</code></pre><ul><li><h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4></li><li><p>当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。 整个扩容分为两部分：</p><ul><li>1)构建一个nextTable，大小为table的两倍。</li><li>2)把table的数据复制到nextTable中。</li></ul></li><li><p>这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但实现的复杂度也上升了一个台阶。</p></li><li><p>先看第一步，构建nextTable，毫无疑问，这个过程只能有单个线程进行nextTable的初始化。</p></li><li><p>通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍。</p></li><li><p>节点从table移动到nextTable，大体思想是遍历、复制的过程。</p><ul><li>1)首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个ForwardingNode实例fwd。</li><li>2)如果f==null，则在table中的i位置放入fwd，这个过程是采用</li></ul></li><li><p>Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。</p><ul><li>3)如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</li><li>4)如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。</li><li>5)遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。</li></ul></li><li><p>在多线程环境下，ConcurrentHashMap用两点来保证正确性：ForwardingNode和synchronized。当一个线程遍历到的节点如果是ForwardingNode，则继续往后遍历，如果不是，则将该节点加锁，防止其他线程进入，完成后设置ForwardingNode节点，以便要其他线程可以看到该节点已经处理过了，如此交叉进行，高效而又安全。</p></li></ul><pre><code>/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. */private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {    int n = tab.length, stride;    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range</code></pre><ul><li>// 扩容第一步，创建两倍长的数组nextTable，单线程执行</li><li>// initiating只能有一个线程进行构造nextTable，如果别的线程进入发现不为空就不用构造nextTable了<br>  if (nextTab == null) {            // initiating<pre><code>  try {      @SuppressWarnings(&quot;unchecked&quot;)      Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];      nextTab = nt;  } catch (Throwable ex) {      // try to cope with OOME      sizeCtl = Integer.MAX_VALUE;      return;  }  nextTable = nextTab;  // 原先扩容大小  transferIndex = n;</code></pre>  }</li><li>// 扩容第二步，把table的数据复制到nextTable中，多线程可以同时进行<br>  int nextn = nextTab.length;</li><li>// 构造一个ForwardingNode用于多线程之间的共同扩容情况<br>  ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);<br>  boolean advance = true;<br>  boolean finishing = false; // to ensure sweep before committing nextTab<br>  // 遍历每个节点</li><li>for (int i = 0, bound = 0;;) {<pre><code>  Node&lt;K,V&gt; f; int fh;  while (advance) {      int nextIndex, nextBound;      if (--i &gt;= bound || finishing)          advance = false;      else if ((nextIndex = transferIndex) &lt;= 0) {          i = -1;          advance = false;      }      else if (U.compareAndSwapInt               (this, TRANSFERINDEX, nextIndex,                nextBound = (nextIndex &gt; stride ?                             nextIndex - stride : 0))) {          bound = nextBound;          i = nextIndex - 1;          advance = false;      }  }</code></pre></li></ul><pre><code>// 得到一个i，i指向table中某一个尚未拷贝的bucket，下面的代码是对i对应的bucket进行拷贝，拷贝完后将bucket赋值为fwd（ForwadingNode)        //**************************************************************//</code></pre><ul><li>if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {<pre><code>      int sc;</code></pre></li><li>// 如果原table已经复制结束<pre><code>      if (finishing) {          nextTable = null;          table = nextTab;</code></pre><ul><li>// 修改扩容后的阀值，应该是现在容量的0.75倍<pre><code>      sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);      return;  }  // 采用CAS算法更新SizeCtl，减一，表示有一个新的线程参与到扩容操作</code></pre></li><li>if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {<pre><code>  if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)      return;  finishing = advance = true;  i = n; // recheck before commit</code></pre>  }<br>}<br>// CAS算法获取某一个数组的节点，为空就设为ForwordingNode<br>else if ((f = tabAt(tab, i)) == null)<br>  advance = casTabAt(tab, i, null, fwd);</li></ul></li><li>// 如果这个节点的hash值是MOVED，就表示这个节点是ForwordingNode节点，就表示这个节点已经被处理过了，直接跳过</li><li>else if ((fh = f.hash) == MOVED)<br>  advance = true; // already processed<br>else {<br>  synchronized (f) {<pre><code>  if (tabAt(tab, i) == f) {      Node&lt;K,V&gt; ln, hn;      if (fh &gt;= 0) {</code></pre></li><li>//如果这个节点的确是链表节点，则拆分为两个子链表，存储到nextTable相应的两个位置<pre><code>                  int runBit = fh &amp; n;                  Node&lt;K,V&gt; lastRun = f;                  for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {                      int b = p.hash &amp; n;                      if (b != runBit) {                          runBit = b;                          lastRun = p;                      }                  }                  if (runBit == 0) {                      ln = lastRun;                      hn = null;                  }                  else {                      hn = lastRun;                      ln = null;                  }</code></pre></li><li>// <pre><code>                  for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {                      int ph = p.hash; K pk = p.key; V pv = p.val;                      if ((ph &amp; n) == 0)                          ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                      else                          hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                  }</code></pre></li><li>// CAS存储在nextTable的i位置上<pre><code>                  setTabAt(nextTab, i, ln);</code></pre></li><li>// CAS存储在nextTable的i+n位置上<pre><code>                  setTabAt(nextTab, i + n, hn);</code></pre></li><li>// CAS在原table的i处设置forwordingNode节点，表示这个这个节点已经处理完毕<pre><code>                  setTabAt(tab, i, fwd);                  advance = true;              }</code></pre></li><li>// 如果这个节点是红黑树，则拆分为两颗子树，保存到nextTable相应的两个位置<pre><code>              else if (f instanceof TreeBin) {                  TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                  TreeNode&lt;K,V&gt; lo = null, loTail = null;                  TreeNode&lt;K,V&gt; hi = null, hiTail = null;                  int lc = 0, hc = 0;                  for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {                      int h = e.hash;                      TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                          (h, e.key, e.val, null, null);                      if ((h &amp; n) == 0) {                          if ((p.prev = loTail) == null)                              lo = p;                          else                              loTail.next = p;                          loTail = p;                          ++lc;                      }                      else {                          if ((p.prev = hiTail) == null)                              hi = p;                          else                              hiTail.next = p;                          hiTail = p;                          ++hc;                      }                  }</code></pre></li><li>// 如果拆分后的树的节点数量已经少于6个就需要重新转化为链表<pre><code>                  ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                      (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                  hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                      (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</code></pre></li><li>// CAS存储在nextTable的i位置上<pre><code>                  setTabAt(nextTab, i, ln);</code></pre></li><li>// CAS存储在nextTable的i+n位置上<pre><code>                  setTabAt(nextTab, i + n, hn);</code></pre></li><li>// CAS在原table的i处设置forwordingNode节点，表示这个这个节点已经处理完毕</li><li>setTabAt(tab, i, fwd);<pre><code>                  advance = true;              }          }      }  }</code></pre>  }<br>}</li></ul><h4 id="helpTransfer"><a href="#helpTransfer" class="headerlink" title="helpTransfer"></a>helpTransfer</h4><pre><code>- final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {Node&lt;K,V&gt;[] nextTab; int sc;if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;    (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {    int rs = resizeStamp(tab.length);    while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;           (sc = sizeCtl) &lt; 0) {        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||            sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)            break;        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {</code></pre><ul><li>// 调用扩容方法<pre><code>          transfer(tab, nextTab);          break;      }  }  return nextTab;</code></pre>  }<br>  return table;<br>}<h3 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent"></a>putIfAbsent</h3></li></ul><pre><code>public V putIfAbsent(K key, V value) {    return putVal(key, value, true);}</code></pre><h3 id="get（无锁"><a href="#get（无锁" class="headerlink" title="get（无锁)"></a>get（无锁)</h3><pre><code>public V get(Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h = spread(key.hashCode());    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (e = tabAt(tab, (n - 1) &amp; h)) != null) {        if ((eh = e.hash) == h) {</code></pre><ul><li>// bucket中第一个结点就是我们要找的，直接返回<pre><code>      if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))          return e.val;  }  else if (eh &lt; 0)</code></pre></li><li>// bucket中第一个结点是红黑树根，则调用find方法去找<pre><code>  return (p = e.find(h, key)) != null ? p.val : null;</code></pre></li><li>// bucket中第一个结点是链表，则遍历链表查找<pre><code>  while ((e = e.next) != null) {      if (e.hash == h &amp;&amp;          ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))          return e.val;  }</code></pre>  }<br>  return null;<br>}</li><li></li></ul><h3 id="untreeify（无锁"><a href="#untreeify（无锁" class="headerlink" title="untreeify（无锁)"></a>untreeify（无锁)</h3><ul><li>static &lt;K,V&gt; Node&lt;K,V&gt; untreeify(Node&lt;K,V&gt; b) {<br>  Node&lt;K,V&gt; hd = null, tl = null;<br>  for (Node&lt;K,V&gt; q = b; q != null; q = q.next) {<pre><code>  Node&lt;K,V&gt; p = new Node&lt;K,V&gt;(q.hash, q.key, q.val, null);  if (tl == null)      hd = p;  else      tl.next = p;  tl = p;</code></pre>  }<br>  return hd;<br>}</li></ul><h3 id="remove（有锁-1"><a href="#remove（有锁-1" class="headerlink" title="remove（有锁)"></a>remove（有锁)</h3><pre><code>public boolean remove(Object key, Object value) {    if (key == null)        throw new NullPointerException();    return value != null &amp;&amp; replaceNode(key, null, value) != null;}</code></pre><pre><code>/** * Implementation for the four public remove/replace methods: * Replaces node value with v, conditional upon match of cv if * non-null.  If resulting value is null, delete. */final V replaceNode(Object key, V value, Object cv) {    int hash = spread(key.hashCode());    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;        if (tab == null || (n = tab.length) == 0 ||            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)            break;        else if ((fh = f.hash) == MOVED)</code></pre><ul><li>// 如果已经被移动，那么就帮助进行扩容<pre><code>      tab = helpTransfer(tab, f);  else {      V oldVal = null;      boolean validated = false;      synchronized (f) {          if (tabAt(tab, i) == f) {</code></pre></li><li>// 如果是链表，则删除链表中的节点<pre><code>              if (fh &gt;= 0) {                  validated = true;                  for (Node&lt;K,V&gt; e = f, pred = null;;) {                      K ek;                      if (e.hash == hash &amp;&amp;                          ((ek = e.key) == key ||                           (ek != null &amp;&amp; key.equals(ek)))) {                          V ev = e.val;                          if (cv == null || cv == ev ||                              (ev != null &amp;&amp; cv.equals(ev))) {                              oldVal = ev;                              if (value != null)                                  e.val = value;                              else if (pred != null)                                  pred.next = e.next;                              else                                  setTabAt(tab, i, e.next);                          }                          break;                      }                      pred = e;                      if ((e = e.next) == null)                          break;                  }              }</code></pre><ul><li>// 如果是红黑树，则从红黑树中删除结点<pre><code>          else if (f instanceof TreeBin) {              validated = true;              TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;              TreeNode&lt;K,V&gt; r, p;              if ((r = t.root) != null &amp;&amp;                  (p = r.findTreeNode(hash, key, null)) != null) {                  V pv = p.val;                  if (cv == null || cv == pv ||                      (pv != null &amp;&amp; cv.equals(pv))) {                      oldVal = pv;                      if (value != null)                          p.val = value;                      else if (t.removeTreeNode(p))                          setTabAt(tab, i, untreeify(t.first));                  }              }          }      }  }  if (validated) {      if (oldVal != null) {          if (value == null)              addCount(-1L, -1);          return oldVal;      }      break;  }</code></pre>  }<br>}<br>return null;<br>}</li></ul></li></ul><h3 id="containsKey-2"><a href="#containsKey-2" class="headerlink" title="containsKey"></a>containsKey</h3><pre><code>public boolean containsKey(Object key) {    return get(key) != null;}</code></pre><h3 id="containsValue-2"><a href="#containsValue-2" class="headerlink" title="containsValue"></a>containsValue</h3><pre><code>public boolean containsValue(Object value) {    if (value == null)        throw new NullPointerException();    Node&lt;K,V&gt;[] t;    if ((t = table) != null) {        Traverser&lt;K,V&gt; it = new Traverser&lt;K,V&gt;(t, t.length, 0, t.length);        for (Node&lt;K,V&gt; p; (p = it.advance()) != null; ) {            V v;            if ((v = p.val) == value || (v != null &amp;&amp; value.equals(v)))                return true;        }    }    return false;}</code></pre><pre><code>static class Traverser&lt;K,V&gt; {    Node&lt;K,V&gt;[] tab;        // current table; updated if resized    Node&lt;K,V&gt; next;         // the next entry to use    TableStack&lt;K,V&gt; stack, spare; // to save/restore on ForwardingNodes    int index;              // index of bin to use next    int baseIndex;          // current index of initial table    int baseLimit;          // index bound for initial table    final int baseSize;     // initial table size    Traverser(Node&lt;K,V&gt;[] tab, int size, int index, int limit) {        this.tab = tab;        this.baseSize = size;        this.baseIndex = this.index = index;        this.baseLimit = limit;        this.next = null;    }    /**     * Advances if possible, returning next valid node, or null if none.     */    final Node&lt;K,V&gt; advance() {        Node&lt;K,V&gt; e;        if ((e = next) != null)            e = e.next;        for (;;) {            Node&lt;K,V&gt;[] t; int i, n;  // must use locals in checks            if (e != null)                return next = e;            if (baseIndex &gt;= baseLimit || (t = tab) == null ||                (n = t.length) &lt;= (i = index) || i &lt; 0)                return next = null;            if ((e = tabAt(t, i)) != null &amp;&amp; e.hash &lt; 0) {                if (e instanceof ForwardingNode) {                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    e = null;                    pushState(t, i, n);                    continue;                }                else if (e instanceof TreeBin)                    e = ((TreeBin&lt;K,V&gt;)e).first;                else                    e = null;            }            if (stack != null)                recoverState(n);            else if ((index = i + baseSize) &gt;= n)                index = ++baseIndex; // visit upper slots if present        }    }    /**     * Saves traversal state upon encountering a forwarding node.     */    private void pushState(Node&lt;K,V&gt;[] t, int i, int n) {        TableStack&lt;K,V&gt; s = spare;  // reuse if possible        if (s != null)            spare = s.next;        else            s = new TableStack&lt;K,V&gt;();        s.tab = t;        s.length = n;        s.index = i;        s.next = stack;        stack = s;    }    /**     * Possibly pops traversal state.     *     * @param n length of current table     */    private void recoverState(int n) {        TableStack&lt;K,V&gt; s; int len;        while ((s = stack) != null &amp;&amp; (index += (len = s.length)) &gt;= n) {            n = len;            index = s.index;            tab = s.tab;            s.tab = null;            TableStack&lt;K,V&gt; next = s.next;            s.next = spare; // save for reuse            stack = next;            spare = s;        }        if (s == null &amp;&amp; (index += baseSize) &gt;= n)            index = ++baseIndex;    }}</code></pre><h3 id="遍历-6"><a href="#遍历-6" class="headerlink" title="遍历"></a>遍历</h3><pre><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {    EntrySetView&lt;K,V&gt; es;    return (es = entrySet) != null ? es : (entrySet = new EntrySetView&lt;K,V&gt;(this));}</code></pre><pre><code>public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {    ConcurrentHashMap&lt;K,V&gt; m = map;    Node&lt;K,V&gt;[] t;    int f = (t = m.table) == null ? 0 : t.length;    return new EntryIterator&lt;K,V&gt;(t, f, 0, f, m);}</code></pre><pre><code>static class BaseIterator&lt;K,V&gt; extends Traverser&lt;K,V&gt; {    final ConcurrentHashMap&lt;K,V&gt; map;    Node&lt;K,V&gt; lastReturned;    BaseIterator(Node&lt;K,V&gt;[] tab, int size, int index, int limit,                ConcurrentHashMap&lt;K,V&gt; map) {        super(tab, size, index, limit);        this.map = map;        advance();    }    public final boolean hasNext() { return next != null; }    public final boolean hasMoreElements() { return next != null; }    public final void remove() {        Node&lt;K,V&gt; p;        if ((p = lastReturned) == null)            throw new IllegalStateException();        lastReturned = null;        map.replaceNode(p.key, null, null);    }}</code></pre><pre><code>static final class EntryIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt;    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {    EntryIterator(Node&lt;K,V&gt;[] tab, int index, int size, int limit,                  ConcurrentHashMap&lt;K,V&gt; map) {        super(tab, index, size, limit, map);    }    public final Map.Entry&lt;K,V&gt; next() {        Node&lt;K,V&gt; p;        if ((p = next) == null)            throw new NoSuchElementException();        K k = p.key;        V v = p.val;        lastReturned = p;        advance();        return new MapEntry&lt;K,V&gt;(k, v, map);    }}</code></pre><ul><li><h3 id="1-7-分段锁实现"><a href="#1-7-分段锁实现" class="headerlink" title="1.7 分段锁实现"></a>1.7 分段锁实现</h3></li><li><p>采用 Segment + HashEntry的方式进行实现</p></li></ul><h4 id="put-4"><a href="#put-4" class="headerlink" title="put"></a>put</h4><ul><li><p>当执行 put方法插入数据时，根据key的hash值，在 Segment数组中找到相应的位置，如果相应位置的 Segment还未初始化，则通过CAS进行赋值，接着执行 Segment对象的 put方法通过加锁机制插入数据，实现如下：</p></li><li><p>场景：线程A和线程B同时执行相同 Segment对象的 put方法</p></li><li><p>1、线程A执行 tryLock()方法成功获取锁，则把 HashEntry对象插入到相应的位置； </p></li><li><p>2、线程B获取锁失败，则执行 scanAndLockForPut()方法，在 scanAndLockForPut方法中，会通过重复执行 tryLock()方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行 tryLock()方法的次数超过上限时，则执行 lock()方法挂起线程B； </p></li><li><p>3、当线程A执行完插入操作时，会通过 unlock()方法释放锁，接着唤醒线程B继续执行；</p><h4 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h4></li><li><p>因为 ConcurrentHashMap是可以并发插入数据的，所以在准确计算元素时存在一定的难度，一般的思路是统计每个 Segment对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个 Segment的元素个数时，已经计算过的 Segment同时可能有数据的插入或则删除。</p></li><li><p>先采用不加锁的方式，连续计算元素的个数，最多计算3次： 1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的； 2、如果前后两次计算结果都不同，则给每个 Segment进行加锁，再计算一次元素的个数；</p></li><li></li></ul><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><ul><li><p>ConcurrentSkipListMap有几个ConcurrentHashMap 不能比拟的优点：</p></li><li><p>　　1、ConcurrentSkipListMap 的key是有序的。</p></li><li><p>2、ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap 的存取时间是log（N)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出他的优势。</p></li><li><p>SkipList 跳表：</p></li><li><p>跳表是平衡树的一种替代的数据结构，但是和红黑树不相同的是，跳表对于树的平衡的实现是基于一种随机化的算法的，这样也就是说跳表的插入和删除的工作是比较简单的。</p></li><li><p>下面来研究一下跳表的核心思想：</p></li><li><p>先从链表开始，如果是一个简单的链表，那么我们知道在链表中查找一个元素I的话，需要将整个链表遍历一次。</p></li><li></li><li><p>如果是说链表是排序的，并且节点中还存储了指向前面第二个节点的指针的话，那么在查找一个节点时，仅仅需要遍历N/2个节点即可。</p></li><li><p>这基本上就是跳表的核心思想，其实也是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。</p></li><li></li></ul><h2 id="Map实现类之间的区别"><a href="#Map实现类之间的区别" class="headerlink" title="Map实现类之间的区别"></a>Map实现类之间的区别</h2><h3 id="HashMap与ConcurrentHashMap区别"><a href="#HashMap与ConcurrentHashMap区别" class="headerlink" title="HashMap与ConcurrentHashMap区别"></a>HashMap与ConcurrentHashMap区别</h3><pre><code>- 1)前者允许key或value为null，后者不允许- 2)前者不是线程安全的，后者是</code></pre><h3 id="HashMap、TreeMap与LinkedHashMap区别"><a href="#HashMap、TreeMap与LinkedHashMap区别" class="headerlink" title="HashMap、TreeMap与LinkedHashMap区别"></a>HashMap、TreeMap与LinkedHashMap区别</h3><pre><code>- 1)HashMap遍历时，取得数据的顺序是完全随机的；</code></pre><ul><li>TreeMap可以按照自然顺序或Comparator排序；<ul><li>LinkedHashMap可以按照插入顺序或访问顺序排序，且get的效率（O(1))比TreeMap（O(logn))更高。</li><li>2)HashMap底层基于哈希表，数组+链表/红黑树；</li></ul></li><li>TreeMap底层基于红黑树</li><li>LinkedHashMap底层基于HashMap与环形双向链表<ul><li>3)就get和put效率而言，HashMap是最高的，LinkedHashMap次之，TreeMap最次。<h3 id="HashMap与Hashtable区别"><a href="#HashMap与Hashtable区别" class="headerlink" title="HashMap与Hashtable区别"></a>HashMap与Hashtable区别</h3></li><li><ol><li>扩容策略：Hashtable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂（<em>2+1)，而HashMap则要求一定为2的整数次幂（</em>2)。</li></ol></li></ul></li><li><ol start="2"><li>允许null：Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null)。</li></ol></li><li><ol start="3"><li>线程安全：前者不是线程安全的，后者是；<h3 id="ConcurrentHashMap、Collections-synchronizedMap与Hashtable的异同"><a href="#ConcurrentHashMap、Collections-synchronizedMap与Hashtable的异同" class="headerlink" title="ConcurrentHashMap、Collections.synchronizedMap与Hashtable的异同"></a>ConcurrentHashMap、Collections.synchronizedMap与Hashtable的异同</h3></li></ol></li><li>它们都是同步Map，但三者实现同步的机制不同；后两者都是简单地在方法上加synchronized实现的，锁的粒度较大；前者是基于CAS和synchronized实现的，锁的粒度较小，大部分都是lock-free无锁实现同步的。</li><li>ConcurrentHashMap还提供了putIfAbsent同步方法。</li></ul><h1 id="3-6-Collections"><a href="#3-6-Collections" class="headerlink" title="3.6 Collections"></a>3.6 Collections</h1><h2 id="同步集合包装"><a href="#同步集合包装" class="headerlink" title="同步集合包装"></a>同步集合包装</h2><pre><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {    return new SynchronizedMap&lt;&gt;(m);}</code></pre><pre><code>private static class SynchronizedMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Serializable {    private static final long serialVersionUID = 1978198479659022715L;    private final Map&lt;K,V&gt; m;     // Backing Map    final Object      mutex;        // Object on which to synchronize    SynchronizedMap(Map&lt;K,V&gt; m) {        this.m = Objects.requireNonNull(m);        mutex = this;    }    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {        this.m = m;        this.mutex = mutex;    }    public int size() {        synchronized (mutex) {return m.size();}    }    public boolean isEmpty() {        synchronized (mutex) {return m.isEmpty();}    }    public boolean containsKey(Object key) {        synchronized (mutex) {return m.containsKey(key);}    }    public boolean containsValue(Object value) {        synchronized (mutex) {return m.containsValue(value);}    }    public V get(Object key) {        synchronized (mutex) {return m.get(key);}    }    public V put(K key, V value) {        synchronized (mutex) {return m.put(key, value);}    }    public V remove(Object key) {        synchronized (mutex) {return m.remove(key);}    }    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {        synchronized (mutex) {m.putAll(map);}    }    public void clear() {        synchronized (mutex) {m.clear();}    }    private transient Set&lt;K&gt; keySet;    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    private transient Collection&lt;V&gt; values;    public Set&lt;K&gt; keySet() {        synchronized (mutex) {            if (keySet==null)                keySet = new SynchronizedSet&lt;&gt;(m.keySet(), mutex);            return keySet;        }    }    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {        synchronized (mutex) {            if (entrySet==null)                entrySet = new SynchronizedSet&lt;&gt;(m.entrySet(), mutex);            return entrySet;        }    }    public Collection&lt;V&gt; values() {        synchronized (mutex) {            if (values==null)                values = new SynchronizedCollection&lt;&gt;(m.values(), mutex);            return values;        }    }    public boolean equals(Object o) {        if (this == o)            return true;        synchronized (mutex) {return m.equals(o);}    }    public int hashCode() {        synchronized (mutex) {return m.hashCode();}    }    public String toString() {        synchronized (mutex) {return m.toString();}    }    // Override default methods in Map    @Override    public V getOrDefault(Object k, V defaultValue) {        synchronized (mutex) {return m.getOrDefault(k, defaultValue);}    }    @Override    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {        synchronized (mutex) {m.forEach(action);}    }    @Override    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {        synchronized (mutex) {m.replaceAll(function);}    }    @Override    public V putIfAbsent(K key, V value) {        synchronized (mutex) {return m.putIfAbsent(key, value);}    }    @Override    public boolean remove(Object key, Object value) {        synchronized (mutex) {return m.remove(key, value);}    }    @Override    public boolean replace(K key, V oldValue, V newValue) {        synchronized (mutex) {return m.replace(key, oldValue, newValue);}    }    @Override    public V replace(K key, V value) {        synchronized (mutex) {return m.replace(key, value);}    }    @Override    public V computeIfAbsent(K key,            Function&lt;? super K, ? extends V&gt; mappingFunction) {        synchronized (mutex) {return m.computeIfAbsent(key, mappingFunction);}    }    @Override    public V computeIfPresent(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        synchronized (mutex) {return m.computeIfPresent(key, remappingFunction);}    }    @Override    public V compute(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        synchronized (mutex) {return m.compute(key, remappingFunction);}    }    @Override    public V merge(K key, V value,            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {        synchronized (mutex) {return m.merge(key, value, remappingFunction);}    }    private void writeObject(ObjectOutputStream s) throws IOException {        synchronized (mutex) {s.defaultWriteObject();}    }}</code></pre><h2 id="不可变集合包装"><a href="#不可变集合包装" class="headerlink" title="不可变集合包装"></a>不可变集合包装</h2><pre><code>public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {    return new UnmodifiableMap&lt;&gt;(m);}</code></pre><pre><code>private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable {    private static final long serialVersionUID = -1034234728574286014L;    private final Map&lt;? extends K, ? extends V&gt; m;    UnmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) {        if (m==null)            throw new NullPointerException();        this.m = m;    }    public int size()                        {return m.size();}    public boolean isEmpty()                 {return m.isEmpty();}    public boolean containsKey(Object key)   {return m.containsKey(key);}    public boolean containsValue(Object val) {return m.containsValue(val);}    public V get(Object key)                 {return m.get(key);}    public V put(K key, V value) {        throw new UnsupportedOperationException();    }    public V remove(Object key) {        throw new UnsupportedOperationException();    }    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {        throw new UnsupportedOperationException();    }    public void clear() {        throw new UnsupportedOperationException();    }    private transient Set&lt;K&gt; keySet;    private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;    private transient Collection&lt;V&gt; values;    public Set&lt;K&gt; keySet() {        if (keySet==null)            keySet = unmodifiableSet(m.keySet());        return keySet;    }    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {        if (entrySet==null)            entrySet = new UnmodifiableEntrySet&lt;&gt;(m.entrySet());        return entrySet;    }    public Collection&lt;V&gt; values() {        if (values==null)            values = unmodifiableCollection(m.values());        return values;    }    public boolean equals(Object o) {return o == this || m.equals(o);}    public int hashCode()           {return m.hashCode();}    public String toString()        {return m.toString();}    // Override default methods in Map    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public V getOrDefault(Object k, V defaultValue) {        // Safe cast as we don&#39;t change the value        return ((Map&lt;K, V&gt;)m).getOrDefault(k, defaultValue);    }    @Override    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {        m.forEach(action);    }    @Override    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {        throw new UnsupportedOperationException();    }    @Override    public V putIfAbsent(K key, V value) {        throw new UnsupportedOperationException();    }    @Override    public boolean remove(Object key, Object value) {        throw new UnsupportedOperationException();    }    @Override    public boolean replace(K key, V oldValue, V newValue) {        throw new UnsupportedOperationException();    }    @Override    public V replace(K key, V value) {        throw new UnsupportedOperationException();    }    @Override    public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V computeIfPresent(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V compute(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V merge(K key, V value,            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }</code></pre><h2 id="空集合包装"><a href="#空集合包装" class="headerlink" title="空集合包装"></a>空集合包装</h2><pre><code>public static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() {    return (Map&lt;K,V&gt;) EMPTY_MAP;}</code></pre><pre><code>public static final Map EMPTY_MAP = new EmptyMap&lt;&gt;();</code></pre><pre><code>private static class EmptyMap&lt;K,V&gt;    extends AbstractMap&lt;K,V&gt;    implements Serializable{    private static final long serialVersionUID = 6428348081105594320L;    public int size()                          {return 0;}    public boolean isEmpty()                   {return true;}    public boolean containsKey(Object key)     {return false;}    public boolean containsValue(Object value) {return false;}    public V get(Object key)                   {return null;}    public Set&lt;K&gt; keySet()                     {return emptySet();}    public Collection&lt;V&gt; values()              {return emptySet();}    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()      {return emptySet();}    public boolean equals(Object o) {        return (o instanceof Map) &amp;&amp; ((Map&lt;?,?&gt;)o).isEmpty();    }    public int hashCode()                      {return 0;}    // Override default methods in Map    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public V getOrDefault(Object k, V defaultValue) {        return defaultValue;    }    @Override    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {        Objects.requireNonNull(action);    }    @Override    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {        Objects.requireNonNull(function);    }    @Override    public V putIfAbsent(K key, V value) {        throw new UnsupportedOperationException();    }    @Override    public boolean remove(Object key, Object value) {        throw new UnsupportedOperationException();    }    @Override    public boolean replace(K key, V oldValue, V newValue) {        throw new UnsupportedOperationException();    }    @Override    public V replace(K key, V value) {        throw new UnsupportedOperationException();    }    @Override    public V computeIfAbsent(K key,            Function&lt;? super K, ? extends V&gt; mappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V computeIfPresent(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V compute(K key,            BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }    @Override    public V merge(K key, V value,            BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {        throw new UnsupportedOperationException();    }    // Preserves singleton property    private Object readResolve() {        return EMPTY_MAP;    }}</code></pre><h2 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort"></a>Collections.sort</h2><pre><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {    list.sort(null);}</code></pre><ul><li>List#sort</li><li>default void sort(Comparator&lt;? super E&gt; c) {<br>  Object[] a = this.toArray();<br>  Arrays.sort(a, (Comparator) c);<br>  ListIterator<E> i = this.listIterator();<br>  for (Object e : a) {<pre><code>  i.next();  i.set((E) e);</code></pre>  }<br>}</li></ul><pre><code>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {    if (c == null) {        sort(a);    } else {        if (LegacyMergeSort.userRequested)            legacyMergeSort(a, c);        else            TimSort.sort(a, 0, a.length, c, null, 0, 0);    }}</code></pre><pre><code>public static void sort(Object[] a) {    if (LegacyMergeSort.userRequested)        legacyMergeSort(a);    else        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);}</code></pre><h3 id="1-7（TimSort"><a href="#1-7（TimSort" class="headerlink" title="1.7（TimSort)"></a>1.7（TimSort)</h3><ul><li>结合了归并排序和插入排序的混合算法，它基于一个简单的事实，实际中大部分数据都是部分有序（升序或降序)的。</li><li>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</li><li>综上述过程，Timsort算法的过程包括</li><li>（0)如果数组长度小于某个值，直接用二分插入排序算法<ul><li>（1)找到各个run，并入栈</li><li>（2)按规则合并run</li></ul></li></ul><pre><code>/** * Sorts the given range, using the given workspace array slice * for temp storage when possible. This method is designed to be * invoked from public methods (in class Arrays) after performing * any necessary array bounds checks and expanding parameters into * the required forms. * * @param a the array to be sorted * @param lo the index of the first element, inclusive, to be sorted * @param hi the index of the last element, exclusive, to be sorted * @param work a workspace array (slice) * @param workBase origin of usable space in work array * @param workLen usable size of work array * @since 1.8 */static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) {    assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;    int nRemaining  = hi - lo;    if (nRemaining &lt; 2)        return;  // Arrays of size 0 and 1 are always sorted    // If array is small, do a &quot;mini-TimSort&quot; with no merges    if (nRemaining &lt; MIN_MERGE) {        int initRunLen = countRunAndMakeAscending(a, lo, hi);        binarySort(a, lo, hi, lo + initRunLen);        return;    }    /**     * March over the array once, left to right, finding natural runs,     * extending short natural runs to minRun elements, and merging runs     * to maintain stack invariant.     */    ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);    int minRun = minRunLength(nRemaining);    do {        // Identify next run        int runLen = countRunAndMakeAscending(a, lo, hi);        // If run is short, extend to min(minRun, nRemaining)        if (runLen &lt; minRun) {            int force = nRemaining &lt;= minRun ? nRemaining : minRun;            binarySort(a, lo, lo + force, lo + runLen);            runLen = force;        }        // Push run onto pending-run stack, and maybe merge        ts.pushRun(lo, runLen);        ts.mergeCollapse();        // Advance to find next run        lo += runLen;        nRemaining -= runLen;    } while (nRemaining != 0);    // Merge all remaining runs to complete sort    assert lo == hi;    ts.mergeForceCollapse();    assert ts.stackSize == 1;}</code></pre><pre><code>/** * Creates a TimSort instance to maintain the state of an ongoing sort. * * @param a the array to be sorted * @param work a workspace array (slice) * @param workBase origin of usable space in work array * @param workLen usable size of work array */private ComparableTimSort(Object[] a, Object[] work, int workBase, int workLen) {    this.a = a;    // Allocate temp storage (which may be increased later if necessary)    int len = a.length;    int tlen = (len &lt; 2 * INITIAL_TMP_STORAGE_LENGTH) ?        len &gt;&gt;&gt; 1 : INITIAL_TMP_STORAGE_LENGTH;    if (work == null || workLen &lt; tlen || workBase + tlen &gt; work.length) {        tmp = new Object[tlen];        tmpBase = 0;        tmpLen = tlen;    }    else {        tmp = work;        tmpBase = workBase;        tmpLen = workLen;    }    /*     * Allocate runs-to-be-merged stack (which cannot be expanded).  The     * stack length requirements are described in listsort.txt.  The C     * version always uses the same stack length (85), but this was     * measured to be too expensive when sorting &quot;mid-sized&quot; arrays (e.g.,     * 100 elements) in Java.  Therefore, we use smaller (but sufficiently     * large) stack lengths for smaller arrays.  The &quot;magic numbers&quot; in the     * computation below must be changed if MIN_MERGE is decreased.  See     * the MIN_MERGE declaration above for more information.     * The maximum value of 49 allows for an array up to length     * Integer.MAX_VALUE-4, if array is filled by the worst case stack size     * increasing scenario. More explanations are given in section 4 of:     * http://envisage-project.eu/wp-content/uploads/2015/02/sorting.pdf     */    int stackLen = (len &lt;    120  ?  5 :                    len &lt;   1542  ? 10 :                    len &lt; 119151  ? 24 : 49);    runBase = new int[stackLen];    runLen = new int[stackLen];}</code></pre><h3 id="1-6-（MergeSort"><a href="#1-6-（MergeSort" class="headerlink" title="1.6 （MergeSort)"></a>1.6 （MergeSort)</h3><pre><code>private static void legacyMergeSort(Object[] a) {    Object[] aux = a.clone();    mergeSort(aux, a, 0, a.length, 0);}</code></pre><pre><code>private static void mergeSort(Object[] src,                              Object[] dest,                              int low,                              int high,                              int off) {    int length = high - low;    // 7    // Insertion sort on smallest arrays    if (length &lt; INSERTIONSORT_THRESHOLD) {        for (int i=low; i&lt;high; i++)            for (int j=i; j&gt;low &amp;&amp;                     ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)                swap(dest, j, j-1);        return;    }    // Recursively sort halves of dest into src    int destLow  = low;    int destHigh = high;    low  += off;    high += off;    int mid = (low + high) &gt;&gt;&gt; 1;    mergeSort(dest, src, low, mid, -off);    mergeSort(dest, src, mid, high, -off);    // If list is already sorted, just copy from src to dest.  This is an    // optimization that results in faster sorts for nearly ordered lists.    if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {        System.arraycopy(src, low, dest, destLow, length);        return;    }    // Merge sorted halves (now in src) into dest    for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {        if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)            dest[i] = src[p++];        else            dest[i] = src[q++];    }}</code></pre><h1 id="3-7-Fail-Fast"><a href="#3-7-Fail-Fast" class="headerlink" title="3.7 Fail-Fast"></a>3.7 Fail-Fast</h1><ul><li><p>在ArrayList,LinkedList,HashMap等等的内部实现增，删，改中我们总能看到modCount的身影，modCount字面意思就是修改次数，但为什么要记录modCount的修改次数呢？ </p></li><li><p>所有使用modCount属性集合的都是线程不安全的。</p></li><li><p>在一个迭代器初始的时候会赋予它调用这个迭代器的对象的modCount，在迭代器遍历的过程中，一旦发现这个对象的modCount和迭代器中存储的modCount不一样那就抛异常。</p></li><li><p>它是 java 集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast。</p><ul><li>例如 ：假设存在两个线程（线程 1、线程 2)，线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容)，那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。</li></ul></li><li><p>原因： 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</p></li><li><p>每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li><li><p>解决办法：使用线程安全的集合</p></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二、设计模式</title>
      <link href="//post/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>//post/%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="2-1-设计原则"><a href="#2-1-设计原则" class="headerlink" title="2.1 设计原则"></a>2.1 设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><ul><li>不要存在多于一个导致类变更的原因。</li><li>总结：一个类只负责一项职责。<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2></li><li>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>2.子类中可以增加自己特有的方法。</li><li>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参)要比父类方法的输入参数更宽松。</li><li>4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值)要比父类更严格。</li><li>总结：所有引用父类的地方必须能透明地使用其子类对象<h2 id="依赖倒置原则-面向接口编程"><a href="#依赖倒置原则-面向接口编程" class="headerlink" title="依赖倒置原则/面向接口编程"></a>依赖倒置原则/面向接口编程</h2></li><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2></li><li>使用多个专门的接口来替代一个统一的接口；</li><li>一个类对另一个类的依赖应建立在最小的接口上<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2></li><li>一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2></li><li>对扩展开放，对修改关闭</li><li>用抽象构建框架，用实现扩展细节<h2 id="合成复用原则-组合优于继承"><a href="#合成复用原则-组合优于继承" class="headerlink" title="合成复用原则/组合优于继承"></a>合成复用原则/组合优于继承</h2></li><li>尽量多使用组合和聚合，尽量少使用甚至不使用继承关系</li><li></li></ul><h1 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h1><ul><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h1 id="2-3-创建型设计模式"><a href="#2-3-创建型设计模式" class="headerlink" title="2.3 创建型设计模式"></a>2.3 创建型设计模式</h1><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>工厂模式分为简单（静态)工厂模式、工厂方法模式和抽象工厂模式</p><ul><li>1) 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。</li><li>2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。</li><li>3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。</li></ul></li><li><p>简单工厂模式：一个工厂类处于对产品类实例化调用的中心位置上,它决定那一个产品类应当被实例化,   </p></li><li><p>工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。 　　</p></li><li><p>一个抽象工厂类，可以派生出多个具体工厂类。 </p></li><li><p>　　          每个具体工厂类只能创建一个具体产品类的实例。</p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点"><a href="#适用场景与优缺点" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：<ul><li>1)客户不需要知道要使用的对象的创建过程</li><li>2)客户使用的对象存在变动的可能，或者根本就不知道使用哪一个具体对象</li></ul></li><li>缺点：</li><li>类的数量膨胀</li><li></li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li>抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 </li><li>　　          一个抽象工厂类，可以派生出多个具体工厂类。 </li><li>　　          每个具体工厂类可以创建多个具体产品类的实例。 </li><li>区别：          工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。</li><li>　　          工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。<h3 id="UML-1"><a href="#UML-1" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-1"><a href="#适用场景与优缺点-1" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)系统中有多个产品族，而系统一次只能消费其中一族产品</li><li>2)同属于同一个产品族的产品一起使用</li></ul></li><li></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul><li>通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例<h3 id="UML-2"><a href="#UML-2" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-2"><a href="#适用场景与优缺点-2" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>使用场景：</p><ul><li>1)当类只有一个实例且客户可以从一个众所周知的访问点 访问它</li><li>2)当这个唯一实例应该是通过子类化可扩展的，且客户应该无序更改代码就能使用一个扩展的实例</li></ul></li><li><p>优点：</p><ul><li>1)对唯一实例的受控访问</li><li>2)缩小命名空间，避免命名污染</li><li>3)允许单例有子类</li><li>4)允许可变数目的实例</li></ul></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//懒汉式，线程不安全</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Car instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。</span>    <span class="token comment" spellcheck="true">//懒汉式，线程安全</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Car instance <span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。</span>     <span class="token comment" spellcheck="true">//饿汉式</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Car instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法)导致类装载，这时候初始化instance显然没有达到lazy loading的效果。</p><pre class="line-numbers language-java"><code class="language-java">     <span class="token comment" spellcheck="true">//饿汉式变种</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Car instance<span class="token punctuation">;</span>     <span class="token keyword">static</span> <span class="token punctuation">{</span>         instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance。 <span class="token comment" spellcheck="true">//静态内部类（类的加载是线程安全的)</span>    <span class="token keyword">private</span> <span class="token keyword">static</span>  <span class="token keyword">class</span> <span class="token class-name">CarHolder</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Car instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span>     <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> CarHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别)：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果)，而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 枚举</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Car <span class="token punctuation">{</span>     INSTANCE<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双重校验锁</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Car instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span><span class="token punctuation">(</span>Car<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                     instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这个是第二种方式的升级版，俗称双重检查锁定。</li><li>所谓双重检查加锁机制，指的是：并不是每次进入getInstance方法都需要同步， 而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块， 这是第一重检查。进入同步块后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</li><li>双重检查加锁机制的实现会使用一个关键字volatile，它的意思是：被volatile</li><li>修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</li><li>说明：由于volatile关键字可能会屏蔽掉虚拟机中的一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用”双重检查加锁“机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>将一个复杂对象的创建和它的表示分离，使得同样的创建过程可以创建不同的表示。</p></li><li><p>Builder用于构建组件</p></li><li><p>Director负责装配</p></li><li><p>客户端通过Director来获得最终产品，Director与Builder打交道，持有一个Builder的引用。</p><h3 id="UML-3"><a href="#UML-3" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-3"><a href="#适用场景与优缺点-3" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)当创建复杂对象的算法应该独立于该对象的组成部分以及它们的赚个屁方式时</li><li>2)当构造过程必须允许被构造的对象有不同的表示时</li></ul></li><li><p>优点：</p><ul><li>1)可以改变一个对象的内部表示：Builder对象提供给Director一个构造产品的抽象接口，该接口使得Buildewr可以隐藏这个产品的表示和内部结构，同时隐藏了该产品是如何装配的。</li><li>2)将构造代码与表示代码分离</li><li>3)可以对构造过程进行更精细化的控制</li></ul></li><li></li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><h3 id="UML-4"><a href="#UML-4" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-4"><a href="#适用场景与优缺点-4" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>• 当要实例化的类是在运行时刻指定时，例如，通过动态装载；</p></li><li><p>• 为了避免创建一个与产品类层次平行的工厂类层次时；</p></li><li><p>• 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p></li><li><p>优点：</p></li><li><p>性能优良。原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p></li><li><p>缺点：</p></li><li><p>逃避构造函数的约束。这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</p></li><li></li></ul><h1 id="2-4-结构型设计模式"><a href="#2-4-结构型设计模式" class="headerlink" title="2.4 结构型设计模式"></a>2.4 结构型设计模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>将一个类的接口转换成客户所期待的另一种接口</p></li><li><p>Adapter可以组合+实现（对象适配器方式)，也可以继承+实现（类适配器方式)。但是继承不如组合好，因此尽量使用组合+实现。</p></li></ul><h3 id="UML-5"><a href="#UML-5" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-5"><a href="#适用场景与优缺点-5" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：<ul><li>1)想使用一个已存在的类，而它的接口不符合你的需求</li><li>2)想创建一个可以复用的类，该类可以与不相关的类或不可预见的类协同工作<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li></ul><ul><li><h3 id="UML-6"><a href="#UML-6" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-6"><a href="#适用场景与优缺点-6" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：<ul><li>1)在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责</li><li>2)处理那些可以撤销的职责</li><li>3)当不能通过生成子类的方法进行扩充时</li></ul></li><li>优点：<ul><li>1)比继承更加灵活，可以用添加和分离的方式，用装饰在运行时 增加和删除职责</li><li>2)避免在层次结构高的类有太多特征，用装饰器为其逐渐地添加功能</li></ul></li><li></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>代理可以分为静态代理和动态代理</p></li><li><p>为其他对象提供一种代理以控制对这个对象的访问。<br>为了一个对象提供一个替身或者占位符，以控制对这个对象的访问</p></li><li><ul><li>远程代理能够控制访问远程对象(RMI)</li></ul></li><li><ul><li>虚拟代理控制访问创建开销大的资源（先创建一个资源消耗较小的对象表示，真实对象只在需要时才会被创建)</li></ul></li><li><ul><li>保护代理基于权限控制对资源的访问<h3 id="UML-7"><a href="#UML-7" class="headerlink" title="UML"></a>UML</h3></li></ul></li></ul><h3 id="适用场景与优缺点-7"><a href="#适用场景与优缺点-7" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>使用场景：</p></li><li><p>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access)代理。 5、Cache代理。 6、防火墙（Firewall)代理。 7、同步化（Synchronization)代理。 8、智能引用（Smart Reference)代理。</p></li><li><p>优点：</p></li><li><p>1、职责清晰。 2、高扩展性。 3、智能化。</p></li><li><p>缺点： </p></li><li><p>1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </p></li><li><p>2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3></li><li><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这一接口使得子系统更加容易使用。</p></li><li><p>遵循了迪米特法则：</p></li></ul><pre><code>通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</code></pre><ul><li>外观模式就是一种较好的封装</li><li>是整体和子组件之间的关系，外部类不应该与一个类的子组件过多的接触，应该尽可能与整体打交道。</li></ul><h3 id="UML-8"><a href="#UML-8" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-8"><a href="#适用场景与优缺点-8" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：<ul><li>1)为一个复杂子系统提供一个简单接口</li><li>2)客户与抽象类的实现部分之间存在着很大的依赖性，引入Facade将子系统与客户解耦，提高了子系统的独立性和可移植性</li></ul></li><li>优点：<ul><li>1)对客户屏蔽了子系统组件，减少客户处理的对象数目，并使得子系统使用起来更加容易</li><li>2)实现了子系统与客户之间的松耦合</li><li>3)降低了大型软件中的编译依赖性</li><li>4)只是提供了一个访问子系统的统一入口，并不影响客户直接使用子系统<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li><li>处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立地扩展，在抽象层建立关联。</li><li>一个维度的父类持有另一个维度的接口的引用（使用组合代替了继承)</li></ul><ul><li>希望有一个Bridge类来将类型维度和品牌维度连接起来，这样增加类型和增加品牌不会影响对方。</li><li>两种变化以上的情况应该考虑桥接模式<h3 id="UML-9"><a href="#UML-9" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-9"><a href="#适用场景与优缺点-9" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：</li><li>1．如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li><li>2．设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。</li><li>3．一个构件有多于一个的抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li><li>4．虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li></ul><ul><li><h2 id="组合模式（树形结构"><a href="#组合模式（树形结构" class="headerlink" title="组合模式（树形结构)"></a>组合模式（树形结构)</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3></li><li><p>无子节点的是叶子，有子节点的是容器</p></li><li><p>叶子和容器的共同点抽象为Component组件</p></li><li><p>每个容器持有一个Component的List引用，包含它的所有子节点。</p><h3 id="UML-10"><a href="#UML-10" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-10"><a href="#适用场景与优缺点-10" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：<ul><li>1)想表示对象的层次结构</li><li>2)希望客户忽略组合对象与单一对象的不同，用户将统一使用组合结构中的所有对象</li></ul></li><li>优点：<ul><li>1)定义了包含基本对象和组合对象的类层次结构</li><li>2)简化客户代码，客户可以一致地使用组合结构和单个对象</li><li>3)更容易添加新类型的组件<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li></ul><ul><li>将相同部分放在一个类中，工厂持有一个Map，可以创建相同部分，如果已持有那么直接返回。</li><li>不同部分单独设计一个类，可以作为相同部分类的方法的参数传入</li><li>将一个对象拆成两部分（成员变量拆成两部分)：相同部分和不同部分。相同部分使用工厂创建，进行共享；不同部分作为参数传入<h3 id="UML-11"><a href="#UML-11" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-11"><a href="#适用场景与优缺点-11" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：池化 内存池 数据库连接池 线程池</p></li><li><p>优点：</p><ul><li>1)极大减少内存中对象的数量</li><li>2)相同或相似对象内存中只存一份，节省内存</li><li>3)外部状态相对独立，不影响内部状态</li></ul></li><li><p>缺点：</p><ul><li>1)模式较复杂，使程序逻辑复杂化</li><li>2)读取外部状态使运行时间变长，用时间换取了空间</li></ul></li><li></li></ul><h1 id="2-5-行为型设计模式"><a href="#2-5-行为型设计模式" class="headerlink" title="2.5 行为型设计模式"></a>2.5 行为型设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><ul><li>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。</li><li>环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。</li><li>抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。</li><li>具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。<h3 id="UML-12"><a href="#UML-12" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-12"><a href="#适用场景与优缺点-12" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li>适用场景：</li><li>实现某一个功能由多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能</li><li>优点：<ul><li>1)Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。</li><li>2)提供了可以替换继承关系的方法</li><li>3)消除if-else<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li></ul><h3 id="UML-13"><a href="#UML-13" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-13"><a href="#适用场景与优缺点-13" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)一次性实现一个算法的不变部分，并将可变部分留给子类来实现</li><li>2)个子类中公共的行为提取出来并集中到一个公共父类中以避免重复</li><li>3)控制子类扩展，只允许在某些点进行扩展</li></ul></li><li><p>优点：</p><ul><li>1)在一个父类中形式化地定义算法，由它的子类实现细节的处理</li><li>2)是一个代码复用的基本技术</li><li>3)控制翻转（好莱坞原则)，父类调用子类的操作，通过对子类的扩展来增加新的行为，符合开闭原则<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li><li><p>也称为发布-订阅模式。</p></li><li><p>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。</p></li><li><p>与Reactor模式非常类似，不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联。</p><h3 id="UML-14"><a href="#UML-14" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-14"><a href="#适用场景与优缺点-14" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)当一个对象的改变需要通知其他对象，而且它不知道具体有多少个对象有待通知时</li><li>2)当一个抽象模型有两个方面，其中一个方面依赖于另一方面，将这二者封装在独立的对象中国以使它们可以独立地改变和服用</li></ul></li><li><p>优点：</p><ul><li>1)独立地改变目标和观察者，解耦</li><li>2)是吸纳表示层和数据逻辑层分离（表示层是观察者，逻辑层是主题)<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li><li><p>找到一种不同容器的统一的遍历方式，定义一个接口，所有可以提供遍历方式的容器都实现这个接口，返回一个迭代器，然后所有的迭代器的接口是一致的。</p></li><li><p>所有的容器都可以通过iterator方法返回一个迭代器Iterator，这个迭代器对外暴露的接口是一致的，因此可以保证对所有的容器遍历方法是一致的，仅需得到这个容器的迭代器即可，而各个容器对迭代器的实现是不同的，即遍历方式是不同的。迭代器模式可以将各个容器的遍历方式的调用方式统一起来，隐藏了内部遍历的实现细节。</p><h3 id="UML-15"><a href="#UML-15" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-15"><a href="#适用场景与优缺点-15" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)访问一个聚合对象的内容而无需暴露它的内部表示</li><li>2)需要为聚合对象提供多种遍历方式</li><li>3)为遍历不同的聚合结构提供一个统一的接口</li></ul></li><li><p>优点：</p><ul><li>1)支持以不同的方式遍历一个聚合对象</li><li>2)简化聚合接口</li><li>3)方便添加新的聚合类和迭代器类<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li><li><p>使多个处理器对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些处理器对象连成一条链，并沿这条链传递请求，直到有一个处理器对象处理它为止</p><h3 id="UML-16"><a href="#UML-16" class="headerlink" title="UML"></a>UML</h3></li></ul><h3 id="适用场景与优缺点-16"><a href="#适用场景与优缺点-16" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)有多个处理器对象可以处理一个请求，哪个处理器对象处理该请求在运行时动态确定</li><li>2)在不明确指定接收者的情况下，向多个处理器对象中的一个提交请求</li><li>3)可以动态指定一组处理器对象处理请求</li></ul></li><li><p>优点：</p><ul><li>1)降低耦合，使得 请求发送者无需知道是哪个处理器对象处理请求</li><li>2)简化对象的相互连接</li><li>3)增强了给对象指派责任的灵活性</li><li>4)方便添加新的请求处理类<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li><li><p>命令模式把一个请求或者操作封装到一个对象中，把发出命令的责任和执行命令的责任分割开，委派给不同的对象，可降低行为请求者与行为实现者之间耦合度。从使用角度来看就是请求者把接口实现类作为参数传给使用者，使用者直接调用这个接口的方法，而不用关心具体执行的那个命令。</p></li><li><p>Command模式将操作的执行逻辑封装到一个个Command对象中，解耦了操作发起者和操作执行逻辑之间的耦合关系：操作发起者要进行一个操作，不用关心具体的执行逻辑，只需创建一个相应的Command实例，调用它的执行接口即可。而在swing中，与界面交互的各种操作，比如插入，删除等被称之为Edit，实际上就是Command。</p></li><li><p>使用undo包很简单，主要操作步骤如下：</p></li><li><p>1、创建CommandManager实例（持有Command的undo栈和redo栈)；</p></li><li><p>2、创建各种实现Command的具体操作类；</p></li><li><p>3、调用某种操作时，创建一个具体操作类的实例，加入CommandManager；</p></li><li><p>4、在Undo/Redo时，直接调用CommandManager的undo/redo方法。</p><h3 id="UML-17"><a href="#UML-17" class="headerlink" title="UML"></a>UML</h3></li><li><p>黑色箭头表示持有，关联关系 Client持有Invoker</p></li><li><p>菱形箭头也是持有，聚合关系 Invoker持有Command</p></li><li><p>白色箭头是继承，ConcreteCommand继承了Command</p><h3 id="适用场景与优缺点-17"><a href="#适用场景与优缺点-17" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3></li><li><p>适用场景：</p><ul><li>1)系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>2)系统需要在不同的时间制定请求，将请求排序和执行请求</li><li>3)系统需要支持undo和redo操作</li><li>4)系统需要将一组操作组合在一起</li></ul></li><li><p>优点：</p><ul><li>1)降低系统的耦合度，调用者和接收者解耦</li><li>2)Command是头等对象，可以被操纵和扩展</li><li>3)组合命令</li><li>4)方便实现undo和redo</li></ul></li><li></li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Originate是实体类，并负责创建和恢复Memento（比如JavaBean)</li><li>Memento负责保存对象的状态</li><li>CareTaker 负责存储Memento（一个或一系列)（多条历史记录)</li><li>Originate除了对象的属性和setter getter之外，还有创建和恢复Memento的方法</li><li>Memento也持有对象的所有属性和setter getter，它的构造方法是由Originate对象得到其内部状态。</li><li>CareTaker持有一个或一组Memento，并提供setter and getter</li></ul><h3 id="UML-18"><a href="#UML-18" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-18"><a href="#适用场景与优缺点-18" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p></li><li><p>1、需要保存/恢复数据的相关状态场景。 </p></li><li><p>2、提供一个可回滚的操作。</p></li><li><p>优点：</p></li><li><p>1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 </p></li><li><p>2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p></li><li><p>缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3></li></ul><h3 id="UML-19"><a href="#UML-19" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-19"><a href="#适用场景与优缺点-19" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><ul><li><p>适用场景：</p><ul><li>1)一个对象的行为取决于它的状态</li><li>2)代码中包含大量的与对象状态有关的条件语句</li></ul></li><li><p>优点：</p><ul><li>1)将与特定状态相关的行为局部化，并且将不同状态的行为分割开来</li><li>2)使得状态转换显式化</li><li>3)State对象可被共享</li></ul></li><li></li></ul><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h3 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h3><h3 id="UML-20"><a href="#UML-20" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-20"><a href="#适用场景与优缺点-20" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h3 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>解耦多个同事对象之间的交互关系。</p></li><li><p>每个同事对象都持有中介者对象的引用，只跟中介者打交道。我们通过中介者统一管理这些交互关系。</p></li><li><p>每个同事类都持有一个中介者类的引用。</p><h3 id="UML-21"><a href="#UML-21" class="headerlink" title="UML"></a>UML</h3></li><li><p>将多对多的关系解耦后转为一对多的关系，每个对象和中介者打交道，不直接和其他对象打交道。</p></li><li><p>如果关系比较简单，那么没有必要使用中介者模式，反而会复杂化。</p><h3 id="适用场景与优缺点-21"><a href="#适用场景与优缺点-21" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3></li><li><p>MVC中的C就是中介者</p></li><li><p>适用场景：</p><ul><li>1)系统中对象之间存在着复杂的引用关系</li><li>2)一组对象以定义良好但复杂的方式进行通信</li><li>3)一个对象引用其他很多对象并直接与这些对象通信，导致难以复用该对象</li></ul></li><li><p>优点：</p><ul><li>1)减少子类生成</li><li>2)简化同事类的设计和实现</li><li>3)简化对象协议（一对多代替多对多)</li><li>4)对对象如何协作进行了抽象</li><li>5)使控制集中化（将交互复杂性变为中介者的复杂性)<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h3 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h3></li></ul></li></ul><h3 id="UML-22"><a href="#UML-22" class="headerlink" title="UML"></a>UML</h3><h3 id="适用场景与优缺点-22"><a href="#适用场景与优缺点-22" class="headerlink" title="适用场景与优缺点"></a>适用场景与优缺点</h3><h1 id="2-6-设计模式的区分"><a href="#2-6-设计模式的区分" class="headerlink" title="2.6 设计模式的区分"></a>2.6 设计模式的区分</h1><h2 id="代理模式和装饰器区别"><a href="#代理模式和装饰器区别" class="headerlink" title="代理模式和装饰器区别"></a>代理模式和装饰器区别</h2><ul><li><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class)可以对它的客户隐藏一个对象的具体信息。</p></li><li><p>因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p></li><li><p>相同点：都是为被代理(被装饰)的类扩充新的功能。 </p></li><li><p>不同点：代理模式具有控制被代理类的访问等性质，而装饰模式紧紧是单纯的扩充被装饰的类。所以区别仅仅在是否对被代理/被装饰的类进行了控制而已。</p></li></ul><h2 id="适配器模式和代理模式的区别"><a href="#适配器模式和代理模式的区别" class="headerlink" title="适配器模式和代理模式的区别"></a>适配器模式和代理模式的区别</h2><ul><li><p>适配器模式，一个适配允许通常因为接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。</p></li><li><p>装饰器模式，原有的不能满足现有的需求，对原有的进行增强。</p></li><li><p>代理模式，同一个类而去调用另一个类的方法，不对这个方法进行直接操作，控制访问。</p><h2 id="抽象工厂和工厂方法模式的区别"><a href="#抽象工厂和工厂方法模式的区别" class="headerlink" title="抽象工厂和工厂方法模式的区别"></a>抽象工厂和工厂方法模式的区别</h2></li><li><p>工厂方法：创建某个具体产品</p></li><li><p>抽象工厂：创建某个产品族中的系列产品</p></li></ul><p>工厂方法模式    抽象工厂模式<br>针对的是一个产品等级结构    针对的是面向多个产品等级结构<br>一个抽象产品类    多个抽象产品类<br>可以派生出多个具体产品类    每个抽象产品类可以派生出多个具体产品类<br>一个抽象工厂类，可以派生出多个具体工厂类    一个抽象工厂类，可以派生出多个具体工厂类<br>每个具体工厂类只能创建一个具体产品类的实例    每个具体工厂类可以创建多个具体产品类的实例</p><ul><li><h1 id="2-7-JDK中的设计模式（17"><a href="#2-7-JDK中的设计模式（17" class="headerlink" title="2.7 JDK中的设计模式（17)"></a>2.7 JDK中的设计模式（17)</h1><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2></li><li><p>1)工厂方法</p></li><li><p>Collection.iterator() 由具体的聚集类来确定使用哪一个Iterator</p><ul><li>2)单例模式</li></ul></li><li><p>Runtime.getRuntime()</p><ul><li>3)建造者模式</li></ul></li><li><p>StringBuilder</p><ul><li>4)原型模式</li></ul></li><li><p>Java中的Cloneable</p><h2 id="结构性"><a href="#结构性" class="headerlink" title="结构性"></a>结构性</h2></li><li><p>1)适配器模式</p></li><li><p>InputStreamReader</p></li><li><p>OutputStreamWriter</p></li><li><p>RunnableAdapter</p><ul><li>2)装饰器模式</li></ul></li><li><p>io包 FileInputStream BufferedInputStream</p><ul><li>3)代理模式</li></ul></li><li><p>动态代理；RMI</p><ul><li>4)外观模式</li></ul></li><li><p>java.util.logging</p><ul><li>5)桥接模式</li></ul></li><li><p>JDBC</p><ul><li>6)组合模式</li></ul></li><li><p>dom</p><ul><li>7)享元模式</li></ul></li><li><p>Integer.valueOf</p><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2></li><li><p>1)策略模式</p></li><li><p>线程池的四种拒绝策略</p><ul><li>2)模板方法模式</li></ul></li><li><p>AbstractList、AbstractMap等</p></li><li><p>InputStream、OutputStream</p></li><li><p>AQS</p><ul><li>3)观察者模式</li></ul></li><li><p>Swing中的Listener</p><ul><li>4)迭代器模式</li></ul></li><li><p>集合类中的iterator</p><ul><li>5)责任链模式</li></ul></li><li><p>J2EE中的Filter</p><ul><li>6)命令模式</li></ul></li><li><p>Runnable、Callable，ThreadPoolExecutor</p><ul><li>7)备忘录模式</li><li>8)状态模式</li><li>9)访问者模式</li></ul></li><li><p>10)中介者模式</p><ul><li>11)解释器模式</li></ul></li><li></li></ul><h1 id="2-8-Spring中的设计模式（6"><a href="#2-8-Spring中的设计模式（6" class="headerlink" title="2.8 Spring中的设计模式（6)"></a>2.8 Spring中的设计模式（6)</h1><ul><li><p>1)抽象工厂模式：</p></li><li><p>BeanFactory</p><ul><li>2)代理模式：</li></ul></li><li><p>AOP</p><ul><li>3)模板方法模式：</li></ul></li><li><p>AbstractApplicationContext中定义了一系列的抽象方法，比如refreshBeanFactory、closeBeanFactory、getBeanFactory。</p><ul><li>4)单例模式：</li></ul></li><li><p>Spring可以管理单例对象，控制对象为单例</p><ul><li>5)原型模式：</li></ul></li><li><p>Spring可以管理多例对象，控制对象为prototype</p><ul><li>6)适配器模式：</li></ul></li><li><p>Advice与Interceptor的适配</p></li><li><p>Adapter类接口：Target</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AdvisorAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">supportsAdvice</span><span class="token punctuation">(</span>Advice advice<span class="token punctuation">)</span><span class="token punctuation">;</span>    MethodInterceptor <span class="token function">getInterceptor</span><span class="token punctuation">(</span>Advisor advisor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>MethodBeforeAdviceAdapter类，Adapter</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MethodBeforeAdviceAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">AdvisorAdapter</span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supportsAdvice</span><span class="token punctuation">(</span>Advice advice<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>advice <span class="token keyword">instanceof</span> <span class="token class-name">MethodBeforeAdvice</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> MethodInterceptor <span class="token function">getInterceptor</span><span class="token punctuation">(</span>Advisor advisor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MethodBeforeAdvice advice <span class="token operator">=</span> <span class="token punctuation">(</span>MethodBeforeAdvice<span class="token punctuation">)</span> advisor<span class="token punctuation">.</span><span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MethodBeforeAdviceInterceptor</span><span class="token punctuation">(</span>advice<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>五、JVM</title>
      <link href="//post/%E4%BA%94%E3%80%81JVM.html"/>
      <url>//post/%E4%BA%94%E3%80%81JVM.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><ul><li>Java运行时数据区有     </li><li>堆 ，本地方法栈，虚拟机栈，程序计数器，方法区（运行时常量池，属性和方法数据，代码区)</li></ul><ul><li>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。Java虚拟机所管理的内存将会包括以下集合运行时数据区域：</li></ul><h1 id="5-1-程序计数器（线程独享"><a href="#5-1-程序计数器（线程独享" class="headerlink" title="5.1 程序计数器（线程独享)"></a>5.1 程序计数器（线程独享)</h1><ul><li><p>程序计数器（Program Counter Register)是一块很小的内存区域，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></li><li><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。</p></li><li><p>如果线程正在执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法， 这个计数器的值为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h1 id="5-2-虚拟机栈（线程独享"><a href="#5-2-虚拟机栈（线程独享" class="headerlink" title="5.2 虚拟机栈（线程独享)"></a>5.2 虚拟机栈（线程独享)</h1></li><li><p>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（StackFrame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h1 id="5-3-本地方法栈（线程独享"><a href="#5-3-本地方法栈（线程独享" class="headerlink" title="5.3 本地方法栈（线程独享)"></a>5.3 本地方法栈（线程独享)</h1></li><li><p>本地方法栈（Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码)服务，而本地方法栈为虚拟机使用到的Native方法服务。</p><h1 id="5-4-Java堆"><a href="#5-4-Java堆" class="headerlink" title="5.4 Java堆"></a>5.4 Java堆</h1></li><li><p>对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p></li><li><p>Java堆是垃圾收集器管理的主要区域。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB)。</p></li><li><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><h1 id="5-5-方法区"><a href="#5-5-方法区" class="headerlink" title="5.5 方法区"></a>5.5 方法区</h1></li><li><p>方法区（Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆)，目的应该是与Java堆区分开来。</p></li><li><p>“PermGen space”是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”。</p></li><li><p>HotSpot虚拟机将GC分代收集拓展至方法区，或者说使用永久代来实现方法区。这样的HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。如果实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但是用永久代实现方法区，并不是一个好主意，因为这样容易遇到内存溢出问题。</p></li><li><p>垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区就永久存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p></li><li><p>在Java8中，永久代被删除，方法区的HotSpot的实现为Metaspace元数据区，不放在虚拟机中而放在本地内存中，存储类的元信息；</p></li><li><p>而将类的静态变量（放在Class对象中)和运行时常量池放在堆中。</p></li><li><p>为什么？</p><ul><li><p>1)移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p></li><li><p>2)现实使用中易出问题</p></li></ul></li><li><p>由于永久代内存经常不够用或发生内存泄露，出现异常java.lang.OutOfMemoryError: PermGen</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2></li><li><p>运行时常量池（Runtime Constant Pool)是方法区的一部分。Class文件中除了有关的描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池。</p></li><li><p>运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如String类的intern方法。</p><h1 id="5-6-直接内存"><a href="#5-6-直接内存" class="headerlink" title="5.6 直接内存"></a>5.6 直接内存</h1></li><li><p>直接内存（Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用。JDK的NIO类，引入了一种基于通道和缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场合显著提高性能，避免了在Java堆和Native堆来回复制数据。</p></li><li><p>直接内存的分配不会受到Java堆大小的限制，但会受到本机总内存的限制。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h1 id="5-7-对象的创建"><a href="#5-7-对象的创建" class="headerlink" title="5.7 对象的创建"></a>5.7 对象的创建</h1></li><li><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那就执行类加载过程。</p></li><li><p>在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一块与对象大小相等的距离，这种分配方式称为指针碰撞。如果Java堆中的内存不是规整的，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为空闲列表（Free List)。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p></li><li><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两个方案，一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB。哪个线程分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p></li><li><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据等信息。这些信息存放在对象的对象头之中。上述工作完成后，从虚拟机的视角来看，一个新的对象已经产生，但从Java程序的视角来看，构造方法还没有执行，字段都还为0。所以执行new指令之后会接着执行构造方法等，这样一个对象才算真正产生出来。</p><h1 id="5-8-对象的内存布局"><a href="#5-8-对象的内存布局" class="headerlink" title="5.8 对象的内存布局"></a>5.8 对象的内存布局</h1></li><li><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3个区域：对象头（Header)、实例数据（Instance Data)和对齐填充（Padding)。</p></li><li><p>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等。对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></li><li><p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承的，还是在子类中定义的，都需要记录下来。相同宽度的字段总是被分配到一起，在这个前提下，在父类中定义的变量会出现在子类之前。</p></li><li><p>对齐填充并不是必然存在的，它仅仅起着占位符的作用，HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即对象大小必须是8字节的整数倍，而对象头正好是8字节的整数倍。因此，当对象实例数据部分没有对齐时，就需要对齐填充来补全。</p><h1 id="5-9-对象的访问定位"><a href="#5-9-对象的访问定位" class="headerlink" title="5.9 对象的访问定位"></a>5.9 对象的访问定位</h1></li><li><p>Java程序需要通过栈上的Reference数据来操作堆上的具体对象。由于Reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式来定位、访问堆中对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目标主流的方式有使用句柄和直接指针两种。</p></li><li><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，Reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p></li><li><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而Reference中存储的直接就是对象地址。</p></li><li><p>使用句柄来访问的最大好处就是Reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而Reference本身不需要修改。</p></li><li><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。</p></li></ul><h1 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h1><ul><li>OOM ；方法区OOM时的异常；查看dump 文件，怎么查看，具体命令记得吗，答jstack  具体怎么用的<h1 id="5-10-堆溢出"><a href="#5-10-堆溢出" class="headerlink" title="5.10 堆溢出"></a>5.10 堆溢出</h1></li><li>Java堆用于存储对象实例，只要不断增加对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制后就会产生OOM异常。</li></ul><pre><code>public class HeapOOM {    static class OOMObject{    }     public static void main(String[] args) {        List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;();        while(true){            list.add(new OOMObject());        }    }}</code></pre><ul><li><p>VM Options:</p></li><li><p>-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p></li><li><p>java.lang.OutOfMemoryError: Java heap space</p></li><li><p>Dumping heap to java_pid15080.hprof …</p></li><li><p>Heap dump file created [28193498 bytes in 0.125 secs]</p></li><li><p>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</p></li><li><p>at java.util.Arrays.copyOf(Arrays.java:3210)</p><ul><li>at java.util.Arrays.copyOf(Arrays.java:3181)</li><li>at java.util.ArrayList.grow(ArrayList.java:261)</li><li>at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)</li><li>at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)</li><li>at java.util.ArrayList.add(ArrayList.java:458)</li><li>at cn.sinjinsong.se.review.oom.HeapOOM.main(HeapOOM.java:17)</li></ul></li><li><p>要解决这个区域的异常，一般的手段是通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要判断是出现来内存泄露还是内存溢出。前者的话要进一步通过工具查看泄露对象到GC Roots的引用链；后者的话可以调大虚拟机的堆参数（-Xms和-Xmx)，或者从代码上检查某些对象生命周期过长等。</p></li><li></li></ul><h1 id="5-11-栈溢出（虚拟机栈和本地方法栈"><a href="#5-11-栈溢出（虚拟机栈和本地方法栈" class="headerlink" title="5.11 栈溢出（虚拟机栈和本地方法栈)"></a>5.11 栈溢出（虚拟机栈和本地方法栈)</h1><ul><li>对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小)存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在JVM规范中描述了两种异常：<ul><li>1) 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>2)如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常。</li></ul></li></ul><pre><code>public class StackSOF {    private int stackLength = -1;    public void stackLeak() {        stackLength++;        stackLeak();    }    public static void main(String[] args) {        StackSOF sof = new StackSOF();        try {            sof.stackLeak();        } catch (Throwable e) {            System.out.println(&quot;stack length:&quot; + sof.stackLength);            throw e;        }    }}</code></pre><ul><li><p>-Xss128k（设置栈容量)</p></li><li><p>stack length:998</p></li><li><p>Exception in thread “main” java.lang.StackOverflowError</p></li><li><p>at cn.sinjinsong.se.review.oom.StackSOF.stackLeak(StackSOF.java:10)</p><ul><li>at cn.sinjinsong.se.review.oom.StackSOF.stackLeak(StackSOF.java:11)</li></ul></li><li><p>…</p></li><li><p>操作系统分配给每个进程的内存是有限制的，每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p></li><li><p>如果线程过多导致SOF，可以通过减少最大堆和减少栈容量来换取更多的线程。</p></li></ul><pre><code>public class StackSOFByThread {    public void stackLeakByThread() {        while(true) {            new Thread(() -&gt; {                while (true){}            }).start();        }    }    public static void main(String[] args) {        new StackSOFByThread().stackLeakByThread();    }}</code></pre><ul><li><h1 id="5-12-方法区溢出"><a href="#5-12-方法区溢出" class="headerlink" title="5.12 方法区溢出"></a>5.12 方法区溢出</h1></li><li><p>注意Java8下运行时常量池在堆中，所以运行时常量池过大会体现为OOM：heap；</p></li><li><p>而在此以前是放在永久代中，体现为OOM：PermGen space。</p></li></ul><pre><code>public class RuntimeConstantPoolOOM {    public static void main(String[] args) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        int i = 0;        while (true) {            list.add(String.valueOf(i++).intern());        }    }}</code></pre><ul><li><p>VM Options: -Xms20m -Xmx20m</p></li><li><p>Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded</p><ul><li>at java.lang.Integer.toString(Integer.java:401)</li><li>at java.lang.String.valueOf(String.java:3099)</li><li>at cn.sinjinsong.se.review.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:15)</li></ul></li><li><p>方法区还存放Class的相关信息，运行时产生大量的类也会导致方法区（Java8中放在直接内存中)溢出。</p></li></ul><pre><code>public class MetaspaceOOM {    public static void main(String[] args) {        while(true){            Enhancer enhancer = new Enhancer();            enhancer.setSuperclass(HeapOOM.OOMObject.class);            enhancer.setUseCache(false);            enhancer.setCallback(new MethodInterceptor() {                @Override                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {                    return proxy.invokeSuper(obj,args);                }            });            enhancer.create();        }    }}</code></pre><ul><li><p>VM Options: -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</p></li><li><p>Caused by: java.lang.OutOfMemoryError: Metaspace</p></li><li><p>at java.lang.ClassLoader.defineClass1(Native Method)</p><ul><li>at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</li></ul></li><li><p>… 11 more</p></li><li><p>方法区溢出也是一种常见的内存溢出异常，一个类被GC，判定条件是比较苛刻的。在经常生成大量Class的应用中，需要特别注意类的回收情况。这类场景除了动态代理生成类和动态语言外，还有：大量使用JSP、基于OSGi的应用。</p></li></ul><h1 id="5-13-直接内存溢出"><a href="#5-13-直接内存溢出" class="headerlink" title="5.13 直接内存溢出"></a>5.13 直接内存溢出</h1><ul><li>直接内存可以使用-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值相同。</li><li>虽然使用DirectByteBuffer分配内存也会抛出OOM异常，但它抛出异常时并没有真正向OS申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常。</li><li>真正申请内存的方法是unsafe.allocateMemory()。</li></ul><pre><code>public class DirectMemoryOOM {    private static final int _1MB = 1024 * 1024;    public static void main(String[] args) throws IllegalAccessException {        Field unsafeField = Unsafe.class.getDeclaredFields()[0];        unsafeField.setAccessible(true);        Unsafe unsafe = (Unsafe) unsafeField.get(null);        while(true) {            unsafe.allocateMemory(_1MB);        }    }}</code></pre><ul><li><p>VM Options: -XX:MaxDirectMemorySize=10m</p></li><li><p>Exception in thread “main” java.lang.OutOfMemoryError</p></li><li><p>at sun.misc.Unsafe.allocateMemory(Native Method)</p><ul><li>at cn.sinjinsong.se.review.oom.DirectMemoryOOM.main(DirectMemoryOOM.java:19)</li></ul></li><li></li></ul><h1 id="5-14-内存泄露"><a href="#5-14-内存泄露" class="headerlink" title="5.14 内存泄露"></a>5.14 内存泄露</h1><pre><code>- 1)非静态内部类- 2)连接未关闭：比如数据库连接（dataSourse.getConnection())，网络连接(socket)和io连接，除非其显式的调用了其close（)方法将其连接关闭，否则是不会自动被GC 回收的。</code></pre><ul><li><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h1 id="5-15-对象是否存活"><a href="#5-15-对象是否存活" class="headerlink" title="5.15 对象是否存活"></a>5.15 对象是否存活</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2></li><li><p>很多教科书判断对象是否存活的算法是这样的：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计算器为0的对象就是不可能再被使用的。</p></li><li><p>主流的Java虚拟机中没有选用计数算法来管理内存，最主要的原因是它很难就解决对象之间相互循环引用的问题。</p></li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><ul><li><p>主流的商用程序语言的主流实现中，都是称通过可达性分析（Reachability Analysis)来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的。下图章，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots时不可达的，所以它们将会被判定为可回收的对象。</p></li><li><p>在Java中，可作为GC Roots的对象包括：<br>- 虚拟机栈中引用的对象<br>- 方法区中类静态属性引用的对象<br>- 方法区中常量引用的对象<br>- 本地方法栈中JNI（一般说的Native方法)引用的对象</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2></li><li><p>即使在可达性分析中不可达的对象，也并非是非死不可。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件就是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，虚拟机将这两种情况视为没有必要执行。</p></li><li><p>如果这个对象被判为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将会对F-Queue中的对象进行第二次小规模的标记，\如果对象要在finalize()中拯救自己，只要重新与引用链上的任何一个对象建立联系即可，比如把自己this复制给某个类变量或对象的成员变量，那在第二次标记时它将被移出即将回收的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。任何一个对象的finalize()方法都只会被系统调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2></li><li><p>在方法区（永久代)中进行垃圾收集的性价比较低：在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。</p></li><li><p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量和回收Java堆中的对象类似。以常量池中字面量的回收为例，没有任何String对象引用常量池中的某个字符串常量，这个常量就会被系统清理出常量池。常量池中的其他类、方法、字段的符号引用也与此类似。</p></li><li><p>判定一个类是否是无用的类的条件比较苛刻，需要同时满足以下三个条件：</p><ul><li>1)该类的所有实例都已经被回收</li><li>2)加载该类的类加载器已经被回收</li><li>3)该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是可以，而不是和对象一样，不适用了就必然会被回收。是否对类回收，HotSpot虚拟机提供了参数进行控制。</p></li><li><p>在大量使用反射、动态代理、CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p></li><li></li></ul><h1 id="5-16-GC算法"><a href="#5-16-GC算法" class="headerlink" title="5.16 GC算法"></a>5.16 GC算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><ul><li><p>最基础的收集算法是标记-清除算法（Mark-Sweep)，算法分为标记和清除两个阶段。首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。他的不足主要有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2></li><li><p>为了解决效率问题，出现了复制算法。它将可用内存按容量划分为大小相等的两块，每次只是用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存空间，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p></li><li><p>现在的商业虚拟机都采用这种收集算法来回收新生代。将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次都使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。当Survivor空间不够用时，需要依赖其他内存（老年代)进行分配担保。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2></li><li><p>复制收集算法在对象存活率较高时，效率就会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，所以老年代一般不能直接选用这种算法。</p></li><li><p>根据老年代的特点，有人提出一种标记-整理算法（Mark-Compact)，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p></li></ul><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ul><li><p>当前商业虚拟机的垃圾收集都采用分代收集算法（Generational Collection)，这种算法是根据对象存活周期的不同将内存划分为适当的几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清除或者标记-整理算法来进行回收。</p></li><li></li></ul><h1 id="5-17-Minor-Full-GC"><a href="#5-17-Minor-Full-GC" class="headerlink" title="5.17 Minor Full GC"></a>5.17 Minor Full GC</h1><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><ul><li>从年轻代空间（包括 Eden 和 Survivor 区域)回收内存被称为 Minor GC。</li><li>非常频繁，回收速度较快。</li><li>各种Young GC的触发原因都是eden区满了。<h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2></li><li>收集整个堆，包括年轻代、老年代、元数据区等所有部分。</li><li>速度较慢。</li><li>触发原因不确定，因具体垃圾收集器而异。</li><li>比如老年代内存不足，ygc出现promotion failure，System.gc()等。</li><li>CMS垃圾收集器不能像其他垃圾收集器那样等待年老代机会完全被填满之后再进行收集，需要预留一部分空间供并发收集时的使用。</li></ul><h1 id="5-18-HotSpot的垃圾收集器"><a href="#5-18-HotSpot的垃圾收集器" class="headerlink" title="5.18 HotSpot的垃圾收集器"></a>5.18 HotSpot的垃圾收集器</h1><ul><li><p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能有很大差别，并且一般都会提供参数供用户根据自己得到应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于HotSpot虚拟机，这个虚拟机包含的所有收集器如图所示。</p></li><li></li></ul><h2 id="1-Serial垃圾收集器"><a href="#1-Serial垃圾收集器" class="headerlink" title="(1).Serial垃圾收集器"></a>(1).Serial垃圾收集器</h2><ul><li><p>Serial是最基本、历史最悠久的垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。</p></li><li><p>Serial是一个单线程的收集器，它不仅仅只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。</p></li><li><p>Serial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以 获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。</p><h2 id="2-ParNew垃圾收集器"><a href="#2-ParNew垃圾收集器" class="headerlink" title="(2).ParNew垃圾收集器"></a>(2).ParNew垃圾收集器</h2></li><li><p>ParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p></li><li><p>ParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。</p></li><li><p>ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。</p><h2 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="(3).Parallel Scavenge收集器"></a>(3).Parallel Scavenge收集器</h2></li><li><p>Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量 （Thoughput，CPU用于运行用户代码的时间/CPU总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))，高吞吐量 可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p></li><li><p>Parallel Scavenge收集器提供了两个参数用于精准控制吞吐量：</p></li><li><p>a.-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，是一个大于0的毫秒数。</p><ul><li>b.-XX:GCTimeRation：直接设置吞吐量大小，是一个大于0小于100的整数，也就是程序运行时间占总时间的比率，默认值是99，即垃圾收集运行最大1%（1/(1+99))的垃圾收集时间。</li></ul></li><li><p>Parallel Scavenge是吞吐量优先的垃圾收集器，它还提供一个参数：-XX:+UseAdaptiveSizePolicy，这是个开关参数，打开之后就不需 要手动指定新生代大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRation)、新生代晋升年老代对象年龄 (-XX:PretenureSizeThreshold)等细节参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以达到最大吞吐 量，这种方式称为GC自适应调节策略，自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别。</p><h2 id="4-Serial-Old收集器"><a href="#4-Serial-Old收集器" class="headerlink" title="(4).Serial Old收集器"></a>(4).Serial Old收集器</h2></li><li><p>Serial Old是Serial垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。</p></li><li><p>在Server模式下，主要有两个用途：</p></li><li><p>a.在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。</p></li><li><p>b.作为年老代中使用CMS收集器的后备垃圾收集方案。</p></li><li><p>新生代Serial与年老代Serial Old搭配垃圾收集过程图：</p></li><li><p>新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是多线程的收集器，都使用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。</p></li><li><p>新生代Parallel Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图：</p></li></ul><h2 id="5-Parallel-Old收集器"><a href="#5-Parallel-Old收集器" class="headerlink" title="(5).Parallel Old收集器"></a>(5).Parallel Old收集器</h2><ul><li>Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。</li><li>在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。</li><li>新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：</li></ul><h2 id="6-CMS收集器（重点"><a href="#6-CMS收集器（重点" class="headerlink" title="(6).CMS收集器（重点)"></a>(6).CMS收集器（重点)</h2><ul><li><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。</p></li><li><p>最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验，CMS收集器是Sun HotSpot虚拟机中第一款真正意义上并发垃圾收集器，它第一次实现了让垃圾收集线程和用户线程同时工作。</p></li><li><p>CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：</p></li><li><p>a.初始标记：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p></li><li><p>b.并发标记：进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p></li><li><p>c.重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</p></li><li><p>d.并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。</p></li><li><p>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行。</p></li><li><p>CMS收集器工作过程：</p></li><li><p>CMS收集器有以下三个不足：</p><ul><li>a.CMS收集器对CPU资源非常敏感，其默认启动的收集线程数=(CPU数量+3)/4，在用户程序本来CPU负荷已经比较高的情况下，如果还要分出CPU资源用来运行垃圾收集器线程，会使得CPU负载加重。</li></ul></li><li><p>b.CMS无法处理浮动垃圾(Floating Garbage)，可能会导致Concurrent ModeFailure失败而导致另一次Full GC。由于CMS收集器和用户线程并发运行，因此在收集过程中不断有新的垃圾产生，这些垃圾出现在标记过程之后，CMS无法在本次收集中处理掉它们，只好 等待下一次GC时再将其清理掉，这些垃圾就称为浮动垃圾。</p></li><li><p>CMS垃圾收集器不能像其他垃圾收集器那样等待年老代机会完全被填满之后再进行收集，需要预留一部分空间供并发收集时的使用，可以通过参数 </p></li><li><p>-XX:CMSInitiatingOccupancyFraction来设置年老代空间达到多少的百分比时触发CMS进行垃圾收集，默认是68%。</p></li><li><p>如果在CMS运行期间，预留的内存无法满足程序需要，就会出现一次ConcurrentMode Failure失败，此时虚拟机将启动预备方案，使用Serial Old收集器重新进行年老代垃圾回收。</p></li><li><p>c.CMS收集器是基于标记-清除算法，因此不可避免会产生大量不连续的内存碎片，如果无法找到一块足够大的连续内存存放对象时，将会触发因此 Full GC。CMS提供一个开关参数-XX:+UseCMSCompactAtFullCollection，用于指定在Full GC之后进行内存整理，内存整理会使得垃圾收集停顿时间变长，CMS提供了另外一个参数-XX:CMSFullGCsBeforeCompaction， 用于设置在执行多少次不压缩的Full GC之后，跟着再来一次内存整理。</p></li><li><p>promotion failure 发生在 young gc 阶段，即 cms 的 ParNewGC。promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；</p></li><li><p>concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的</p><h2 id="7-G1收集器（重点"><a href="#7-G1收集器（重点" class="headerlink" title="(7).G1收集器（重点)"></a>(7).G1收集器（重点)</h2></li><li><p>Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是：</p></li><li><p>a.基于标记-整理算法，不产生内存碎片。</p></li><li><p>b.可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p></li><li><p>G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。</p></li><li><p>区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p></li><li></li></ul><h1 id="5-19-内存分配原则"><a href="#5-19-内存分配原则" class="headerlink" title="5.19 内存分配原则"></a>5.19 内存分配原则</h1><ul><li>对象的内存分配，就是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能直接分配在老年代中，分配的规则不是固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</li><li>下面会讲解几条最普遍的内存分配原则。<h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2></li><li>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。如果GC期间虚拟机发现已有的对象全部无法放入Survivor空间，会通过分配担保机制提前转移至老年代中。</li></ul><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><ul><li><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来安置它们。</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2></li><li><p>虚拟机为每个对象定义一个对象年龄（Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁)，就将会被晋升到老年代。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2></li><li><p>虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2></li><li><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那此时也要改为进行一次Full GC。</p></li><li><p>冒险是指当出现大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor区无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共会有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之间每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p></li><li><p>取平均值进行比较其实仍然是一种动态概率的手段，依然存在担保失败的情况。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。</p></li><li></li></ul><h1 id="5-20-GC相关API"><a href="#5-20-GC相关API" class="headerlink" title="5.20 GC相关API"></a>5.20 GC相关API</h1><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc"></a>System.gc</h2><ul><li>建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</li></ul><pre><code>public static void gc() {</code></pre><ul><li><p>Runtime.getRuntime().gc();</p></li><li><p>}</p></li><li><p>Runtime.gc的底层实现位于Runtime.c文件中</p></li><li><p>JNIEXPORT void JNICALL</p></li><li><p>Java_java_lang_Runtime_gc(JNIEnv *env, jobject this)</p></li><li><p>{</p></li><li><p>JVM_GC();</p></li><li><p>}</p></li><li><p>JVM_ENTRY_NO_ENV(void, JVM_GC(void))</p></li><li><p>JVMWrapper(“JVM_GC”);</p></li><li><p>if (!DisableExplicitGC) {</p></li><li><p>Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);</p></li><li><p>}</p></li><li><p>JVM_END</p></li><li><p>这里有一个DisableExplicitGC参数，默认是false，如果启动JVM时添加了参数-XX:+DisableExplicitGC，那么JVM_GC相当于一个空函数，并不会进行GC。</p></li><li><p>其中Universe::heap()返回当前堆对象，由collect方法开始执行GC，并设置当前触发GC的条件为_java_lang_system_gc，内部会根据GC条件执行不同逻辑。</p></li><li><p>JVM的具体堆实现，在Universe.cpp文件中的initialize_heap()由启动参数所设置的垃圾回收算法决定。</p></li><li><p>堆实现和回收算法对应关系：</p></li><li><p>1、UseParallelGC：ParallelScavengeHeap</p></li><li><p>2、UseG1GC：G1CollectedHeap</p></li><li><p>3、默认或者CMS：GenCollectedHeap</p></li><li></li></ul><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><ul><li><p>Class类文件的结构</p></li><li><p>Class文件并不一定定义在文件里，也可以通过类加载器直接生成。</p></li><li><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p></li><li><p>Class文件结构采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。</p></li><li><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照utf-8编码构成字符串值。</p></li><li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以_info结尾。表用于描述有层次关系的复合结构的数据。</p></li><li><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p></li><li><p>魔数与Class文件的版本</p></li><li><p>每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接收的Class文件。很多文件存储格式都使用魔数来进行身份识别。魔数的值为0xCAFEBABE。</p></li><li><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是此版本号，第7和第8个字节是主版本号。</p></li><li><p>简单的一段Java代码，后面的内容将以此为例进行讲解：</p></li></ul><pre><code>public class TestClass {</code></pre><pre><code>    private int m;</code></pre><pre><code>    public int inc(){</code></pre><ul><li><p>return m+1;</p></li><li><p>}</p></li><li><p>}</p></li><li><p>常量池</p></li><li><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件中的资源仓库，它是Class文件结构中和其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p></li><li><p>由于常量池中常量的数量是不固定的，所以在常量池入口需要放置一项u2类型的数据，代表常量池容量计数器（从1开始)。对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p></li><li><p>常量池中主要存放两大类常量：字面量（Literal)和符号引用（Symbolic References)。字面量比较接近于Java语言层面的常量概念，如字符串、final常量值。而符号引用则属于编译原理方面的概念，包括了下面三类常量：<br>- 类和接口的全限定名<br>- 字段的名称和描述符<br>- 方法的名称和描述符</p></li><li><p>Java代码在javac编译的时候，并没有连接这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p></li><li><p>常量池中每一项常量都是一个表，在JDK1.7之前有11种不同结构的表结构数据。1.7增加了3种。它们的共同特点是表开始的第一位是一个u1类型的标志位，代表当前这个常量属于哪种常量类型。</p></li><li><p>访问标志</p></li></ul><pre><code>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</code></pre><ul><li><p>访问标志中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位一律为0。</p></li><li><p>类索引、父类索引与接口索引集合</p></li><li><p>类索引和父类索引都是一个u2类型数据，而接口索引集合是一组u2类型数据的集合，Class文件中由这3项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按implements 语句后的接口顺序从左到右排列在接口索引集合中。</p></li><li><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p></li><li><p>对于接口类型集合，入口的第一项—u2类型的数据为接口计数器，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p></li><li><p>字段表集合</p></li><li><p>字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：作用域（访问权限)、static修饰符、final修饰符、并发可见性、序列化修饰符等。</p></li><li><p>跟随access_flags标志的是两项索引值：name_index and desciptor_index。它们都是对常量池的引用，分别代表字段的简单名称以及字段和方法的描述符。</p></li><li><p>全限定名和简单名称：org/fenixsoft/clazz/TestClass是这个类的全限定名。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类的inc（)方法和m字段的简单名称分别是inc和m。</p></li><li><p>相对于全限定名和简单名称而言，方法和字段的描述符要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（数量、类型、顺序)和返回值。基本数据类型（byte、char、double…)以及代表无返回值的void类型都用一个大写字母表示，而对象类型则用字符L加对象的全限定名来表示。</p></li><li><p>对于数组来说，每一维度将使用一个前置的【字符来描述，如定义一个java.lang.String[][]类型的二维数组，将被记录为[[Ljava/lang/String，一个整数数组 int[] 将被记录为[I。</p></li><li><p>用描述符描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号之内。比如方法void inc（)的描述符为()V，方法java.lang.String.toString()的描述符为()Ljava/lang/String。</p></li><li><p>字段表集合首先是一个容量计数器，说明该类的字段表数据个数，然后是access_flags标志，然后是其他标志、</p></li><li><p>在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息。</p></li><li><p>字段表集合不会列出从超类或者父接口继承而来的字段，但有可能列出原本Java代码中不存在的字段，比如内部类会自动添加指向外部类实例的字段。</p></li><li><p>方法表集合</p></li><li><p>方法表的结构依次包括了访问标志、名称索引、描述符索引、属性表集合。</p></li><li><p>方法里面的Java代码，经过编译器编译为字节码指令后，存放在方法属性表中一个名为Code的属性里面，属性表是Class文件格式中最具拓展性的一种数据项目。</p></li><li><p>与字段表集合对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器<clinit>和实例构造器<init>。</p></li><li><p>要重载一个方法，除了要有和原方法相同的简单名称外，还必须有一个不同的特征签名。特征签名就是一个方法中各个参数在常量池中的字段符号引用的结婚，也就是返回值不会包含在特征签名中。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存在同一个Class文件中的。</p></li><li><p>属性表集合</p></li><li><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制宽松一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表写入自己定义的属性信息。为了能正确解析Class文件，Java虚拟机规范预定义了9项虚拟机实现应当能识别的属性。（现已增至21项)</p></li><li><p>以上列出其中的5种。</p></li><li><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性表的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下图所定义的结构：</p></li><li><p>1、Code属性</p></li><li><p>Code属性出现在方法表的属性集合中，但并非所有的方法表都必须存在这种属性。</p></li><li><p>max_stack代表了操作数栈深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。</p></li><li><p>max_locals代表了局部变量表所需的存储空间，单位是slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char等长度不超过32位的数据类型，每个局部变量占1个Slot，而long和double占2个Slot。方法参数（包括this)、显式异常处理器参数（catch所定义的异常)、方法体中定义的局部变量都需要使用局部变量表来存放。并不是方法中用到了多少个局部变量，就把这些变量所占Slot之和作为max_locals的值，因为局部变量表中的Slot可以重用，当代码执行超过一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用。</p></li><li><p>Code属性表是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码和元数据两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p></li><li><p>在任何实例方法中，都可以通过this关键字访问到此方法所属的对象。它的实现就是通过javac编译器变异的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用。</p></li><li><p>在字节码指令之后的是这个方法的显式异常处理表集合，异常表对Code属性来说并不是必须存在的。</p></li><li><p>异常表包含4个字段，这些字段的含义是：如果当字节码在第start_pc行到第end_pc之间（不含end_pc)出现了类型为catch_type或者其子类的异常，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。</p></li><li><p>异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。</p></li><li><p>2、Exceptions属性</p></li><li><p>Exceptions属性的作用是列举出方法中可能抛出的受检查异常，也就是方法描述时在throws关键字后面列举的异常。它的结构：</p></li><li><p>3、LineNumberTable属性</p></li><li><p>LineNumberTable属性用于描述Java源码行号与字节码行号之间的对应关系，是可选的属性。如果选择不生成LineNumberTable属性，对程序运行的最主要的影响就是当跳出异常时，堆栈中将不会显示出错的行号，并且在调试的时候，也无法按照源码行来设置断点。</p></li><li><p>4、LocalVariableTable属性</p></li><li><p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量和Java源码中定义的变量之间的关系，它也是可选的属性。</p></li><li><p>5、SourceFile属性</p></li><li><p>SourceFile属性用于记录生成这个Class文件的源码文件名称，也是可选的。</p></li><li><p>6、ConstantValue属性</p></li><li><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static修饰的变量才可以使用这项属性。对于非static类型的变量的赋值是在实例构造方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器<clinit>中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果是常量（static final)，并且这个常量的数据类型是基本类型或者String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型或字符串，则将会选择在类构造器<clinit>中进行初始化。</p></li><li><p>字节码指令简介</p></li><li><p>Java虚拟机指令是由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode)以及跟随其后的零至多个代表此操作所需参数（操作数，Operands)而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p></li><li><p>1个字节意味着指令集的操作码总数不能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号。</p></li><li><p>Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解：</p></li><li><p>字节码与数据类型</p></li><li><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。iload指令用于从局部变量表中记载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p></li><li><p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务，i代表对int类型的数据操作，l代表long等。</p></li><li><p>大部分的指令都没有支持整数类型byte、char和short，编译器会在编译时或运行时将byte和short类型的数据带符号拓展为相应的int类型的数据。大多数对于boolean、byte、short和char类型的数据的操作，实际上都是使用相应的int类型作为运算类型。</p></li><li><p>加载和存储指令</p></li><li><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数之间来回传输。</p></li><li><p>尖括号结尾的指令实际上是代表了一组指令，这几组指令都是某个带有一个操作数的通用指令的特殊形式，对于这若干组的特殊指令来说，它们省略掉了显式地操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。</p></li><li><p>运算指令</p></li></ul><ul><li><p>类型转换指令</p></li><li><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p></li><li><p>对象创建与访问指令</p></li><li><p>操作数栈管理指令</p></li><li><p>控制转换指令</p></li><li><p>方法调用和返回指令</p></li><li><p>异常处理指令</p></li><li><p>在Java程序中显式抛出的操作都由athrow指令来实现。处理异常（catch)不是由字节码指令来实现的，而是采用异常表来完成的。</p></li><li><p>athrow指令与异常表：</p></li></ul><pre><code>public void catchException() {</code></pre><ul><li><p>try {</p></li><li><p>throw new Exception();</p><ul><li>} catch (Exception var2) {</li></ul></li><li><p>;</p></li><li><p>}</p></li><li><p>}</p></li><li><p>字节码：</p></li></ul><pre><code>public void catchException();  </code></pre><ul><li><p>Code:  </p></li><li><p>Stack=2, Locals=2, Args_size=1  </p></li><li><p>0:   new     #58; //class java/lang/Exception  </p></li><li><p>3:   dup  </p></li><li><p>4:   invokespecial   #60; //Method java/lang/Exception.”<init>“:()V  </p></li><li><p>7:   athrow </p></li><li><p>8:   astore_1  </p></li><li><p>9:   return  </p></li><li><p>Exception table:  </p></li><li><p>from   to  target type  </p></li><li><p>0     8     8   Class java/lang/Exception  </p></li><li><p>偏移为7的athrow指令，这个指令运作过程大致是首先检查操作栈顶，这时栈顶必须存在一个reference类型的值，并且是java.lang.Throwable的子类（虚拟机规范中要求如果遇到null则当作NPE异常使用)，然后暂时先把这个引用出栈，接着搜索本方法的异常表，找一下本方法中是否有能处理这个异常的handler，如果能找到合适的handler就会重新初始化PC寄存器指针指向此异常handler的第一个指令的偏移地址。接着把当前栈帧的操作栈清空，再把刚刚出栈的引用重新入栈。如果在当前方法中很悲剧的找不到handler，那只好把当前方法的栈帧出栈（这个栈是VM栈，不要和前面的操作栈搞混了，栈帧出栈就意味着当前方法退出)，这个方法的调用者的栈帧就自然在这条线程VM栈的栈顶了，然后再对这个新的当前方法再做一次刚才做过的异常handler搜索，如果还是找不到，继续把这个栈帧踢掉，这样一直到找，要么找到一个能使用的handler，转到这个handler的第一条指令开始继续执行，要么把VM栈的栈帧抛光了都没有找到期望的handler，这样的话这条线程就只好被迫终止、退出了。</p><ul><li>上面的异常表只有一个handler记录，它指明了从偏移地址0开始（包含0)，到偏移地址8结束（不包含8)，如果出现了java.lang.Exception类型的异常，那么就把PC寄存器指针转到8开始继续执行。顺便说一下，对于Java语言中的关键字catch和finally，虚拟机中并没有特殊的字节码指令去支持它们，都是通过编译器生成字节码片段以及不同的异常处理器来实现。</li></ul></li><li></li><li><p>同步指令（重点)</p></li><li><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor)来支持的。</p></li><li><p>方法级的同步是隐式的，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p></li><li><p>同步一段指令集序列通常是由synchronized语句块来表示的，Java虚拟机的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javc编译器和虚拟机两者共同协作支持。</p></li><li><p>方法中调用过的每一条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是否正常结束。</p></li><li><p>为了保证在方法异常完成时monitorenter和monitorexit指令异常可以正常配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可以处理所有的异常，它的目的就是用来执行monitorexit指令。</p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1></li><li><p>概述</p></li><li><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p></li><li><p>与那些编译时需要进行连接的语言不同，Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时增加一些性能开销，但是是为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p></li><li><p>类加载的时机</p></li><li><p>类的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。</p></li><li><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序开始，而解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（动态绑定)。</p></li><li><p>什么时候开始类加载过程的第一个阶段：加载？</p></li><li><p>Java虚拟机规范规定有且只有5种情况必须立即对类进行初始化：</p><ul><li>1)遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有过初始化，则需要先初始化。生成这4条指令的最常见的Java代码场景是：使用new实例化对象时、读取或设置一个类的静态字段时、调用一个类的静态方法时</li><li>2)反射</li><li>3)如果一个类的父类尚未初始化，那么先触发其父类的初始化</li><li>4)main方法所在类</li><li>5)java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、 REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul></li><li><p>只有直接定义一个静态字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确确定，这点取决于虚拟机的具体实现。</p></li><li><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父类接口全部都完成了初始化，只有在真正使用到父接口（如引用接口中定义的常量)的时候才会初始化。</p></li><li><p>类加载的过程</p><ul><li>1) 加载</li></ul></li><li><p>加载是类加载过程的一个阶段。</p></li><li><p>在加载阶段，虚拟机需要完成以下3件事情：</p><ul><li>1)通过一个类的全限定名获得此类的二进制字节流</li><li>2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>3)在内存中生成一个代表这个类的Class对象（HotSpot中放在堆里)，作为方法区这个类的各种数据的访问入口。</li></ul></li><li><p>加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p></li><li><p>加载阶段和连接阶段的部分内容是交叉进行的</p></li><li><p>java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用，InstanceKlass放在方法区（Java8HotSpot中放在元数据区)</p><ul><li>2) 验证</li></ul></li><li><p>验证是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p></li><li><p>验证阶段是否严谨直接决定了Java虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。</p></li><li><p>验证阶段大致会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p></li><li><p>1、文件格式验证</p></li><li><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p></li><li><p>2、元数据验证</p></li><li><p>第二阶段是对字节码描述的数据进行语义分析，以保证其描述的信息符合Java语言规范的要求。</p></li><li><p>3、字节码验证</p></li><li><p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验的类的方法在运行时不会做出危害虚拟机安全的事件。</p></li><li><p>如果一个方法体通过了字节码校验，也不能说明其一定就是安全的，这里涉及一个停机问题，通过程序去校验程序逻辑是无法做到绝对准确的—–不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p></li><li><p>4、符号引用验证</p></li><li><p>最后一个阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段—解析阶段中发生。符号引用可以看做是对类自身以外（常量池中的各种符号引用)的信息进行匹配性校验。</p><ul><li>3) 准备</li></ul></li><li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量，而不包括实例变量；这里所说的初始值，是指0值。</p></li><li><p>如果是static final 常量，那么会被初始化为ConstantValue属性所指定的值。</p><ul><li>4) 解析</li></ul></li><li><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p></li><li><p>符号引用：符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定都已经加载到内存中。</p></li><li><p>直接引用：直接引用是可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那么引用的目标必须已经在内存中存在。</p></li><li><p>对同一个符号引用进行多次解析请求是很常见的事情，除了invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存，从而避免解析动作重复进行。动态（invokedynamic)的含义是必须等到程序实际运行到这条指令的时候，解析动作才能进行。</p><ul><li>5) 初始化</li></ul></li><li><p>类初始化是类加载阶段的最后一步。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p></li><li><p>初始化阶段是执行类构造器<clinit>方法的过程。</p></li><li><p>类构造器<clinit>是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态代码块只能访问到定义在静态代码块之间的变量，定义在它之后的变量，在前面的静态代码块可以赋值，但是不能访问。</p></li><li><p>类构造器<clinit>与类的构造方法不同，它不需要显式调用父类构造器<clinit>，虚拟机会保证在子类的类构造器<clinit>执行之前，父类的类构造器<clinit>已经执行完毕。</p></li><li><p>类构造器<clinit>对于类或接口不是必需的，如果一个类中没有静态代码块，也没有对变量的赋值操作，那么编译器可以不为这个类生成类构造器<clinit>。</p></li><li><p>接口中不能使用静态代码块，但是仍然有变量初始化的赋值操作，因此接口和类一样都会生成类构造器<clinit>。但接口与类不同的是，执行接口的类构造器<clinit>不需要先执行父接口的类构造器<clinit>。只有当父接口中定义的变量使用时，父接口才会初始化，另外，接口的实现类在初始化时也一样不会执行接口的类构造器<clinit>。</p></li><li><p>虚拟机会保证一个类的类构造器<clinit>在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的类构造器<clinit>，其他线程都需要阻塞等待，直至活动线程执行类构造器<clinit>完毕。</p></li><li><p>类的主动引用和被动引用</p></li><li><p>主动引用（一定会发生类的初始化)</p></li><li><p>new对象</p></li><li><p>引用静态变量（static非final)和静态方法</p></li><li><p>反射</p></li><li><p>main方法所在类</p></li><li><p>当前类的所有父类</p></li><li><p>被动引用（不会发生类的初始化)</p></li><li><p>访问一个类的静态变量，只有真正声明这个静态变量的类才会被初始化</p></li><li><p>通过数组定义类引用</p></li><li><p>引用常量（存在方法区的运行时常量池)</p></li><li><p>类加载器</p></li><li><p>类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为类加载器。</p></li><li><p>类与类加载器</p></li><li><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换句话说，比较两个类是否相等，只有在这两个类是由同一个类加载器（实例)加载的前提下才有意义，否则，即使这两个来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类必定不相等。</p></li><li><p>这里所指的相等，包括类的Class对象的equals方法等的返回结果，也包括instance of的返回结果。</p></li><li><p>双亲委派模型</p></li><li><p>从Java虚拟机角度来讲，只存在两种不同的类加载器：一种是启动类加载器（bootstrap classloader)，这个类加载器由C++语言实现（HotSpot)，是虚拟机自身的一部分；另一种就是所有的其他类加载器，都由Java语言实现，独立于虚拟机外部。并且全继承自java.lang.ClassLoader。</p></li><li><p>从Java开发人员的角度看，Java程序使用到以下3种系统提供的类加载器：</p><ul><li>1)启动类加载器：负责将存放在\lib目录中的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</li><li>2)扩展类加载器（Extension ClassLoader)：这个加载器负责加载\lib\ext目录中的所有类库，开发者可以直接使用扩展类加载器。</li><li>3)应用程序类加载器（Application ClassLoader)：或称系统类加载器，负责加载用户classpath下所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><p>类加载器之间的层次关系成为类加载器的双亲委派模型（Parents Delegation Model)。双亲委派模型要求除了顶层了启动类加载器，其他的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是使用组合的方式来复用父加载器的代码。</p></li><li><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去加载。</p></li><li><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>破坏双亲委派模型</p></li><li><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。比如OSGi环境下，类加载不再是双亲委派模型中的树形结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求，OSGi将按照下面的顺序进行类搜索：</p></li></ul><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><ul><li><p>如果我们希望将java类卸载，并且替换更新版本的java类，该怎么做呢？’</p></li><li><p>1、销毁该自定义ClassLoader</p></li><li><p>2、更新class文件</p></li><li><p>3、创建新的ClassLoader去加载更新后的class文件。</p><h1 id="5-21-对象初始化的先后顺序"><a href="#5-21-对象初始化的先后顺序" class="headerlink" title="5.21 对象初始化的先后顺序"></a>5.21 对象初始化的先后顺序</h1></li><li><p>单个类：</p><ul><li>1)类的静态变量清0</li><li>2)静态变量赋值，静态代码块（按照编写顺序调用)</li><li>3)成员变量清0</li><li>4)成员变量赋值，非静态代码块（按照编写顺序调用)</li><li>5)构造方法</li></ul></li><li><p>1、2统称为类的初始化</p></li><li><p>4、5统称为对象初始化</p></li><li><p>带有继承时：</p><ul><li>1)父类类初始化</li><li>2)子类类初始化</li><li>3)成员变量清0，包括父类和子类</li><li>3)父类对象初始化</li><li>4)子类对象初始化</li></ul></li></ul><ul><li>实例一：</li></ul><pre><code>public class StaticTest {    public static void main(String[] args) {        staticFunction();    }    static StaticTest st = new StaticTest();    static {   //静态代码块        System.out.println(&quot;1&quot;);    }    {       // 实例代码块        System.out.println(&quot;2&quot;);    }    StaticTest() {    // 实例构造器        System.out.println(&quot;3&quot;);        System.out.println(&quot;a=&quot; + a + &quot;,b=&quot; + b);    }    public static void staticFunction() {   // 静态方法        System.out.println(&quot;4&quot;);    }    int a = 110;    // 实例变量    static int b = 112;     // 静态变量    /**     main 方法属于静态方法，主动引用，开始执行类的初始化：按照编写顺序进行静态变量赋值与静态代码块执行     1)先初始化StaticTest，对象实例化时，因为类已经被加载，所以执行对象初始化，先对成员变量进行初始化（a赋值为0)，     然后按照编写顺序进行非静态变量赋值与非静态代码块执行（打印2，a赋值为110)，     再调用构造方法（打印3，打印a=110，b=0)     2)再执行静态代码块，打印1     3)再赋值b为112,     4)至此类加载完毕，执行main方法，打印4     2     3     a=110,b=0     1     4     */}</code></pre><ul><li>实例二：</li></ul><pre><code>public class InitializeDemo {    private static int k = 1;    private static InitializeDemo t1 = new InitializeDemo(&quot;t1&quot;);    private static InitializeDemo t2 = new InitializeDemo(&quot;t2&quot;);    private static int i = print(&quot;i&quot;);    private static int n = 99;    static {        print(&quot;静态块&quot;);    }    private int j = print(&quot;j&quot;);    {        print(&quot;构造块&quot;);    }    public InitializeDemo(String str) {        System.out.println((k++) + &quot;:&quot; + str + &quot;   i=&quot; + i + &quot;    n=&quot; + n);        ++i;        ++n;    }    public static int print(String str) {        System.out.println((k++) + &quot;:&quot; + str + &quot;   i=&quot; + i + &quot;    n=&quot; + n);        ++n;        return ++i;    }    public static void main(String args[]) {        new InitializeDemo(&quot;init&quot;);    }} </code></pre><ul><li></li><li><p>1:j   i=0    n=0  </p></li><li><p>2:构造块   i=1    n=1  </p></li><li><p>3:t1   i=2    n=2  </p></li><li><p>4:j   i=3    n=3  </p></li><li><p>5:构造块   i=4    n=4  </p></li><li><p>6:t2   i=5    n=5  </p></li><li><p>7:i   i=6    n=6  </p></li><li><p>8:静态块   i=7    n=99  </p></li><li><p>9:j   i=8    n=100  </p></li><li><p>10:构造块   i=9    n=101  </p></li><li><p>11:init   i=10    n=102  </p></li></ul><ul><li>实例三：</li></ul><pre><code>class Glyph {    void draw() {        System.out.println(&quot;Glyph.draw()&quot;);    }    Glyph() {        System.out.println(&quot;Glyph() before draw()&quot;);        draw();        System.out.println(&quot;Glyph() after draw()&quot;);    }}class RoundGlyph extends Glyph {    private int radius = 1;    RoundGlyph(int r) {        radius = r;        System.out.println(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);    }    void draw() {        System.out.println(&quot;RoundGlyph.draw(), radius = &quot; + radius);    }}public class PolyConstructors {    public static void main(String[] args) {        new RoundGlyph(5);        /**         *         Glyph() before draw()         RoundGlyph.draw(), radius = 0         Glyph() after draw()         RoundGlyph.RoundGlyph(), radius = 5         */    }}  </code></pre><ul><li></li><li></li></ul><h1 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h1><ul><li><p>概述</p></li><li><p>虚拟机的执行引擎不是直接建立在处理器、硬件、指令集和操作系统层面的，而是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并能够执行哪些不被硬件直接支持的指令集格式。</p></li><li><p>在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行和编译执行（通过即时编译器产生本地代码)两种选择，也可能两者兼备。但从外观上看起来，所有的Java虚拟机都是一样的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行过程。</p></li><li><p>运行时栈帧结构</p></li><li><p>栈帧（Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接、返回地址等信息。每一个方法从调用开始至执行完成过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p></li><li><p>在编译程序代码时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p></li><li><p>一个线程中的方法调用链可能会很长，很多方法同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p></li><li><p>局部变量表</p></li><li><p>局部变量表（Local Variable Table)是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p></li><li><p>局部变量表的容量以变量槽（Slot)为最小单位，每个Slot都应该能存放一个boolean、byte、char、short、Reference等类型的数据，允许Slot的长度可以随着处理器、操作系统或虚拟机的实现不同而发生变化。</p></li><li><p>一个Slot可以存放一个对象实例的引用，虚拟机能够通过这个引用做到两点：一是从此引用中直接或间接地查找对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。</p></li><li><p>局部变量表是线程私有的数据，无论读写两个连续的Slot（long、double)是否为原子操作，都不会引起线程安全问题。</p></li><li><p>对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。</p></li><li><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围从0开始至局部变量表最大的Slot数量。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个。</p></li><li><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法，那局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字this来访问到这个隐含的参数。其他参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p></li><li><p>局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那整个变量对应的Slot就可以交给其他变量使用。Slot的复用会直接影响到系统的垃圾收集行为。</p></li><li><p>操作数栈</p></li><li><p>操作数栈（Operand Stack)是一个后进先出栈。操作数栈的最大深度也是在编译的时候就写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深入都不会超过max_stacks。</p></li><li><p>在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。</p></li><li><p>Java虚拟机的解释执行引擎称为基于栈的执行引擎，其中的栈就是操作数栈。</p></li><li><p>动态连接</p></li><li><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking)。Class文件的常量池存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p></li><li><p>方法返回地址</p></li><li><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</p></li><li><p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p></li><li><p>无论何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是通过异常处理器确定的，栈帧中一般不会保存这部分信息。</p></li><li><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出可能的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</p><h1 id="5-22-方法调用"><a href="#5-22-方法调用" class="headerlink" title="5.22 方法调用"></a>5.22 方法调用</h1></li><li><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法)，暂时不涉及方法内部的具体执行过程。Class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在Class文件中存储的都是符号引用，而不是方法在实际运行时内存布局中的入口地址。这个特性使得Java方法调用过程变得复杂，需要在类加载器件，甚至到运行期间才能确定目标方法的直接引用。</p></li><li><p>解析</p></li><li><p>符号引用能转为直接引用成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。</p></li><li><p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法，前者和类型直接关联，后者在外部不可被访问，这两种方法的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p></li><li><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这个方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final)。</p></li><li><p>非虚方法也包含被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法调用者进行多态选择，又或者说多态选择的结果肯定是位移的。</p></li><li><p>解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的组合就构成了静态单分派、静态多分派、动态单分派、动态多分派这4中分派组合情况。</p></li><li><p>分派</p></li><li><p>分派调用过程将会揭示多态性的一些最基本体现，如重载和重写。</p></li><li><p>1、静态分派</p></li><li><p>上面代码中的Human称为变量的静态类型（Static Type)，或者叫做外观类型，后面的Man则称为变量的实际类型（Actual Type)，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会发生改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p></li><li><p>代码中刻意定义了两个静态类型相同但是实际类型不同的变量，但编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译器可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，，所以选择了sayHello（Human)作为调用目标，并把这个方法的符号引用写到main（)方法里的两条invokevirtual指令的参数中。</p></li><li><p>所有依赖静态类型来定位方法执行版本的分派动作被称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是唯一的，往往只能确定一个更加合适的版本。产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式地静态类型，它的静态类型只能通过语言上的规则去理解和推断。</p></li><li><p>2、动态分派</p></li><li><p>重写</p></li></ul><ul><li>导致整个现象的原因很明显，是这两个变量的实际类型不同。</li><li>以下为字节码</li></ul><ul><li><p>由于invokevitual指令执行的第一步就是 在运行期确定接受者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质，我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p></li><li><p>3、单分派与多分派</p></li><li><p>方法的接收者和方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p></li><li><p>今天的Java语言是一门静态多分派、动态单分派的语言。</p></li><li><p>4、虚拟机动态分派的实现</p></li><li><p>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如何频繁的搜索。最常用的稳定优化的方法就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。</p></li><li><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p></li><li><p>为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引编号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p></li><li><p>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p></li><li><p>虚拟机除了使用方法表之外，在条件允许的情况下，还会使用内联缓存和基于类型继承关系分析技术的守护内联两种非稳定的激进优化手段来获得更高的性能。</p></li><li><p>基于栈的字节码解释执行引擎</p></li><li><p>许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行和编译执行两种选择。</p></li><li><p>解释执行</p></li><li><p>Java语言经常被人们定位为解释执行的语言，但当主流的虚拟机都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p></li><li><p>基于栈的指令集和基于寄存器的指令集</p></li><li><p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture,ISA)，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集。</p></li><li><p>计算1+1：</p></li><li><p>前者：</p></li><li><p>后者：</p></li><li><p>基于栈的指令集主要的优点是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。栈架构的指令集还有一些其他的优点，如代码相对更加紧凑、编译器实现更加简单（不需要考虑空间分配，都在栈上操作)等。</p></li><li><p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。</p></li><li><p>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p></li><li></li></ul><h1 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h1><h1 id="5-23-字节码的编译过程（前端编译器"><a href="#5-23-字节码的编译过程（前端编译器" class="headerlink" title="5.23 字节码的编译过程（前端编译器)"></a>5.23 字节码的编译过程（前端编译器)</h1><ul><li><p>Java语言的编译期是一段不确定的操作过程。</p><ul><li>1)编译器前端/前端编译器：把java文件转为class文件，比如Sun的Javac</li><li>2)编译器后端/后端运行时编译器(JIT Just In Time 编译器)：把字节码转为机器码，比如HotSpot VM的C1、C2编译器</li><li>3)静态提前编译器（AOT Ahead Of Time 编译器)：直接把java文件编译为本地机器代码，比如GNU Compiler for the Java（GCJ)。</li></ul></li><li><p>通常意义上的编译器就是前端编译器，这类编译器对代码的运行效率几乎没有任何优化，把对性能的优化集中到了后端编译器，这样可以使其他语言的class文件也同样能享受到编译器优化所带来的好处。</p></li><li><p>但是Javac做了很多针对Java语言编码过程中的优化措施来改善程序员的编码风格和提高编码效率，相当多的新的语法特性都是靠前端编译器的语法糖实现的，而非依赖虚拟机的底层改进来实现。</p></li><li><p>Javac的编译过程大致可以分为三个阶段：</p><ul><li>1)解析和填充符号表</li><li>2)插入式注解处理器的注解处理</li><li>3)语义分析与字节码生成</li></ul></li></ul><h2 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h2><pre><code>- 1)解析包括了词法分析和语法分析两个过程。</code></pre><ul><li>词法分析是将源代码的字符流变为Token序列；</li><li>语法分析是根据Token序列构造抽象语法树AST的过程<ul><li>2)填充符号表</li></ul></li><li>符号表是由一组符号地址和符号信息构成的表格。</li><li>符号表中所登记的信息在编译的不同阶段都要用到。</li></ul><h2 id="插入式注解处理器的注解处理"><a href="#插入式注解处理器的注解处理" class="headerlink" title="插入式注解处理器的注解处理"></a>插入式注解处理器的注解处理</h2><ul><li>插入式注解处理器可以视为一组编译器的插件，可以读取、修改、添加AST中的任意元素。如果在处理注解期间对AST进行了修改，那么编译器将回到解析与填充符号表的过程重新处理，每一次循环称为一个Record。</li></ul><h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><ul><li>语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查。</li><li>语义分析的过程分为Token检查和数据及控制流分析两个阶段。<ul><li>1)Token检查的内容包括变量使用前是否声明、变量和赋值之间的数据类型能否匹配，还有常量折叠等。</li><li>2)数据及控制流分析是对程序上下文逻辑进行更进一步的验证，它可以检查出如程序员局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检异常都被正确处理等。</li><li>3)解语法糖：比如泛型、变长参数、自动装箱/拆箱等</li><li>4)字节码生成：不仅仅是把签个各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作，比如添加实例构造器<init>()和类构造器<client>()。<h1 id="5-24-后端编译器的优化（JIT"><a href="#5-24-后端编译器的优化（JIT" class="headerlink" title="5.24 后端编译器的优化（JIT)"></a>5.24 后端编译器的优化（JIT)</h1></li></ul></li><li>解决以下几个问题：<ul><li>1)为何HotSpot虚拟机要使用解释器和编译器并存的架构</li><li>2)为何HotSpot虚拟机要实现两个不同的JIT</li><li>3)程序何时使用解释器执行，何时使用编译器执行</li><li>4)哪些程序代码会被编译为本地代码，如何编译为本地代码</li><li>5)如何从外部观察JIT的编译过程和编译结果</li></ul></li></ul><h2 id="编译器与解释器"><a href="#编译器与解释器" class="headerlink" title="编译器与解释器"></a>编译器与解释器</h2><ul><li><p>解释器与编译器各有优势，前者节省内存，后者提高效率。</p></li><li><p>在整个虚拟机执行架构中，解释器与编译器经常配合工作。</p></li><li><p>HotSpot虚拟机中内置了两个JIT，分别称为Client Compiler和Server Compiler。在虚拟机中习惯将Client Compiler称为C1，将Server Complier 称为C2。目前主流的HotSpot虚拟机中，默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器取决于虚拟机运行的模式。HotSpot虚拟机会根据自身版本与机器硬件性能自动选择运行模式，用户也可以使用-client或者-server参数去强制指定虚拟机运行的模式。</p></li><li><p>无论采用哪一种编译器，解释器与编译器搭配使用的方式在虚拟机中称为混合模式，用户可以使用参数-Xint强制虚拟机运行于解释模式，这时编译器完全不介入工作；也可以使用参数-Xcomp强制虚拟机运行于编译模式，这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p></li><li><p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机会逐渐启用分层编译的策略。</p></li><li><p>第0层：程序解释执行，解释器不开启性能监控功能，可触发第1层编译</p></li><li><p>第1层：也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必须将加入性能监控的逻辑</p></li><li><p>第2层（或2层以上)：也称为C2编译，也是将字节码编译为本地代码，但是会启动一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p></li><li><p>实时分层编译后，Client Compiler和Server Compiler将会同时工作，很多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compile获取更好的编译质量，在解释执行的时候也无需再承担收集性能监控信息的任务。</p></li></ul><h2 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h2><ul><li><p>在运行过程中被JIT编译的热点代码有两类：</p><ul><li>1)被多次调用的方法</li><li>2)被多次执行的循环体<h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3></li></ul></li><li><p>编译器都会以整个方法作为编译对象。这种编译方式因为编译发生在方法执行过程之中，因此形象地成为栈上替换（On Stack Replacement OSR)。</p></li><li><p>判断一段代码是不是热点代码，是不是需要触发JIT，这样的行为称为热点探测。目前主流的热点探测判定方式有两种：</p><ul><li>1)基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这些方法就是热点方法。好处是简单高效，还可以很容易得获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>2)基于计数器的热点探测：采用这种方法的虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是热点方法。好处是更加精确演进，缺点是实现较为麻烦。</li></ul></li><li><p>HotSpot采用的第二种方法，因为它为每个方法准备了两类计数器：方法调用计数器和回边计数器。这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器加一，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果已超过阈值，那么会向JIT提交一个该方法的代码编译请求。</p></li><li><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的总次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给JIT编译，则这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的衰减，而这段时间就称为此方法统计的半衰周期。</p></li></ul><h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><ul><li>回边计数器的作用是统计一个方法中循环体的代码执行次数，在字节码中遇到控制流向后调换的指令称为回边，回边计数器统计的目的就是为了触发OSR编译。</li><li>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有这已经编译好的版本，如果有，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器之和是否超过回边计数器的阈值。当超过阈值时，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</li><li></li></ul><h2 id="Client-Compiler（编译速度快"><a href="#Client-Compiler（编译速度快" class="headerlink" title="Client Compiler（编译速度快)"></a>Client Compiler（编译速度快)</h2><ul><li>是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</li><li>三段式：<ul><li>1)第一个阶段，一个平台独立的前端会将字节码构造成一种高级中间代码表示（HIR High-Level Intermediate Representation)。HIR使用静态单分配的形式来表示代码值，这使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。</li></ul></li><li>在此之前编译器会在字节码上完成一部分基础优化，如方法内联、常量传播等。<ul><li>2)第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（LIR Low-Level Intermediate Representation)，而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等。</li><li>3)第三个阶段，一个平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器代码。</li></ul></li></ul><h2 id="Server-Compiler（编译质量高"><a href="#Server-Compiler（编译质量高" class="headerlink" title="Server Compiler（编译质量高)"></a>Server Compiler（编译质量高)</h2><ul><li><p>是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的编译器。它会执行所有经典的优化动作，如无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本块重排序等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除、空值检查消除。另外还可能根据解释器或Client Compiler提供的性能监控信息，进行一些不稳定的激进优化，如守护内联、分值预测检测等。</p><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2></li><li><p>语言无关的经典优化技术之一：公共子表达式消除</p></li><li><p>语言相关的经典优化技术之一：数组范围检查消除</p></li><li><p>最重要的优化技术之一：方法内联</p></li><li><p>最前沿的优化技术之一：逃逸分析</p><h3 id="语言相关的优化技术——逃逸分析"><a href="#语言相关的优化技术——逃逸分析" class="headerlink" title="语言相关的优化技术——逃逸分析"></a>语言相关的优化技术——逃逸分析</h3></li><li><p>分析指针动态范围的方法称之为逃逸分析（通俗点讲，当一个对象的指针被多个方法或线程引用时们称这个指针发生了逃逸)。</p></li><li><p>逃逸分析并不是直接的优化手段，而是一个代码分析，通过动态分析对象的作用域，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸。</p></li><li><p>1、方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中；</p></li><li><p>2、线程逃逸：如类变量或实例变量，可能被其它线程访问到；</p></li><li><p>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配。</p></li><li><p>同步消除</p></li><li><p>线程同步本身比较耗，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，则可以消除对该对象的同步锁，通过-XX:+EliminateLocks可以开启同步消除。</p></li><li><p>标量替换</p></li><li><p>1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；</p></li><li><p>2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；</p></li><li><p>3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；</p></li><li><p>通过-XX:+EliminateAllocations可以开启标量替换， -XX:+PrintEliminateAllocations查看标量替换情况。</p></li><li><p>栈上分配</p></li><li><p>故名思议就是在栈上分配对象，其实目前Hotspot并没有实现真正意义上的栈上分配，实际上是标量替换。</p></li></ul><h1 id="性能监控与故障处理工具"><a href="#性能监控与故障处理工具" class="headerlink" title="性能监控与故障处理工具"></a>性能监控与故障处理工具</h1><p>- 如果一个接口调用很慢，原因是，如何定位，没有日志的话：假设一下，复现问题，dump查看内存，查看监控日志<br>- 如何把java内存的数据全部dump出来<br>- 在生产线Dump堆分析程序是否有内存及性能问题<br>- jstack jmap、jconsole 等工具 可视化工具使用；如何线上排查JVM的相关问题？<br>- JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息？<br>- 查看jvm虚拟机里面堆、线程的信息，你用过什么命令？<br>- 内存泄露如何定位</p><h1 id="5-25-JPS：显示所有虚拟机进程"><a href="#5-25-JPS：显示所有虚拟机进程" class="headerlink" title="5.25 JPS：显示所有虚拟机进程"></a>5.25 JPS：显示所有虚拟机进程</h1><h1 id="5-26-JConsole：图形化工具，查询JVM中的内存变化情况。"><a href="#5-26-JConsole：图形化工具，查询JVM中的内存变化情况。" class="headerlink" title="5.26 JConsole：图形化工具，查询JVM中的内存变化情况。"></a>5.26 JConsole：图形化工具，查询JVM中的内存变化情况。</h1><h1 id="5-27-JVisualVM：图形化工具，分析GC趋势、内存消耗情况"><a href="#5-27-JVisualVM：图形化工具，分析GC趋势、内存消耗情况" class="headerlink" title="5.27 JVisualVM：图形化工具，分析GC趋势、内存消耗情况"></a>5.27 JVisualVM：图形化工具，分析GC趋势、内存消耗情况</h1><ul><li>可以分析堆dump文件</li></ul><h1 id="5-28-JMap：命令行工具，查看JVM中各个代的内存状况、JVM中对象的内存的占用状况，以及dump整个JVM中的内存信息。"><a href="#5-28-JMap：命令行工具，查看JVM中各个代的内存状况、JVM中对象的内存的占用状况，以及dump整个JVM中的内存信息。" class="headerlink" title="5.28 JMap：命令行工具，查看JVM中各个代的内存状况、JVM中对象的内存的占用状况，以及dump整个JVM中的内存信息。"></a>5.28 JMap：命令行工具，查看JVM中各个代的内存状况、JVM中对象的内存的占用状况，以及dump整个JVM中的内存信息。</h1><ul><li>jmap –heap [pid] 整个JVM中内存的状况</li><li>jmap –histo [pid]  JVM堆中对象的详细占用情况</li><li>jmap –dump:format=b,file=文件名 [pid] 将整个JVM内存拷贝到文件中</li></ul><h1 id="5-29-JHat-用于分析JVM堆的dump文件：jhat-–J-Xmx1024M-file"><a href="#5-29-JHat-用于分析JVM堆的dump文件：jhat-–J-Xmx1024M-file" class="headerlink" title="5.29 JHat 用于分析JVM堆的dump文件：jhat –J-Xmx1024M [file]"></a>5.29 JHat 用于分析JVM堆的dump文件：jhat –J-Xmx1024M [file]</h1><ul><li>可以通过浏览器访问，端口号是7000.</li></ul><h1 id="5-30-JStack：看到JVM中线程的运行状况，包括锁的等待、线程是否在运行等。"><a href="#5-30-JStack：看到JVM中线程的运行状况，包括锁的等待、线程是否在运行等。" class="headerlink" title="5.30 JStack：看到JVM中线程的运行状况，包括锁的等待、线程是否在运行等。"></a>5.30 JStack：看到JVM中线程的运行状况，包括锁的等待、线程是否在运行等。</h1><ul><li><p>jstack [pid]</p></li><li><p>jstack [option] pid</p></li><li><p>jstack [option] executable core</p></li><li><p>jstack [option] [server-id@]remote-hostname-or-ip</p></li><li><p>命令行参数选项说明如下：</p></li><li><p>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况</p></li><li><p>-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法)</p></li><li><p>jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。</p></li><li><p>第一步先找出Java进程ID，服务器上的Java应用名称为mrf-center：</p></li><li><p>root@ubuntu:/# ps -ef | grep mrf-center | grep -v grep     （或者直接JPS查看进程PID)</p></li><li><p>root     21711     1  1 14:47 pts/3    00:02:10 java -jar mrf-center.jar</p></li><li><p>第二步 top -H -p pid</p></li><li><p>用第三个，输出如下：</p></li><li><p>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                                                        </p></li><li><p>21936 root      20   0 1747m  21m 9404 S  0.0  0.6   0:00.00 java                                                                                                                           </p></li><li><p>21937 root      20   0 1747m  21m 9404 S  0.0  0.6   0:00.14 java                                                                                                                           </p></li><li><p>21938 root      20   0 1747m  21m 9404 S  0.0  0.6   0:00.00 java                                                                                                                           </p></li><li><p>21939 root      20   0 1747m  21m 9404 S  0.0  0.6   0:00.00 java                                                                                                                           </p></li><li><p>21940 root      20   0 1747m  21m 9404 S  0.0  0.6   0:00.00 java                                                                                                                           </p></li><li><p>TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用</p></li><li><p>printf “%x\n” 21742</p></li><li><p>得到21742的十六进制值为54ee，下面会用到。</p></li><li><p>OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p></li><li><p>root@ubuntu:/# jstack 21711 | grep 54ee</p></li><li><p>“PollIntervalRetrySchedulerThread” prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait()</p></li><li><p>可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码：</p></li><li><p>// Idle wait</p></li><li><p>getLog().info(“Thread [“ + getName() + “] is idle waiting…”);</p></li><li><p>schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;</p></li><li><p>long now = System.currentTimeMillis();</p></li><li><p>long waitTime = now + getIdleWaitTime();</p></li><li><p>long timeUntilContinue = waitTime - now;</p></li><li><p>synchronized(sigLock) {</p></li><li><p>try {</p></li><li><p>if(!halted.get()) {</p></li><li><p>sigLock.wait(timeUntilContinue);</p></li><li><p>}</p></li><li><p>} </p></li><li><p>catch (InterruptedException ignore) {</p></li><li><p>}</p></li><li><p>}</p></li><li><p>它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p><h1 id="5-31-JStat：JVM统计监测工具"><a href="#5-31-JStat：JVM统计监测工具" class="headerlink" title="5.31 JStat：JVM统计监测工具"></a>5.31 JStat：JVM统计监测工具</h1></li><li><p>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</p></li><li><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。</p></li><li><p>比如下面输出的是GC信息，采样时间间隔为250ms，采样数为4：</p></li><li><p>root@ubuntu:/# jstat -gc 21711 250 4</p></li><li><p>S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   </p></li><li><p>192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</p></li><li><p>192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</p></li><li><p>192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</p></li><li><p>192.0  192.0   64.0   0.0    6144.0   2109.7   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</p></li><li><p>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity)和使用量（Used)</p></li><li><p>EC、EU：Eden区容量和使用量</p></li><li><p>OC、OU：年老代容量和使用量</p></li><li><p>PC、PU：永久代容量和使用量</p></li><li><p>YGC、YGT：年轻代GC次数和GC耗时</p></li><li><p>FGC、FGCT：Full GC次数和Full GC耗时</p></li><li><p>GCT：GC总耗时</p><h1 id="5-32-MAT-可视化分析dump文件"><a href="#5-32-MAT-可视化分析dump文件" class="headerlink" title="5.32 MAT 可视化分析dump文件"></a>5.32 MAT 可视化分析dump文件</h1></li><li><p>Memory Analyzer Tool</p></li><li></li></ul><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h1 id="5-33-参数"><a href="#5-33-参数" class="headerlink" title="5.33 参数"></a>5.33 参数</h1><h2 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h2><ul><li>-Xms:初始堆大小 </li><li>-Xmx:最大堆大小 </li><li>-Xmn年轻代大小</li><li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 </li><li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 <h2 id="栈设置"><a href="#栈设置" class="headerlink" title="栈设置"></a>栈设置</h2></li><li>-Xss 设置每个线程的栈大小<h2 id="元数据区设置"><a href="#元数据区设置" class="headerlink" title="元数据区设置"></a>元数据区设置</h2></li><li>-XX:MetaspaceSize -XX:MaxMetaspaceSize 元数据区的初始大小和最大大小</li></ul><h2 id="异常设置"><a href="#异常设置" class="headerlink" title="异常设置"></a>异常设置</h2><ul><li>-XX:+HeapDumpOnOutOfMemoryError 使得JVM在产生内存溢出时自动生成堆内存快照（日后再进行分析，写监控脚本，如果发现应用崩溃则重启，并提醒开发人员去查看dump信息)</li><li>-XX:HeapDumpPath 改变默认的堆内存快照生成路径，<path>可以是相对或者绝对路径</li><li>-XX:OnOutOfMemoryError 当内存发生溢出时 执行一串指令</li></ul><h2 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h2><ul><li><p>-XX:+UseSerialGC:设置串行收集器 </p></li><li><p>-XX:+UseParallelGC:设置并行收集器 </p></li><li><p>-XX:+UseParalledlOldGC:设置并行年老代收集器 </p></li><li><p>-XX:+UseConcMarkSweepGC:设置并发收集器</p><h2 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h2></li><li><p>-XX:+PrintGC </p></li><li><p>-XX:+PrintGCDetails </p></li><li><p>-XX:+PrintGCTimeStamps </p></li><li><p>-Xloggc:filename</p><h2 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h2></li><li><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。 </p></li><li><p>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间 </p></li><li><p>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p><h2 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h2></li><li><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。 </p></li><li><p>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><h1 id="5-34-调优原则"><a href="#5-34-调优原则" class="headerlink" title="5.34 调优原则"></a>5.34 调优原则</h1></li><li><p>JVM的内存参数；xmx,xms,xmn,xss参数你有调优过吗，设置大小和原则你能介绍一下吗？；Xss默认大小，在实际项目中你一般会设置多大</p></li><li><p>对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU)，影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理。</p></li></ul><h2 id="代大小的调优"><a href="#代大小的调优" class="headerlink" title="代大小的调优"></a>代大小的调优</h2><ul><li><ol><li>避免新生代大小设置过小，过小的话一是minor GC更加频繁，二是有可能导致minor GC对象直接进入老年代，此时如进入老年代的对象占据了老年代剩余空间，则触发Full GC。</li></ol></li><li><ol start="2"><li>避免新生代大小设置过大，过大的话一是老年代变小了，有可能导致Full GC频繁执行，二是minor GC的耗时大幅度增加。</li></ol></li><li><ol start="3"><li>避免Survivor区过小或过大</li></ol></li><li><ol start="4"><li>合理设置新生代存活周期，存活周期决定了新生代的对象经过多少次Minor GC后进入老年代，对应的JVM参数是-XX;MaxTenuringThreshold。</li></ol></li></ul><h2 id="GC策略的调优"><a href="#GC策略的调优" class="headerlink" title="GC策略的调优"></a>GC策略的调优</h2><ul><li><p>串行GC性能太差，在实际场景中使用的主要为并行和并发GC。</p></li><li><p>由于CMS GC多数动作是和应用并发进行的，确实可以减小GC给应用带来的暂停。</p></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一、Java基础</title>
      <link href="//post/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80.html"/>
      <url>//post/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ul><li><p>Oracle JDK有部分源码是闭源的，如果确实需要可以查看OpenJDK的源码，可以在该网站获取。</p></li><li><p><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/" target="_blank" rel="noopener">http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/</a></p></li><li><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/73d5bcd0585d/src" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/73d5bcd0585d/src</a></p></li><li><p>上面这个还可以查看native方法。</p><h1 id="1-1-JDK-amp-JRE-amp-JVM"><a href="#1-1-JDK-amp-JRE-amp-JVM" class="headerlink" title="1.1 JDK&amp;JRE&amp;JVM"></a>1.1 JDK&amp;JRE&amp;JVM</h1></li><li><p>JDK（Java Development Kit)是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具（编译、开发工具)和Java核心类库。</p></li><li><p>Java Runtime Environment（JRE)是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。</p></li><li><p>JVM是Java Virtual Machine（Java虚拟机)的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</p></li><li><p>JDK包含JRE和Java编译、开发工具；</p></li><li><p>JRE包含JVM和Java核心类库；</p></li><li><p>运行Java仅需要JRE；而开发Java需要JDK。</p><h1 id="1-2-跨平台"><a href="#1-2-跨平台" class="headerlink" title="1.2 跨平台"></a>1.2 跨平台</h1></li><li><p>字节码是在虚拟机上运行的，而不是编译器。换而言之，是因为JVM能跨平台安装，所以相应JAVA字节码便可以跟着在任何平台上运行。只要JVM自身的代码能在相应平台上运行，即JVM可行，则JAVA的程序员就可以不用考虑所写的程序要在哪里运行，反正都是在虚拟机上运行，然后变成相应平台的机器语言，而这个转变并不是程序员应该关心的。</p><h1 id="1-3-基础数据类型"><a href="#1-3-基础数据类型" class="headerlink" title="1.3 基础数据类型"></a>1.3 基础数据类型</h1></li><li><p>第一类：整型 byte short int long </p></li><li><p>第二类：浮点型 float double</p></li><li><p>第三类：逻辑型 boolean(它只有两个值可取true false)</p></li><li><p>第四类：字符型 char</p><ul><li>byte(1)的取值范围为-128~127（-2的7次方到2的7次方-1)</li><li>short(2)的取值范围为-32768~32767（-2的15次方到2的15次方-1)</li><li>int(4)的取值范围为（-2147483648~2147483647)（-2的31次方到2的31次方-1)</li><li>long(8)的取值范围为（-9223372036854774808~9223372036854774807)（-2的63次方到2的63次方-1)</li><li>float(4)</li><li>double(8)</li><li>char(2)</li><li>boolean(1/8)</li></ul></li><li><p>内码是程序内部使用的字符编码，特别是某种语言实现其char或String类型在内存里用的内部编码；外码是程序与外部交互时外部使用的字符编码。“外部”相对“内部”而言；不是char或String在内存里用的内部编码的地方都可以认为是“外部”。例如，外部可以是序列化之后的char或String，或者外部的文件、命令行参数之类的。</p></li><li><p>Java语言规范规定，Java的char类型是UTF-16的code unit，也就是一定是16位（2字节)，然后字符串是UTF-16 code unit的序列。</p></li><li><p>Java规定了字符的内码要用UTF-16编码。或者至少要让用户无法感知到String内部采用了非UTF-16的编码。</p></li><li><p>String.getBytes()是一个用于将String的内码转换为指定的外码的方法。无参数版使用平台的默认编码作为外码，有参数版使用参数指定的编码作为外码；将String的内容用外码编码好，结果放在一个新byte[]返回。调用了String.getBytes()之后得到的byte[]只能表明该外码的性质，而无法碰触到String内码的任何特质。</p><ul><li>Java标准库实现的对char与String的序列化规定使用UTF-8作为外码。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16)与外部存储的空间效率（采用变长的UTF-8编码)而做的取舍。</li></ul></li></ul><h1 id="1-4-引用类型"><a href="#1-4-引用类型" class="headerlink" title="1.4 引用类型"></a>1.4 引用类型</h1><ul><li>类、接口、数组都是引用类型<h2 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h2></li><li>目的：避免对象长期占用内存，</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><ul><li><p>StringReference GC时不回收</p></li><li><p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3></li><li><p>SoftReference GC时如果JVM内存不足时会回收</p></li><li><p>软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3></li><li><p>WeakReference GC时立即回收</p></li><li><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p></li><li><p>弱引用可以和一个引用队列（ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3></li><li><p>PhantomReference </p></li><li><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p></li><li><p>在Java集合中有一种特殊的Map类型：WeakHashMap， 在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收，那么相应的值对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。</p><h2 id="基础数据类型包装类"><a href="#基础数据类型包装类" class="headerlink" title="基础数据类型包装类"></a>基础数据类型包装类</h2><h3 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h3></li><li><p>由于基本数据类型不是对象，所以java并不是纯面向对象的语言，好处是效率较高（全部包装为对象效率较低)。</p></li><li><p>Java是一个面向对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型)，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p></li><li></li></ul><h3 id="有哪些"><a href="#有哪些" class="headerlink" title="有哪些"></a>有哪些</h3><p> 基本类型        包装器类型<br>boolean    Boolean<br>char    Character<br>int    Integer<br>byte    Byte<br>short    Short<br>long    Long<br>float    Float<br>double    Double</p><ul><li><p>Number是所有数字包装类的父类</p><h3 id="自动装箱、自动拆箱（编译器行为"><a href="#自动装箱、自动拆箱（编译器行为" class="headerlink" title="自动装箱、自动拆箱（编译器行为)"></a>自动装箱、自动拆箱（编译器行为)</h3></li><li><p>自动装箱：可以将基础数据类型包装成对应的包装类</p></li><li><p>Integer i = 10000; // 编译器会改为new Integer(10000)</p></li><li><p>自动拆箱：可以将包装类转为对应的基础数据类型</p></li><li><p>int i = new Integer(1000);//编译器会修改为   int i = new Integer(1000).intValue();</p></li><li><p>自动拆箱时如果包装类是null，那么会抛出NPE</p><h3 id="Integer-valueOf"><a href="#Integer-valueOf" class="headerlink" title="Integer.valueOf"></a>Integer.valueOf</h3></li></ul><pre><code>public static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}</code></pre><ul><li>调用Integer.valueOf时-128~127的对象被缓存起来。</li><li>所以在此访问内的Integer对象使用==和equals结果是一样的。</li><li>如果Integer的值一致，且在此范围内，因为是同一个对象，所以==返回true；但此访问之外的对象==比较的是内存地址，值相同，也是返回false。</li></ul><h1 id="1-5-Object"><a href="#1-5-Object" class="headerlink" title="1.5 Object"></a>1.5 Object</h1><h2 id="与-equals的区别"><a href="#与-equals的区别" class="headerlink" title="== 与 equals的区别"></a>== 与 equals的区别</h2><ul><li>如果两个引用类型变量使用==运算符，那么比较的是地址，它们分别指向的是否是同一地址的对象。结果一定是false，因为两个对象不可能存放在同一地址处。</li><li>要求是两个对象都不是能空值，与空值比较返回false。</li><li>==不能实现比较对象的值是否相同。</li><li>所有对象都有equals方法，默认是Object类的equals，其结果与==一样。</li><li>如果希望比较对象的值相同，必须重写equals方法。<h2 id="hashCode与equals的区别"><a href="#hashCode与equals的区别" class="headerlink" title="hashCode与equals的区别"></a>hashCode与equals的区别</h2></li><li>Object中的equals:</li></ul><pre><code>public boolean equals(Object obj) {    return (this == obj);}</code></pre><ul><li><p>equals 方法要求满足：</p></li><li><p>自反性 a.equals(a)</p></li><li><p>对称性 x.equals(y)  y.equals(x)</p></li><li><p>一致性 x.equals(y)  多次调用结果一致</p></li><li><p>对于任意非空引用x，x.equals(null) 应该返回false</p></li><li><p>Object中的hashCode:</p></li></ul><pre><code>public native int hashCode();</code></pre><ul><li><p>它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置。</p></li><li><p>当equals方法被重写时，通常有必要重写hashCode方法，以维护hashCode方法的常规约定：值相同的对象必须有相同的hashCode。</p><ul><li>object1.equals(object2)为true，hashCode也相同；</li><li>hashCode不同时，object1.equals(object2)为false；</li><li>hashCode相同时，object1.equals(object2)不一定为true；</li></ul></li><li><p>当我们向一个Hash结构的集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则链到后面（如果是链地址法)。</p></li><li><p>先调用hashCode，唯一则存储，不唯一则再调用equals，结果相同则不再存储，结果不同则散列到其他位置。因为hashCode效率更高（仅为一个int值)，比较起来更快。</p></li><li><p>HashMap#put源码 </p></li><li><p>hash是key的hash值，当该hash对应的位置已有元素时会执行以下代码（hashCode相同)</p></li><li><p>if (p.hash == hash &amp;&amp;<br>  ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>  e = p;</p></li><li><p>如果equals返回结果相同，则值一定相同，不再存入。</p><h2 id="如果重写equals不重写hashCode会怎样"><a href="#如果重写equals不重写hashCode会怎样" class="headerlink" title="如果重写equals不重写hashCode会怎样"></a>如果重写equals不重写hashCode会怎样</h2></li><li><p>两个值不同的对象的hashCode一定不一样，那么执行equals，结果为true，HashSet或HashMap的键会放入值相同的对象。</p><h1 id="1-6-String-amp-StringBuffer-amp-StringBuilder"><a href="#1-6-String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="1.6 String&amp;StringBuffer&amp;StringBuilder"></a>1.6 String&amp;StringBuffer&amp;StringBuilder</h1></li><li><p>都是final类，不允许继承；</p></li><li><p>String长度不可变，StringBuffer、StringBuilder长度可变；</p></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}</code></pre><h3 id="equals-amp-hashCode"><a href="#equals-amp-hashCode" class="headerlink" title="equals&amp;hashCode"></a>equals&amp;hashCode</h3><ul><li>String重写了Object的hashCode和equals。</li></ul><pre><code>public boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                    return false;                i++;            }            return true;        }    }    return false;}</code></pre><h3 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h3><ul><li><p>String是final类，不可被继承，也不可重写一个java.lang.String（类加载机制)。</p></li><li><p>一般是使用StringUtils来增强String的功能。</p></li><li><p>为什么只加载系统通过的java.lang.String类而不加载用户自定义的java.lang.String类呢？</p></li><li><p>双亲委派机制</p></li><li><p>因加载某个类时，优先使用父类加载器加载需要使用的类。如果我们自定义了java.lang.String这个类，</p></li><li><p>加载该自定义的String类，该自定义String类使用的加载器是AppClassLoader，根据优先使用父类加载器原理，</p></li><li><p>AppClassLoader加载器的父类为ExtClassLoader，所以这时加载String使用的类加载器是ExtClassLoader，</p></li><li><p>但是类加载器ExtClassLoader在jre/lib/ext目录下没有找到String.class类。然后使用ExtClassLoader父类的加载器BootStrap，</p></li><li><p>父类加载器BootStrap在JRE/lib目录的rt.jar找到了String.class，将其加载到内存中。这就是类加载器的委托机制。</p></li><li><p>所以，用户自定义的java.lang.String不被加载，也就是不会被使用。</p><h3 id="substring"><a href="#substring" class="headerlink" title="+  substring"></a>+  substring</h3></li><li><p>会创建一个新的字符串；</p></li><li><p>编译时会将+转为StringBuilder的append方法。</p></li><li><p>注意新的字符串是在运行时在堆里创建的。</p></li><li><p>String str1 = “ABC”;可能创建一个或者不创建对象，如果”ABC”这个字符串在java String池里不存在，会在java String池里创建一个创建一个String对象(“ABC”)，然后str1指向这个内存地址，无论以后用这种方式创建多少个值为”ABC”的字符串对象，始终只有一个内存地址被分配，之后的都是String的拷贝，Java中称为“字符串驻留”，所有的字符串常量都会在编译之后自动地驻留。</p></li><li></li><li><p>注意只有字符串常量是共享的，+和substring等操作的结果不是共享的，substring也会在堆中重新创建字符串。</p></li></ul><pre><code>public String substring(int beginIndex, int endIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    if (endIndex &gt; value.length) {        throw new StringIndexOutOfBoundsException(endIndex);    }    int subLen = endIndex - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this            : new String(value, beginIndex, subLen);}</code></pre><pre><code>public String(char value[], int offset, int count) {    if (offset &lt; 0) {        throw new StringIndexOutOfBoundsException(offset);    }    if (count &lt;= 0) {        if (count &lt; 0) {            throw new StringIndexOutOfBoundsException(count);        }        if (offset &lt;= value.length) {            this.value = &quot;&quot;.value;            return;        }    }    // Note: offset or count might be near -1&gt;&gt;&gt;1.    if (offset &gt; value.length - count) {        throw new StringIndexOutOfBoundsException(offset + count);    }    this.value = Arrays.copyOfRange(value, offset, offset+count);}</code></pre><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ul><li><p>String str = new String(“ABC”);</p></li><li><p>至少创建一个对象，也可能两个。因为用到new关键字，肯定会在heap中创建一个str2的String对象，它的value是“ABC”。同时如果这个字符串在字符串常量池里不存在，会在池里创建这个String对象“ABC”。</p></li><li><p>String s1= “a”;</p></li><li><p>String s2 = “a”;</p></li><li><p>此时s1 == s2 返回true</p></li><li><p>String s1= new String(“a”);</p></li><li><p>String s2 = new String(“a”);</p></li><li><p>此时s1 == s2 返回false</p></li><li><p>“”创建的字符串在字符串池中。</p></li><li><p>如果引号中字符串存在在常量池中，则仅在堆中拷贝一份(new String);</p></li><li><p>如果不在，那么会先在常量池中创建一份(“abc”)，然后在堆中创建一份(new String)，共创建两个对象。</p></li><li></li></ul><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><ul><li><p>字面量，final 都会在编译期被优化，并且会被直接运算好。</p></li><li><ul><li>1)注意c和d中，final变量b已经被替换为其字符串常量了。</li><li>2)注意f、g中，b被替换为其字符串常量，并且在编译时字符串常量的+运算会被执行，返回拼接后的字符串常量</li><li>3)注意j，a1作为final变量，在编译时被替换为其字符串常量</li></ul></li><li><p>解释 c == h / d == h/ e== h为false：c是运行时使用+拼接，创建了一个新的堆中的字符串ab，与ab字符串常量不是同一个对象；</p></li><li><p>解释f == h/ g == h为true：f编译时进行优化，其值即为字符串常量ab，h也是，指向字符串常量池中的同一个对象；</p></li></ul><ul><li><p>String#intern（JDK1.7之后)</p></li><li><p>JDK1.7之后JVM里字符串常量池放入了堆中，之前是放在方法区。</p></li><li><p>intern()方法设计的初衷，就是重用String对象，以节省内存消耗。</p></li><li><p>一定是new得到的字符串才会调用intern，字符串常量没有必要去intern。</p></li><li><p>当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定)，则返回池中的字符串。否则，常量池中直接存储堆中该字符串的引用（1.7之前是常量池中再保存一份该字符串)。</p></li><li><p>源码</p></li></ul><pre><code>public native String intern();</code></pre><ul><li><p>实例一：</p><ul><li>String s = new String(“1”);<br>s.intern();<br>String s2 = “1”;<br>System.out.println(s == s2);// false</li></ul></li></ul><p>String s3 = new String(“1”) + new String(“1”);<br>s3.intern();<br>String s4 = “11”;<br>System.out.println(s3 == s4);// true</p><ul><li><p>String s = newString(“1”)，生成了常量池中的“1” 和堆空间中的字符串对象。</p></li><li><p>s.intern()，这一行的作用是s对象去常量池中寻找后发现”1”已经存在于常量池中了。</p></li><li><p>String s2 = “1”，这行代码是生成一个s2的引用指向常量池中的“1”对象。</p></li><li><p>结果就是 s 和 s2 的引用地址明显不同。因此返回了false。</p></li><li><p>String s3 = new String(“1”) + newString(“1”)，这行代码在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为”11”)。注意此时常量池中是没有 “11”对象的。</p></li><li><p>s3.intern()，这一行代码，是将 s3中的“11”字符串放入 String 常量池中，此时常量池中不存在“11”字符串，JDK1.6的做法是直接在常量池中生成一个 “11” 的对象。</p></li><li><p>但是在JDK1.7中，常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用直接指向 s3 引用的对象，也就是说s3.intern() ==s3会返回true。</p></li><li><p>String s4 = “11”， 这一行代码会直接去常量池中创建，但是发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。因此s3 == s4返回了true。</p></li><li><p>实例二：</p><ul><li>String s3 = new String(“1”) + new String(“1”);<br>String s4 = “11”;<br>s3.intern();<br>System.out.println(s3 == s4);// false</li></ul></li><li><p>String s3 = new String(“1”) + newString(“1”)，这行代码在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为”11”)。注意此时常量池中是没有 “11”对象的。</p></li><li><p>String s4 = “11”， 这一行代码会直接去生成常量池中的”11”。</p></li><li><p>s3.intern()，这一行在这里就没什么实际作用了。因为”11”已经存在了。</p></li><li><p>结果就是 s3 和 s4 的引用地址明显不同。因此返回了false。</p></li><li><p>实例三：</p><ul><li>String str1 = new String(“SEU”) + new String(“Calvin”);<br>System.out.println(str1.intern() == str1);// true<br>System.out.println(str1 == “SEUCalvin”);// true</li></ul></li><li><p>str1.intern() == str1就是上面例子中的情况，str1.intern()发现常量池中不存在“SEUCalvin”，因此指向了str1。 “SEUCalvin”在常量池中创建时，也就直接指向了str1了。两个都返回true就理所当然啦。</p></li></ul><ul><li><p>实例四：</p><ul><li>String str2 = “SEUCalvin”;//新加的一行代码，其余不变<br>String str1 = new String(“SEU”) + new String(“Calvin”);<br>System.out.println(str1.intern() == str1);// false<br>System.out.println(str1 == “SEUCalvin”);// false</li></ul></li><li><p>在实例三的基础上加了第一行</p></li><li><p>str2先在常量池中创建了“SEUCalvin”，那么str1.intern()当然就直接指向了str2，你可以去验证它们两个是返回的true。后面的”SEUCalvin”也一样指向str2。所以谁都不搭理在堆空间中的str1了，所以都返回了false。</p><h2 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer&amp;StringBuilder"></a>StringBuffer&amp;StringBuilder</h2></li><li><p>StringBuffer是线程安全的，StringBuilder不是线程安全的，但它们两个中的所有方法都是相同的。StringBuffer在StringBuilder的方法之上添加了synchronized，保证线程安全。</p></li><li><p>StringBuilder比StringBuffer性能更好。</p></li><li></li></ul><h1 id="1-7-面向对象"><a href="#1-7-面向对象" class="headerlink" title="1.7 面向对象"></a>1.7 面向对象</h1><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><ul><li><p>区别：</p><ul><li>1)抽象类中方法可以不是抽象的；接口中的方法必须是抽象方法；</li><li>2)抽象类中可以有普通的成员变量；接口中的变量必须是 static final 类型的，必须被初始化 , 接口中只有常量，没有变量。</li><li>3)抽象类只能单继承，接口可以继承多个父接口；</li><li>4)Java8 中接口中会有 default 方法，即方法可以被实现。</li></ul></li><li><p>使用场景：</p></li><li><p>如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。</p></li><li><p>如果知道某个类应该是基类，那么第一个选择的应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。因为抽象类中允许存在一个或多个被具体实现的方法，只要方法没有被全部实现该类就仍是抽象类。</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2></li><li><p>面向对象的三个特性：封装；继承；多态</p></li><li><p>封装：将数据与操作数据的方法绑定起来，隐藏实现细节，对外提供接口。</p></li><li><p>继承：代码重用；可扩展性</p></li><li><p>多态：允许不同子类对象对同一消息做出不同响应</p></li><li><p>多态的三个必要条件：继承、方法的重写、父类引用指向子类对象</p><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2></li><li><p>根据对象对方法进行选择，称为分派</p></li><li><p>编译期的静态多分派：overloading重载 根据调用引用类型和方法参数决定调用哪个方法（编译器)</p></li><li><p>运行期的动态单分派：overriding 重写 根据指向对象的类型决定调用哪个方法（JVM)</p></li><li></li></ul><h1 id="1-8-关键类"><a href="#1-8-关键类" class="headerlink" title="1.8 关键类"></a>1.8 关键类</h1><h2 id="ThreadLocal（线程局部变量"><a href="#ThreadLocal（线程局部变量" class="headerlink" title="ThreadLocal（线程局部变量)"></a>ThreadLocal（线程局部变量)</h2><ul><li>在线程之间共享变量是存在风险的，有时可能要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。</li><li>例如有一个静态变量</li></ul><pre><code>public static final SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);</code></pre><ul><li>如果两个线程同时调用sdf.format(…)</li><li>那么可能会很混乱，因为sdf使用的内部数据结构可能会被并发的访问所破坏。当然可以使用线程同步，但是开销很大；或者也可以在需要时构造一个局部SImpleDateFormat对象。但这很浪费。</li><li>希望为每一个线程构造一个对象，即使该线程调用多次方法，也只需要构造一次，不必在局部每次都构造。</li></ul><pre><code>public static final ThreadLocal&lt;SimpleDateFormat&gt; sdf = new ThreadLocal&lt;SimpleDateFormat&gt;() {    @Override    protected SimpleDateFormat initialValue() {        return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    }};</code></pre><ul><li>实现原理：<h3 id="1-每个线程的变量副本是存储在哪里的"><a href="#1-每个线程的变量副本是存储在哪里的" class="headerlink" title="1)每个线程的变量副本是存储在哪里的"></a>1)每个线程的变量副本是存储在哪里的</h3></li><li>ThreadLocal的get方法就是从当前线程的ThreadLocalMap中取出当前线程对应的变量的副本。该Map的key是ThreadLocal对象，value是当前线程对应的变量。</li></ul><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings(&quot;unchecked&quot;)            T result = (T)e.value;            return result;        }    }    return setInitialValue();}</code></pre><ul><li><p>ThreadLocalMap getMap(Thread t) {<br>  return t.threadLocals;<br>}</p></li><li><p>【注意，变量是保存在线程中的，而不是保存在ThreadLocal变量中】。当前线程中，有一个变量引用名字是threadLocals，这个引用是在ThreadLocal类中createmap函数内初始化的。</p></li><li><p>void createMap(Thread t, T firstValue) {<br>  t.threadLocals = new ThreadLocalMap(this, firstValue);<br>}</p></li><li><p>每个线程都有一个这样的名为threadLocals 的ThreadLocalMap，以ThreadLocal和ThreadLocal对象声明的变量类型作为key和value。</p></li><li><p>Thread</p></li><li><p>ThreadLocal.ThreadLocalMap threadLocals = null;</p></li><li><p>这样，我们所使用的ThreadLocal变量的实际数据，通过get方法取值的时候，就是通过取出Thread中threadLocals引用的map，然后从这个map中根据当前threadLocal作为参数，取出数据。现在，变量的副本从哪里取出来的（本文章提出的第一个问题)已经确认解决了。</p></li><li><p>每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对)，相应的线程被称为这些 Entry 的属主线程；</p></li><li><p>Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；</p></li><li><p>Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。</p><h3 id="2-为什么ThreadLocalMap的Key是弱引用"><a href="#2-为什么ThreadLocalMap的Key是弱引用" class="headerlink" title="2)为什么ThreadLocalMap的Key是弱引用"></a>2)为什么ThreadLocalMap的Key是弱引用</h3></li><li><p>如果是强引用，ThreadLocal将无法被释放内存。</p></li><li><p>因为如果这里使用普通的key-value形式来定义存储结构，实质上就会造成节点的生命周期与线程强绑定，只要线程没有销毁，那么节点在GC分析中一直处于可达状态，没办法被回收，而程序本身也无法判断是否可以清理节点。弱引用是Java中四档引用的第三档，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的键值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。</p><h3 id="3-ThreadLocalMap是何时初始化的（setInitialValue"><a href="#3-ThreadLocalMap是何时初始化的（setInitialValue" class="headerlink" title="3)ThreadLocalMap是何时初始化的（setInitialValue)"></a>3)ThreadLocalMap是何时初始化的（setInitialValue)</h3></li><li><p>在get时最后一行调用了setInitialValue，它又调用了我们自己重写的initialValue方法获得要线程局部变量对象。ThreadLocalMap没有被初始化的话，便初始化，并设置firstKey和firstValue；如果已经被初始化，那么将key和value放入map。</p></li></ul><pre><code>private T setInitialValue() {    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);    return value;}</code></pre><h3 id="4-ThreadLocalMap-原理"><a href="#4-ThreadLocalMap-原理" class="headerlink" title="4)ThreadLocalMap 原理"></a>4)ThreadLocalMap 原理</h3><pre><code>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) {        super(k);        value = v;    }}</code></pre><ul><li>它也是一个类似HashMap的数据结构，但是并没实现Map接口。</li><li>也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中。</li><li>ThreadLoalMap的Entry是继承WeakReference，和HashMap很大的区别是，Entry中没有next字段，所以就不存在链表的情况了。<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4></li><li>ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {<ul><li>// 表的大小始终为2的幂次<br>table = new Entry[INITIAL_CAPACITY];<br>int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);<br>table[i] = new Entry(firstKey, firstValue);<br>size = 1;</li></ul></li><li>// 设定扩容阈值<br>  setThreshold(INITIAL_CAPACITY);<br>}<ul><li>在ThreadLocalMap中，形如key.threadLocalHashCode &amp; (table.length - 1)（其中key为一个ThreadLocal实例)这样的代码片段实质上就是在求一个ThreadLocal实例的哈希值，只是在源码实现中没有将其抽为一个公用函数。</li><li>对于&amp; (INITIAL_CAPACITY - 1)，相对于2的幂作为模数取模，可以用&amp;(2^n-1)来替代%2^n，位运算比取模效率高很多。至于为什么，因为对2^n取模，只要不是低n位对结果的贡献显然都是0，会影响结果的只能是低n位。</li></ul></li></ul><pre><code>private void setThreshold(int len) {    threshold = len * 2 / 3;}</code></pre><ul><li>getEntry（由ThreadLocal#get调用)</li></ul><pre><code>private Entry getEntry(ThreadLocal&lt;?&gt; key) {    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    if (e != null &amp;&amp; e.get() == key)        return e;    else</code></pre><ul><li>// 因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的。<pre><code>  return getEntryAfterMiss(key, i, e);</code></pre>}</li></ul><pre><code>private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {    Entry[] tab = table;    int len = tab.length;    while (e != null) {        ThreadLocal&lt;?&gt; k = e.get();        if (k == key)            return e;        if (k == null)</code></pre><ul><li><p>// 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry            </p></li><li><p>expungeStaleEntry(i);</p><pre><code>  else      i = nextIndex(i, len);  e = tab[i];</code></pre><p>  }<br>  return null;<br>}</p></li><li><p>i是位置</p></li><li><p>从staleSlot开始遍历，将无效key（弱引用指向对象被回收)清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。</p></li><li><p>另外，在过程中还会对非空的entry作rehash。</p></li><li><p>可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等)</p></li></ul><pre><code>private int expungeStaleEntry(int staleSlot) {    Entry[] tab = table;    int len = tab.length;    // expunge entry at staleSlot    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;    // Rehash until we encounter null    Entry e;    int i;    for (i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        ThreadLocal&lt;?&gt; k = e.get();        if (k == null) {            e.value = null;            tab[i] = null;            size--;        } else {</code></pre><ul><li><p>// 对于还没有被回收的情况，需要做一次rehash。</p></li><li><p>如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</p><ul><li><p>则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。<br>int h = k.threadLocalHashCode &amp; (len - 1);<br>if (h != i) {<br>tab[i] = null;</p><p>// Unlike Knuth 6.4 Algorithm R, we must scan until<br>// null because multiple entries could have been stale.<br>while (tab[h] != null)<br>h = nextIndex(h, len);<br>tab[h] = e;<br>}<br>}<br>}<br>return i;<br>}</p></li></ul></li></ul><h4 id="set（线性探测法解决hash冲突"><a href="#set（线性探测法解决hash冲突" class="headerlink" title="set（线性探测法解决hash冲突)"></a>set（线性探测法解决hash冲突)</h4><pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {    // We don&#39;t use a fast path as with get() because it is at    // least as common to use set() to create new entries as    // it is to replace existing ones, in which case, a fast    // path would fail more often than not.    Entry[] tab = table;    int len = tab.length;    // 计算key的hash值</code></pre><pre><code>- int i = key.threadLocalHashCode &amp; (len-1);for (Entry e = tab[i];     e != null;     e = tab[i = nextIndex(i, len)]) {    ThreadLocal&lt;?&gt; k = e.get();    if (k == key) {</code></pre><ul><li><p>// 同一个ThreadLocal赋了新值，则替换原值为新值</p><pre><code>      e.value = value;      return;  }  if (k == null) {</code></pre></li><li><p>// 该位置的TheadLocal已经被回收，那么会清理slot并在此位置放入当前key和value（stale：陈旧的)</p><pre><code>      replaceStaleEntry(key, value, i);      return;  }</code></pre><p>  }<br>  // 下一个位置为空，那么就放到该位置上<br>  tab[i] = new Entry(key, value);<br>  int sz = ++size;</p></li><li><p>// 启发式地清理一些slot,并判断是否是否需要扩容<br>  if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</p><pre><code>  rehash();</code></pre><p>}</p></li><li><p>每个ThreadLocal对象都有一个hash值 threadLocalHashCode，每初始化一个ThreadLocal对象，hash值就增加一个固定的大小 0x61c88647。</p></li></ul><pre><code>private final int threadLocalHashCode = nextHashCode();</code></pre><pre><code>private static final int HASH_INCREMENT = 0x61c88647;</code></pre><pre><code>private static int nextHashCode() {    return nextHashCode.getAndAdd(HASH_INCREMENT);}</code></pre><ul><li>由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。</li></ul><pre><code>private static int nextIndex(int i, int len) {    return ((i + 1 &lt; len) ? i + 1 : 0);}</code></pre><ul><li><p>在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，过程如下：</p></li><li><p>1、如果当前位置是空的，那么正好，就初始化一个Entry对象放在位置i上； </p></li><li><p>2、不巧，位置i已经有Entry对象了，如果这个Entry对象的key正好是即将设置的key，那么重新设置Entry中的value；</p></li><li><p>3、很不巧，位置i的Entry对象，和即将设置的key没关系，那么只能找下一个空位置；</p></li><li><p>这样的话，在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该位置Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置</p></li><li><p>可以发现，set和get如果冲突严重的话，效率很低，因为ThreadLoalMap是Thread的一个属性，所以即使在自己的代码中控制了设置的元素个数，但还是不能控制其它代码的行为。</p><h4 id="cleanSomeSlots（启发式地清理slot"><a href="#cleanSomeSlots（启发式地清理slot" class="headerlink" title="cleanSomeSlots（启发式地清理slot)"></a>cleanSomeSlots（启发式地清理slot)</h4></li><li><p>i是当前位置，n是元素个数</p></li><li><p>i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空)</p></li><li><p>n是用于控制控制扫描次数的</p></li><li><p>正常情况下如果log n次扫描没有发现无效slot，函数就结束了</p></li><li><p>但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理</p></li><li><p>再从下一个空的slot开始继续扫描</p></li><li><p>这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用，</p></li><li><p>区别是前者传入的n为元素个数，后者为table的容量</p></li></ul><pre><code>private boolean cleanSomeSlots(int i, int n) {    boolean removed = false;    Entry[] tab = table;    int len = tab.length;    do {        i = nextIndex(i, len);        Entry e = tab[i];        if (e != null &amp;&amp; e.get() == null) {            n = len;            removed = true;            i = expungeStaleEntry(i);        }    } while ( (n &gt;&gt;&gt;= 1) != 0);    return removed;}</code></pre><h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><ul><li>先全量清理，如果清理后现有元素个数超过负载，那么扩容</li></ul><pre><code>private void rehash() {</code></pre><pre><code>- // 进行一次全量清理expungeStaleEntries();// Use lower threshold for doubling to avoid hysteresisif (size &gt;= threshold - threshold / 4)    resize();</code></pre><p>}</p><ul><li>全量清理</li></ul><pre><code>private void expungeStaleEntries() {    Entry[] tab = table;    int len = tab.length;    for (int j = 0; j &lt; len; j++) {        Entry e = tab[j];        if (e != null &amp;&amp; e.get() == null)            expungeStaleEntry(j);    }}</code></pre><ul><li>扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</li></ul><pre><code>private void resize() {    Entry[] oldTab = table;    int oldLen = oldTab.length;    int newLen = oldLen * 2;    Entry[] newTab = new Entry[newLen];    int count = 0;    for (int j = 0; j &lt; oldLen; ++j) {        Entry e = oldTab[j];        if (e != null) {            ThreadLocal&lt;?&gt; k = e.get();            if (k == null) {                e.value = null; // Help the GC            } else {                int h = k.threadLocalHashCode &amp; (newLen - 1);                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            }        }    }    setThreshold(newLen);    size = count;    table = newTab;}</code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><pre><code>private void remove(ThreadLocal&lt;?&gt; key) {    Entry[] tab = table;    int len = tab.length;    int i = key.threadLocalHashCode &amp; (len-1);    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        if (e.get() == key) {</code></pre><ul><li><p>// 显式断开弱引用</p><pre><code>      e.clear();</code></pre></li><li><p>// 进行段清理</p><pre><code>      expungeStaleEntry(i);      return;  }</code></pre><p>  }<br>}</p></li><li><p>Reference#clear</p></li></ul><pre><code>public void clear() {    this.referent = null;}</code></pre><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><ul><li><p>只有调用TheadLocal的remove或者get、set时才会采取措施去清理被回收的ThreadLocal对应的value（但也未必会清理所有的需要被回收的value)。假如一个局部的ThreadLocal不再需要，如果没有去调用remove方法清除，那么有可能会发生内存泄露。</p></li><li><p>既然已经发现有内存泄露的隐患，自然有应对的策略，在调用ThreadLocal的get()、set()可能会清除ThreadLocalMap中key为null的Entry对象，这样对应的value就没有GC Roots可达了，下次GC的时候就可以被回收，当然如果调用remove方法，肯定会删除对应的Entry对象。</p></li><li><p>如果使用ThreadLocal的set方法之后，没有显式的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p></li></ul><pre><code>JDK建议将ThreadLocal变量定义成private static的，这样的话ThreadLocal的生命周期就更长，由于一直存在ThreadLocal的强引用，所以ThreadLocal也就不会被回收，也就能保证任何时候都能根据ThreadLocal的弱引用访问到Entry的value值，然后remove它，防止内存泄露。</code></pre><ul><li><h2 id="Iterator-ListIterator-Iterable"><a href="#Iterator-ListIterator-Iterable" class="headerlink" title="Iterator / ListIterator / Iterable"></a>Iterator / ListIterator / Iterable</h2></li><li><p>普通for循环时不能删除元素，否则会抛出异常；Iterator可以</p></li></ul><pre><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}</code></pre><ul><li>Collection接口继承了Iterable，Iterable接口定义了iterator抽象方法和forEach default方法。所以ArrayList、LinkedList都可以使用迭代器和forEach，包括增强for循环（编译时转为迭代器)。</li></ul><pre><code>public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; iterator();    default void forEach(Consumer&lt;? super T&gt; action) {        Objects.requireNonNull(action);        for (T t : this) {            action.accept(t);        }    }</code></pre><ul><li><p>default Spliterator<T> spliterator() {</p><pre><code>  return Spliterators.spliteratorUnknownSize(iterator(), 0);</code></pre><p>  }  </p></li><li><p>}</p></li><li></li><li><p>注意这些具体的容器类返回的迭代器对象是各不相同的，主要是因为不同的容器遍历方式不同，但是这些迭代器对象都实现Iterator接口，都可以使用一个Iterator对象来统一指向这些不同的子类对象。</p></li><li><p>ArrayList#iterator</p></li></ul><pre><code>public Iterator&lt;E&gt; iterator() {    return new Itr();}</code></pre><ul><li>ArrayList#Itr</li></ul><pre><code>private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        return cursor != size;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        checkForComodification();        int i = cursor;        if (i &gt;= size)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i + 1;        return (E) elementData[lastRet = i];    }    public void remove() {        if (lastRet &lt; 0)            throw new IllegalStateException();        checkForComodification();        try {            ArrayList.this.remove(lastRet);            cursor = lastRet;            lastRet = -1;            expectedModCount = modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {        Objects.requireNonNull(consumer);        final int size = ArrayList.this.size;        int i = cursor;        if (i &gt;= size) {            return;        }        final Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length) {            throw new ConcurrentModificationException();        }        while (i != size &amp;&amp; modCount == expectedModCount) {            consumer.accept((E) elementData[i++]);        }        // update once at end of iteration to reduce heap write traffic        cursor = i;        lastRet = i - 1;        checkForComodification();    }    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><ul><li>ArrayList#listIterator</li></ul><pre><code>public ListIterator&lt;E&gt; listIterator() {    return new ListItr(0);}</code></pre><ul><li>ArrayList#ListItr</li></ul><pre><code>private class ListItr extends Itr implements ListIterator&lt;E&gt; {    ListItr(int index) {        super();        cursor = index;    }    public boolean hasPrevious() {        return cursor != 0;    }    public int nextIndex() {        return cursor;    }    public int previousIndex() {        return cursor - 1;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E previous() {        checkForComodification();        int i = cursor - 1;        if (i &lt; 0)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i;        return (E) elementData[lastRet = i];    }    public void set(E e) {        if (lastRet &lt; 0)            throw new IllegalStateException();        checkForComodification();        try {            ArrayList.this.set(lastRet, e);        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }    public void add(E e) {        checkForComodification();        try {            int i = cursor;            ArrayList.this.add(i, e);            cursor = i + 1;            lastRet = -1;            expectedModCount = modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }}</code></pre><h2 id="for-增强for-forEach"><a href="#for-增强for-forEach" class="headerlink" title="for /增强for/ forEach"></a>for /增强for/ forEach</h2><p>For-each loop    Equivalent for loop<br>for (type var : arr) {<br>    body-of-loop<br>}    for (int i = 0; i &lt; arr.length; i++) {<br>    type var = arr[i];<br>    body-of-loop<br>}<br>for (type var : coll) {<br>    body-of-loop<br>}    for (Iterator<type> iter = coll.iterator(); iter.hasNext(); ) {<br>    type var = iter.next();<br>    body-of-loop<br>}</p><ul><li><p>增强for循环在编译时被修改为for循环：数组会被修改为下标式的循环；集合会被修改为Iterator循环。</p></li><li><p>增强for循环不适合以下情况：（过滤、转换、平行迭代)</p></li><li><p>对collection或数组中的元素不能做赋值操作；</p></li><li><p>只能正向遍历，不能反向遍历；</p></li><li><p>遍历过程中，collection或数组中同时只有一个元素可见，即只有“当前遍历到的元素”可见，而前一个或后一个元素是不可见的；</p></li><li><p>forEach</p></li><li><p>ArrayList#forEach继承自</p></li><li><p>Iterable接口的default方法</p></li><li><p>default void forEach(Consumer&lt;? super T&gt; action) {<br>  Objects.requireNonNull(action);<br>  for (T t : this) {</p><pre><code>  action.accept(t);</code></pre><p>  }<br>}</p></li><li></li></ul><h2 id="Comparable与Comparator"><a href="#Comparable与Comparator" class="headerlink" title="Comparable与Comparator"></a>Comparable与Comparator</h2><ul><li>基本数据类型包装类和String类均已实现了Comparable接口。</li><li>实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序，默认为升序。</li></ul><ul><li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort)，从而允许在排序顺序上实现精确控制。还可以使用 Comparator 来控制某些数据结构（如TreeSet,TreeMap)的顺序。</li><li></li></ul><h1 id="1-9-继承"><a href="#1-9-继承" class="headerlink" title="1.9 继承"></a>1.9 继承</h1><pre><code>子类继承父类所有的成员变量（即使是private变量，有所有权，但是没有使用权，不能访问父类的private的成员变量)。</code></pre><pre><code>子类中可以直接调用父类非private方法，也可以用super.父类方法的形式调用。</code></pre><ul><li><p>子类构造方法中如果没有显式使用super(父类构造方法参数)去构造父类对象的话（如果有必须是方法的第一行)，编译器会在第一行添加super()。</p></li><li><p>子类的构造函数可否不使用super(父类构造方法参数)调用超类的构造方法？</p></li><li><p>可以不用显式的写出super，但前提是“父类中有多个构造方法，且有一个是显式写出的无参的构造方法”。</p></li><li></li></ul><h1 id="1-10-内部类"><a href="#1-10-内部类" class="headerlink" title="1.10 内部类"></a>1.10 内部类</h1><ul><li>在另一个类的里面定义的类就是内部类</li><li>内部类是编译器现象，与虚拟机无关。</li><li>编译器会将内部类编译成用$分割外部类名和内部类名的常规类文件，而虚拟机对此一无所知。</li></ul><pre><code>内部类可以是static的，也可用public，default，protected和private修饰。（而外部类即类名和文件名相同的只能使用public和default)。</code></pre><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>每个内部类都能独立地继承一个（接口的)实现，所以无论外部类是否已经继承了某个（接口的)实现，对于内部类都没有影响。</p></li><li><p>接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p></li><li><p>用内部类还能够为我们带来如下特性：</p></li><li><p>1、内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外部对象的信息相互独立。</p></li><li><p>2、在单个外部类中，可以让多个内部类实现不同的接口，或者继承不同的类。外部类想要多继承的类可以分别由内部类继承，并进行Override或者直接复用。然后外部类通过创建内部类的对象来使用该内部对象的方法和成员，从而达到复用的目的，这样外部内就具有多个父类的所有特征。</p></li><li><p>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</p></li><li><p>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</p></li><li><p>5、内部类提供了更好的封装，除了该外部类，其他类都不能访问</p></li><li><p>只有静态内部类可以同时拥有静态成员和非静态成员，其他内部类只有拥有非静态成员。</p></li></ul><h2 id="成员内部类：就像外部类的一个成员变量"><a href="#成员内部类：就像外部类的一个成员变量" class="headerlink" title="成员内部类：就像外部类的一个成员变量"></a>成员内部类：就像外部类的一个成员变量</h2><ul><li>注意内部类的对象总有一个外部类的引用</li><li>当创建内部类对象时，会自动将外部类的this引用传递给当前的内部类的构造方法。</li></ul><h2 id="静态内部类：就像外部类的一个静态成员变量"><a href="#静态内部类：就像外部类的一个静态成员变量" class="headerlink" title="静态内部类：就像外部类的一个静态成员变量"></a>静态内部类：就像外部类的一个静态成员变量</h2><pre><code>public class OuterClass {    private static class StaticInnerClass {        int id;        static int increment = 1;    }}//调用方式：//外部类.内部类 instanceName = new 外部类.内部类();</code></pre><h2 id="局部内部类：定义在一个方法或者一个块作用域里面的类"><a href="#局部内部类：定义在一个方法或者一个块作用域里面的类" class="headerlink" title="局部内部类：定义在一个方法或者一个块作用域里面的类"></a>局部内部类：定义在一个方法或者一个块作用域里面的类</h2><ul><li><p>想创建一个类来辅助我们的解决方案，又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。</p></li><li><p>JDK1.8之前不能访问非final的局部变量！</p></li><li><p>生命周期不一致：</p></li><li><p>方法在栈中，对象在堆中；方法执行完，对象并没有死亡</p></li><li><p>如果可以使用方法的局部变量，如果方法执行完毕，就会访问一个不存在的内存区域。</p></li><li><p>而final是常量，就可以将该常量的值复制一份，即使不存在也不影响。</p></li></ul><pre><code>public Destination destination(String str) {    class PDestination implements Destination {        private String label;        private PDestination(String whereTo) {            label = whereTo;        }        public String readLabel() {            return label;        }    }    return new PDestination(str);}</code></pre><h2 id="匿名内部类：必须继承一个父类或实现一个接口"><a href="#匿名内部类：必须继承一个父类或实现一个接口" class="headerlink" title="匿名内部类：必须继承一个父类或实现一个接口"></a>匿名内部类：必须继承一个父类或实现一个接口</h2><ul><li>匿名内部类和局部内部类在JDK1.8 之前都不能访问一个非final的局部变量，只能访问final的局部变量，原因是生命周期不同，可能栈中的局部变量已经被销毁，而堆中的对象仍存活，此时会访问一个不存在的内存区域。假如是final的变量，那么编译时会将其拷贝一份，延长其生命周期。</li><li>拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。</li><li>但在JDK1.8之后可以访问一个非final的局部变量了，前提是非final的局部变量没有修改，表现得和final变量一样才可以！</li></ul><pre><code>interface AnonymousInner {    int add();}public class AnonymousOuter {    public AnonymousInner getAnonymousInner(){        int x = 100;        return new AnonymousInner() {            int y = 100;            @Override            public int add() {                return x + y;            }        };    }}</code></pre><h1 id="1-11-关键字"><a href="#1-11-关键字" class="headerlink" title="1.11 关键字"></a>1.11 关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h2 id="try-finally-return"><a href="#try-finally-return" class="headerlink" title="try-finally-return"></a>try-finally-return</h2><ul><li>1、不管有没有出现异常，finally块中代码都会执行；</li><li>2、当try和catch中有return时，finally仍然会执行；无论try里执行了return语句、break语句、还是continue语句，finally语句块还会继续执行；如果执行try和catch时JVM退出（比如System.exit(0))，那么finally不会被执行；</li><li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的；</li><li>【</li><li>如果try语句里有return，那么代码的行为如下：</li></ul><p>1.如果有返回值，就把返回值保存到局部变量中<br>2.执行jsr指令跳到finally语句里执行<br>3.执行完finally语句后，返回之前保存在局部变量表里的值</p><ul><li><p>】</p></li><li><p>3、当try和finally里都有return时，会忽略try的return，而使用finally的return。    </p></li><li><p>4、如果try块中抛出异常，执行finally块时又抛出异常，此时原始异常信息会丢失，只抛出在finally代码块中的异常。</p></li><li><p>实例一：</p></li></ul><pre><code>public static int test() {    int x = 1;    try {        x++;        return x; // 2    } finally {        x++;    }}</code></pre><ul><li>实例二：</li></ul><pre><code>private static int test2() {    try {        System.out.println(&quot;try...&quot;);        return 80;    } finally {        System.out.println(&quot;finally...&quot;);        return 100; // 100    }}</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。<h3 id="1-修饰成员方法：静态成员方法"><a href="#1-修饰成员方法：静态成员方法" class="headerlink" title="1)修饰成员方法：静态成员方法"></a>1)修饰成员方法：静态成员方法</h3></li><li>在静态方法中不能访问类的非静态成员变量和非静态成员方法；</li><li>在非静态成员方法中是可以访问静态成员方法/变量的；</li><li>即使没有显式地声明为static，类的构造器实际上也是静态方法</li></ul><h3 id="2-修饰成员变量：静态成员变量"><a href="#2-修饰成员变量：静态成员变量" class="headerlink" title="2)修饰成员变量：静态成员变量"></a>2)修饰成员变量：静态成员变量</h3><ul><li><p>静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p></li><li><p>静态成员变量并发下不是线程安全的，并且对象是单例的情况下，非静态成员变量也不是线程安全的。</p></li><li><p>怎么保证变量的线程安全?</p></li><li><p>只有一个线程写，其他线程都是读的时候，加volatile；线程既读又写，可以考虑Atomic原子类和线程安全的集合类；或者考虑ThreadLocal</p><h3 id="3-修饰代码块：静态代码块"><a href="#3-修饰代码块：静态代码块" class="headerlink" title="3)修饰代码块：静态代码块"></a>3)修饰代码块：静态代码块</h3></li><li><p>用来构造静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p></li></ul><h3 id="4-修饰内部类：静态内部类"><a href="#4-修饰内部类：静态内部类" class="headerlink" title="4)修饰内部类：静态内部类"></a>4)修饰内部类：静态内部类</h3><ul><li>成员内部类和静态内部类的区别：<ul><li>1)前者只能拥有非静态成员；后者既可拥有静态成员，又可拥有非静态成员</li><li>2)前者持有外部类的的引用，可以访问外部类的静态成员和非静态成员；后者不持有外部类的引用，只能访问外部类的静态成员</li><li>3)前者不能脱离外部类而存在；后者可以<h3 id="5-修饰import：静态导包"><a href="#5-修饰import：静态导包" class="headerlink" title="5)修饰import：静态导包"></a>5)修饰import：静态导包</h3></li></ul></li><li></li></ul><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><h3 id="switch字符串实现原理"><a href="#switch字符串实现原理" class="headerlink" title="switch字符串实现原理"></a>switch字符串实现原理</h3><ul><li><p>对比反编译之后的结果：</p></li><li><p>编译后switch还是基于整数，该整数来自于String的hashCode。</p></li><li><p>先比较字符串的hashCode，因为hashCode相同未必值相同，又再次检查了equals是否相同。</p></li><li></li></ul><h3 id="字节码实现原理（tableswitch-lookupswitch"><a href="#字节码实现原理（tableswitch-lookupswitch" class="headerlink" title="字节码实现原理（tableswitch / lookupswitch)"></a>字节码实现原理（tableswitch / lookupswitch)</h3><ul><li>编译器会使用tableswitch和lookupswitch指令来生成switch语句的编译代码。当switch语句中的case分支的条件值比较稀疏时，tableswitch指令的空间使用率偏低。这种情况下将使用lookupswitch指令来替代。lookupswitch指令的索引表由int类型的键（来源于case语句块后面的数值)与对应的目标语句偏移量所构成。当lookupswitch指令执行时，switch语句的条件值将和索引表中的键进行比较，如果某个键和条件值相符，那么将转移到这个键对应的分支偏移量继续执行，如果没有键值符合，执行将在default分支执行。</li></ul><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><ul><li><p>只要含有抽象方法，这个类必须添加abstract关键字，定义为抽象类。</p></li><li><p>只要父类是抽象类,内含抽象方法，那么继承这个类的子类的相对应的方法必须重写。如果不重写，就需要把父类的声明抽象方法再写一遍，留给这个子类的子类去实现。同时将这个子类也定义为抽象类。</p></li><li><p>注意抽象类中可以有抽象方法，也可以有具体实现方法（当然也可以没有)。</p></li><li><p>抽象方法须加abstract关键字，而具体方法不可加</p></li><li><p>只要是抽象类，就不能存在这个类的对象（不可以new一个这个类的对象)。</p><h2 id="this-amp-super"><a href="#this-amp-super" class="headerlink" title="this &amp; super"></a>this &amp; super</h2></li><li><p>this</p></li><li><p>自身引用；访问成员变量与方法；调用其他构造方法</p></li><li><ol><li>通过this调用另一个构造方法，用法是this(参数列表)，这个仅在类的构造方法中可以使用</li></ol></li><li><ol start="2"><li>函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。</li></ol></li><li><ol start="3"><li>需要引用当前对象时候，直接用this（自身引用)</li></ol></li><li><p>super</p></li><li><p>父类引用；访问父类成员变量与方法；调用父类构造方法</p></li><li><p>super可以理解为是指向自己超（父)类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p></li><li><p>super有三种用法： </p></li><li><p>1.普通的直接引用</p></li><li><p>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员，如果不冲突的话也可以不加super。</p></li><li><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，为了区别，调用父类的成员必须要加super</p></li><li><p>3.调用父类的构造函数</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2></li></ul><h1 id="1-12-枚举"><a href="#1-12-枚举" class="headerlink" title="1.12 枚举"></a>1.12 枚举</h1><h2 id="JDK实现"><a href="#JDK实现" class="headerlink" title="JDK实现"></a>JDK实现</h2><ul><li>实例：</li></ul><pre><code>public enum Labels0 {    ENVIRONMENT(&quot;环保&quot;), TRAFFIC(&quot;交通&quot;), PHONE(&quot;手机&quot;);    private String name;    private Labels0(String name) {        this.name = name;    }    public String getName() {        return name;    }}</code></pre><ul><li><p>编译后生成的字节码反编译：</p></li><li><p>可以清晰地看到枚举被编译后其实就是一个类，该类被声明成 final，说明其不能被继承，同时它继承了 Enum 类。枚举里面的元素被声明成 static final ，另外生成一个静态代码块 static{}，最后还会生成 values 和 valueOf 两个方法。下面以最简单的 Labels 为例，一个一个模块来看。</p></li></ul><h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><ul><li><p>Enum 类是一个抽象类，主要有 name 和 ordinal 两个属性，分别用于表示枚举元素的名称和枚举元素的位置索引，而构造函数传入的两个变量刚好与之对应。</p></li><li><p>toString 方法直接返回 name。</p></li><li><p>equals 方法直接用 == 比较两个对象。</p></li><li><p>hashCode 方法调用的是父类的 hashCode 方法。</p></li><li><p>枚举不支持 clone、finalize 和 readObject 方法。</p></li><li><p>compareTo 方法可以看到就是比较 ordinal 的大小。</p></li><li><p>valueOf 方法，根据传入的字符串 name 来返回对应的枚举元素。</p></li></ul><h3 id="静态代码块的实现"><a href="#静态代码块的实现" class="headerlink" title="静态代码块的实现"></a>静态代码块的实现</h3><ul><li><p>在静态代码块中创建对象，对象是单例的！</p></li><li><p>可以看到静态代码块主要完成的工作就是先分别创建 Labels 对象，然后将“ENVIRONMENT”、“TRAFFIC”和“PHONE”字符串作为 name ，按照顺序分别分配位置索引0、1、2作为 ordinal，然后将其值设置给创建的三个 Labels 对象的 name 和 ordinal 属性，此外还会创建一个大小为3的 Labels 数组 ENUM$VALUES，将前面创建出来的 Labels 对象分别赋值给数组。</p><h3 id="values的实现"><a href="#values的实现" class="headerlink" title="values的实现"></a>values的实现</h3></li><li><p>可以看到它是一个静态方法，主要是使用了前面静态代码块中的 Labels 数组 ENUM$VALUES，调用 System.arraycopy 对其进行复制，然后返回该数组。所以通过 Labels.values()[2]就能获取到数组中索引为2的元素。</p><h3 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf 方法"></a>valueOf 方法</h3></li><li><p>该方法同样是个静态方法，可以看到该方法的实现是间接调用了父类 Enum 类的 valueOf 方法，根据传入的字符串 name 来返回对应的枚举元素，比如可以通过 Labels.valueOf(“ENVIRONMENT”)获取 Labels.ENVIRONMENT。</p></li><li><p>枚举本质其实也是一个类，而且都会继承java.lang.Enum类，同时还会生成一个静态代码块 static{}，并且还会生成 values 和 valueOf 两个方法。而上述的工作都需要由编译器来完成，然后我们就可以像使用我们熟悉的类那样去使用枚举了。</p></li><li></li></ul><h2 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h2><ul><li><p>将int枚举常量翻译成可打印的字符串，没有很便利的方法。</p></li><li><p>要遍历一个枚举组中的所有int 枚举常量，甚至获得int枚举组的大小。</p></li><li><p>使用枚举类型的values方法可以获得该枚举类型的数组</p></li><li><p>枚举类型没有可以访问的构造器，是真正的final；是实例受控的，它们是单例的泛型化；本质上是单元素的枚举；提供了编译时的类型安全。</p></li><li><p>单元素的枚举是实现单例的最佳方法！</p></li><li><p>可以在枚举类型中放入这段代码，可以实现String2Enum。</p></li><li><p>注意Operation是枚举类型名。</p></li></ul><h2 id="用实例域代替序数"><a href="#用实例域代替序数" class="headerlink" title="用实例域代替序数"></a>用实例域代替序数</h2><ul><li>这种实现不好，不推荐使用ordinal方法，推荐使用下面这种实现：</li></ul><h2 id="用EnumSet代替位域"><a href="#用EnumSet代替位域" class="headerlink" title="用EnumSet代替位域"></a>用EnumSet代替位域</h2><ul><li>位域是将几个常量合并到一个集合中，我们推荐用枚举代替常量，用EnumSet代替集合<ul><li>EnumSet.of(enum1,enum2) -&gt; Set&lt;枚举&gt;<h2 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h2></li></ul></li></ul><ul><li>将一个枚举类型的值与一个元素（或一组)对应起来，推荐使用EnumMap数据结构</li><li>如果是两个维度的变化，那么可以使用EnumMap&lt;Enum1,Map&lt;Enum1,元素&gt;&gt;</li></ul><ul><li><h1 id="1-13-序列化"><a href="#1-13-序列化" class="headerlink" title="1.13 序列化"></a>1.13 序列化</h1><h2 id="JDK序列化（Serizalizable"><a href="#JDK序列化（Serizalizable" class="headerlink" title="JDK序列化（Serizalizable)"></a>JDK序列化（Serizalizable)</h2></li><li><p>定义：将实现了Serializable接口（标记型接口)的对象转换成一个字节数组，并可以将该字节数组转为原来的对象。</p></li><li><p>ObjectOutputStream 是专门用来输出对象的输出流；</p></li><li><p>ObjectOutputStream 将 Java 对象写入 OutputStream。可以使用 ObjectInputStream 读取（重构)对象。</p></li></ul><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><ul><li><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类)的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)。</p><ul><li>1)如果没有添加serialVersionUID，进行了序列化，而在反序列化的时候，修改了类的结构（添加或删除成员变量，修改成员变量的命名)，此时会报错。</li><li>2)如果添加serialVersionUID，进行了序列化，而在反序列化的时候，修改了类的结构（添加或删除成员变量，修改成员变量的命名)，那么可能会恢复部分数据，或者恢复不了数据。</li></ul></li><li><p>如果设置了serialVersionUID并且一致，那么可能会反序列化部分数据；如果没有设置，那么只要属性不同，那么无法反序列化。</p></li></ul><h2 id="其他序列化工具"><a href="#其他序列化工具" class="headerlink" title="其他序列化工具"></a>其他序列化工具</h2><ul><li>XML/JSON</li><li>Thrift/Protobuf</li></ul><h2 id="对象深拷贝与浅拷贝"><a href="#对象深拷贝与浅拷贝" class="headerlink" title="对象深拷贝与浅拷贝"></a>对象深拷贝与浅拷贝</h2><ul><li>当拷贝一个变量时，原始引用和拷贝的引用指向同一个对象，改变一个引用所指向的对象会对另一个引用产生影响。</li><li>如果需要创建一个对象的浅拷贝，那么需要调用clone方法。</li><li>Object 类本身不实现接口 Cloneable，直接调用clone会抛出异常。</li></ul><pre><code>如果要在自己定义类中调用clone方法，必须实现Cloneable接口（标记型接口)，因为Object类中的clone方法为protected，所以需要自己重写clone方法，设置为public。</code></pre><ul><li>protected native Object clone() throws CloneNotSupportedException;</li></ul><pre><code>public class Person implements Cloneable {    private int age;    private String  name;    private Company company;    @Override    public Person clone() throws CloneNotSupportedException {        return (Person) super.clone();    }</code></pre><ul><li>}</li></ul><pre><code>public class Company implements Cloneable{    private String name;</code></pre><pre><code>    @Overridepublic Company clone() throws CloneNotSupportedException {    return (Company) super.clone();}</code></pre><ul><li>}</li><li>使用super（即Object)的clone方法只能进行浅拷贝。</li><li>如果希望实现深拷贝，需要修改实现，比如修改为：</li></ul><pre><code>@Overridepublic Person clone() throws CloneNotSupportedException {    Person person = (Person) super.clone();    person.setCompany(company.clone()); // 一个新的Company    return person;}</code></pre><ul><li><p>假如说Company中还有持有其他对象的引用，那么Company中也要像Person这样做。</p></li><li><p>可以说：想要深拷贝一个子类，那么它的所有父类都必须可以实现深拷贝。</p></li><li><p>另一种实现对象深拷贝的方式是序列化。</p></li><li><p>@Override<br>protected Object clone()  {<br>try {<br> ByteArrayOutputStream baos = new ByteArrayOutputStream();<br> ObjectOutputStream os = new ObjectOutputStream(baos);<br> os.writeObject(this);<br> os.close();<br> ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());<br> ObjectInputStream in = new ObjectInputStream(bais);<br> Object ret = in.readObject();<br> in.close();<br> return ret;<br>}catch(Exception e) {<br> e.printStackTrace();<br>}<br>return null;<br>}</p></li><li></li></ul><h1 id="1-14-异常"><a href="#1-14-异常" class="headerlink" title="1.14 异常"></a>1.14 异常</h1><h2 id="Error、Exception"><a href="#Error、Exception" class="headerlink" title="Error、Exception"></a>Error、Exception</h2><ul><li>Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM)一般会选择线程终止。</li><li>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<h2 id="常见RuntimeException"><a href="#常见RuntimeException" class="headerlink" title="常见RuntimeException"></a>常见RuntimeException</h2></li><li>IllegalArgumentException - 方法的参数无效</li><li>NullPointerException - 试图访问一空对象的变量、方法或空数组的元素</li><li>ArrayIndexOutOfBoundsException - 数组越界访问</li><li>ClassCastException - 类型转换异常</li><li>NumberFormatException 继承IllegalArgumentException，字符串转换为数字时出现。比如int i= Integer.parseInt(“ab3”);</li><li></li></ul><h2 id="RuntimeException与非Runtime-Exception"><a href="#RuntimeException与非Runtime-Exception" class="headerlink" title="RuntimeException与非Runtime    Exception"></a>RuntimeException与非Runtime    Exception</h2><ul><li><p>RuntimeException是运行时异常，也称为未检查异常；</p></li><li><p>非RuntimeException 也称为CheckedException 受检异常</p></li><li><p>前者可以不必进行try-catch，后者必须要进行try-catch或者throw。</p><h2 id="异常包装"><a href="#异常包装" class="headerlink" title="异常包装"></a>异常包装</h2></li><li><p>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型</p></li><li><p>try{</p></li><li><p>…</p></li><li><p>}catch(SQLException e){</p></li><li><p>throw new ServletException(e.getMessage());</p></li><li><p>}</p></li><li><p>这样的话ServletException会取代SQLException。</p></li><li><p>有一种更好的方法，可以保存原有异常的信息，将原始异常设置为新的异常的原因</p></li><li><p>try{</p></li><li><p>…</p></li><li><p>}catch(SQLException e){</p></li><li><p>Throwable se =  new ServletException(e.getMessage());</p></li><li><p>se.initCause(e);</p></li><li><p>throw se;</p></li><li><p>}</p></li><li><p>当捕获到异常时，可以使用getCause方法来重新得到原始异常</p></li><li><p>Throwable e = se.getCause();</p></li><li><p>建议使用这种包装技术，可以抛出系统的高级异常（自己new的)，又不会丢失原始异常的细节。</p></li><li><p>早抛出，晚捕获。</p></li><li></li></ul><h1 id="1-15-泛型"><a href="#1-15-泛型" class="headerlink" title="1.15 泛型"></a>1.15 泛型</h1><ul><li><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参)，然后在使用/调用时传入具体的类型（类型实参)。</p><h2 id="泛型接口-类-方法"><a href="#泛型接口-类-方法" class="headerlink" title="泛型接口/类/方法"></a>泛型接口/类/方法</h2><h2 id="泛型继承、实现"><a href="#泛型继承、实现" class="headerlink" title="泛型继承、实现"></a>泛型继承、实现</h2></li><li><p>父类使用泛型，子类要么去指定具体类型参数，要么继续使用泛型</p></li></ul><h2 id="泛型的约束和局限性"><a href="#泛型的约束和局限性" class="headerlink" title="泛型的约束和局限性"></a>泛型的约束和局限性</h2><pre><code>- 1)只能使用包装器类型，不能使用基本数据类型；- 2)运行时类型查询只适用于原始类型，不适用于带类型参数的类型；</code></pre><ul><li><p>if(a instanceof Pair<String>) //error</p><ul><li>3)不能创建带有类型参数的泛型类的数组</li></ul></li><li><p>Pair<String> [] pairs = new Pair<String>[10];//error</p></li><li><p>只能使用反射来创建泛型数组</p></li></ul><pre><code>public static &lt;T extends Comparable&gt; T[] minmax(T… a){</code></pre><ul><li><p>T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(),个数);</p></li><li><p>…复制</p></li><li><p>}</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2></li><li><p>? 未知类型 只可以用于声明时，声明类型或方法参数，不能用于定义时（指定类型参数时)</p></li><li><p>List&lt;?&gt; unknownList;</p></li><li><p>List&lt;? extends Number&gt; unknownNumberList;</p></li><li><p>List&lt;? super Integer&gt; unknownBaseLineIntgerList;</p></li><li><p>对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素， 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是null。</p></li><li><p>通配符类型 List<?> 与原始类型 List 和具体类型 List<String>都不相同，List<?>表示这个list内的每个元素的类型都相同，但是这种类型具体是什么我们却不知道。注意，List<?>和List<Object>可不相同，由于Object是最高层的超类，List<Object>表示元素可以是任何类型的对象，但是List<?>可不是这个意思（未知类型)。</p></li><li></li></ul><h2 id="extends-指定类型必为自身或其子类"><a href="#extends-指定类型必为自身或其子类" class="headerlink" title="extends 指定类型必为自身或其子类"></a>extends 指定类型必为自身或其子类</h2><ul><li><p>List&lt;? extends Fruit&gt;</p></li><li><p>这个引用变量如果作为参数，哪些引用可以传入？</p></li><li><p>本身及其子类</p></li><li><p>以及含有通配符及extends的本身及子类</p></li><li><p>不可传入只含通配符不含extends+指定类 的引用</p></li><li><p>或者extends的不是指定类及其子类，而是其父类</p></li><li><p>// Number “extends” Number (in this context)</p></li><li><p>List&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Number&gt;(); </p></li><li><p>// Integer extends Number</p></li><li><p>List&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Integer&gt;();</p></li><li><p>// Double extends Number</p></li><li><p>List&lt;? extends Number&gt; foo3 = new ArrayList&lt;? extends Double&gt;();</p></li><li><p>如果实现了多个接口，可以使用&amp;来将接口隔开</p></li><li><p>T extends Comparable &amp; Serializable</p></li><li><p>List&lt;? extends Number&gt; list = new ArrayList<Number>();</p><ul><li>list.add(new Integer(1)); //error</li></ul></li><li><p>list.add(new Float(1.2f));  //error</p></li></ul><h2 id="super-指定类型必为自身或其父类"><a href="#super-指定类型必为自身或其父类" class="headerlink" title="super 指定类型必为自身或其父类"></a>super 指定类型必为自身或其父类</h2><ul><li><p>不能同时声明泛型通配符申明上界和下界</p><h2 id="PECS（读extends，写super"><a href="#PECS（读extends，写super" class="headerlink" title="PECS（读extends，写super)"></a>PECS（读extends，写super)</h2></li><li><p>producer-extends, consumer-super.</p></li><li><p>produce是指参数是producer，consumer是指参数是consumer。</p></li><li><p>要往泛型类写数据时，用extends；</p></li><li><p>要从泛型类读数据时，用super；</p></li><li><p>既要取又要写，就不用通配符（即extends与super都不用)比如List<Integer>。</p></li><li><p>如果参数化类型表示一个T生产者，就是&lt;? extends T&gt;；如果它表示一个T消费者，就使用&lt;? super E&gt;。</p></li><li><p>Stack的pushAll的参数产生E实例供Stack使用，因此参数类型为Iterable&lt;? extends E&gt;。</p></li><li><p>popAll的参数提供Stack消费E实例，因此参数类型为Collection&lt;？ super E&gt;。</p></li></ul><pre><code>public void pushAll(Iterable&lt;? extends E&gt; src) {</code></pre><ul><li>for (E e : src)</li><li>push(e);</li><li>}</li></ul><pre><code>public void popAll(Collection&lt;? super E&gt; dst) {</code></pre><ul><li><p>while (!isEmpty())</p></li><li><p>dst.add(pop());</p></li><li><p>}</p></li><li><p>在调用pushAll方法时生产了E 实例（produces E instances)，在调用popAll方法时dst消费了E 实例（consumes E instances)。Naftalin与Wadler将PECS称为Get and Put Principle。</p></li><li><p>Collections#copy</p></li></ul><pre><code>public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) {    int srcSize = src.size();    if (srcSize &gt; dest.size())        throw new IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;);    if (srcSize &lt; COPY_THRESHOLD ||        (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) {        for (int i=0; i&lt;srcSize; i++)            dest.set(i, src.get(i));    } else {        ListIterator&lt;? super T&gt; di=dest.listIterator();        ListIterator&lt;? extends T&gt; si=src.listIterator();        for (int i=0; i&lt;srcSize; i++) {            di.next();            di.set(si.next());        }    }}</code></pre><ul><li><h2 id="泛型擦除（编译时擦除"><a href="#泛型擦除（编译时擦除" class="headerlink" title="泛型擦除（编译时擦除)"></a>泛型擦除（编译时擦除)</h2></li><li><p>编译器生成的bytecode是不包含泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即泛型擦除。</p></li><li><p>擦除类型变量，并替换为限定类型（无限定的变量用Object)。</p></li><li><p>比如 T extends Comparable </p></li><li><p>那么下面所有出现T的地方都会被替换为Comparable</p></li><li><p>如果调用时指定某个类，比如 Pair<String> pair = new Pair&lt;&gt;();</p></li><li><p>那么Pair<T> 中所有的T都替换为String</p></li><li><p>泛型擦除带来的问题：</p><ul><li>1)无法使用具有不同类型参数的泛型进行方法重载</li></ul></li></ul><pre><code>public void test(List&lt;String&gt; ls) {</code></pre><ul><li>System.out.println(“Sting”);</li><li>}</li></ul><pre><code>public void test(List&lt;Integer&gt; li) {</code></pre><ul><li><p>System.ut.println(“Integer”);</p></li><li><p>} // 编译出错</p></li><li><p>或者</p></li></ul><pre><code>public interface Builder&lt;K,V&gt; {</code></pre><ul><li><p>void add(List<K> keyList);</p></li><li><p>void add(List<V> valueList);</p></li><li><p>}</p><ul><li>2)泛型类的静态变量是共享的</li></ul></li><li><p>另外，因为Java泛型的擦除并不是对所有使用泛型的地方都会擦除的，部分地方会保留泛型信息，在运行时可以获得类型参数。</p></li><li></li></ul><h1 id="1-16-IO"><a href="#1-16-IO" class="headerlink" title="1.16 IO"></a>1.16 IO</h1><h2 id="Unix-IO模型"><a href="#Unix-IO模型" class="headerlink" title="Unix IO模型"></a>Unix IO模型</h2><p>- 异步I/O 是指用户程序发起IO请求后，不等待数据，同时操作系统内核负责I/O操作把数据从内核拷贝到用户程序的缓冲区后通知应用程序。数据拷贝是由操作系统内核完成，用户程序从一开始就没有等待数据，发起请求后不参与任何IO操作，等内核通知完成。<br>- 同步I/O 就是非异步IO的情况，也就是用户程序要参与把数据拷贝到程序缓冲区（例如java的InputStream读字节流过程)。<br>- 同步IO里的非阻塞 是指用户程序发起IO操作请求后不等待数据，而是调用会立即返回一个标志信息告知条件不满足，数据未准备好，从而用户请求程序继续执行其它任务。执行完其它任务，用户程序会主动轮询查看IO操作条件是否满足，如果满足，则用户程序亲自参与拷贝数据动作。</p><ul><li><p>Unix IO模型的语境下，同步和异步的区别在于数据拷贝阶段是否需要完全由操作系统处理。阻塞和非阻塞操作是针对发起IO请求操作后是否有立刻返回一个标志信息而不让请求线程等待。</p><h2 id="BIO-NIO-AIO介绍"><a href="#BIO-NIO-AIO介绍" class="headerlink" title="BIO NIO AIO介绍"></a>BIO NIO AIO介绍</h2></li><li><p>BIO：同步阻塞，每个客户端的连接会对应服务器的一个线程</p></li><li><p>NIO：同步非阻塞，多路复用器轮询客户端的请求，每个客户端的IO请求会对应服务器的一个线程</p></li><li><p>AIO： 异步非阻塞，客户端的IO请求由OS完成后再通知服务器启动线程处理（需要OS支持)</p></li><li><p>1、进程向操作系统请求数据 </p></li><li><p>2、操作系统把外部数据加载到内核的缓冲区中， </p></li><li><p>3、操作系统把内核的缓冲区拷贝到进程的缓冲区 </p></li><li><p>4、进程获得数据完成自己的功能</p></li><li><p>Java NIO属于同步非阻塞IO，即IO多路复用，单个线程可以支持多个IO</p></li><li><p>即询问时从IO没有完毕时直接阻塞，变成了立即返回一个是否完成IO的信号。</p></li><li><p>异步IO就是指AIO，AIO需要操作系统支持。</p></li><li></li></ul><h2 id="Java-BIO-使用"><a href="#Java-BIO-使用" class="headerlink" title="Java BIO 使用"></a>Java BIO 使用</h2><ul><li>Server</li></ul><pre><code>public class ChatServer {</code></pre><ul><li>ServerSocket ss = null;</li><li>boolean started = false;</li><li>ArrayList<Client> clients = new ArrayList<Client>();</li></ul><pre><code>    public static void main(String[] args) {</code></pre><ul><li>new ChatServer().start();</li><li>}</li></ul><pre><code>    public void start() {</code></pre><ul><li><p>try {</p><ul><li>ss = new ServerSocket(6666);</li></ul></li><li><p>started = true;</p></li><li><p>} catch (BindException e) {</p></li><li><p>System.out.println(“端口使用中….”); // 用于处理两次启动Server端</p></li><li><p>System.out.println(“请重新运行服务器”);</p><ul><li>System.exit(-1);</li></ul></li><li><p>} catch (IOException e) {</p></li><li><p>System.out.println(“服务器启动失败”);</p></li><li><p>e.printStackTrace();</p></li><li><p>}</p></li><li><p>try {</p></li><li><p>while (started) {</p></li><li><p>Socket s = ss.accept();</p></li><li><p>Client c = new Client(s);</p></li><li><p>clients.add(c);</p></li><li><p>c.transmitToAll(c.name + “进入了聊天室”);</p></li><li><p>new Thread(c).start();</p></li><li><p>}</p></li><li><p>} catch (IOException e) {</p></li><li><p>e.printStackTrace();</p></li><li><p>} finally { // 主方法结束时应该关闭服务器ServerSocket</p></li><li><p>if (ss != null)</p></li><li><p>try {</p></li><li><p>ss.close();</p></li><li><p>} catch (IOException e) {</p></li><li><p>e.printStackTrace();</p></li><li><p>}</p></li><li><p>}</p></li><li><p>}</p></li><li><p>class Client implements Runnable { // 包装给一个单独的客户端的线程类，应该保留自己的连接Socket和流</p></li><li><p>// 保留连接一般使用构造方法，将连接传入</p></li><li><p>// 一个客户端就new 一个Client 连接</p></li></ul><pre><code>        private Socket s = null;</code></pre><pre><code>        private DataInputStream dis = null;</code></pre><pre><code>        private DataOutputStream dos = null;// 每个客户端的线程都有各自的输入输出流，输入流用于读来自当前客户端的数据，输出流用于保存当前客户端的流。</code></pre><pre><code>        private boolean Connected = false;// 每个客户端都有一个开始结束的标志</code></pre><pre><code>        private String name;</code></pre><ul><li><p>Client(Socket s) { // new 一个Client对象时，要打开Socket和DataInputStream流</p></li><li><p>this.s = s;</p></li><li><p>try {</p></li><li><p>dis = new DataInputStream(s.getInputStream());</p></li><li><p>dos = new DataOutputStream(s.getOutputStream());</p></li><li><p>Connected = true;</p></li><li><p>this.name = dis.readUTF();</p></li><li><p>} catch (IOException e) {</p></li><li><p>e.printStackTrace();</p></li><li><p>}</p></li><li><p>}</p></li><li><p>// 如何实现一个客户端与其他客户端的通信？</p></li><li><p>// 可以考虑在每连到一个客户端就保存与其的连接Socket，当要发送给其他客户端信息时，遍历一遍所有其他客户端</p></li></ul><pre><code>        public void run() {</code></pre><ul><li>try {</li><li>while (Connected) {</li><li>String read = dis.readUTF();</li><li>if (read.equals(“EXIT”)) {</li><li>Connected = false;</li><li>transmitToAll(this.name + “已退出”);</li><li>continue;</li><li>} else if (read.startsWith(“@”)) {<ul><li>String[] msg = read.substring(1).split(“:”);</li></ul></li><li>transmitToPerson(msg[0], msg[1]);</li><li>continue;</li><li>}</li><li>transmitToAll(this.name+”:”+read);</li><li>}<ul><li>} catch (EOFException e1) {</li></ul></li><li>System.out.println(“Client closed”); <ul><li>} catch (IOException e1) {</li></ul></li><li>e1.printStackTrace();</li><li>} finally { // 关闭资源应该放在finally中</li><li>try {</li><li>CloseUtil.close(dis, dos);</li><li>if (s != null)</li><li>s.close();<ul><li>} catch (IOException e1) {</li></ul></li><li>e1.printStackTrace();</li><li>}</li><li>}</li><li>}</li></ul><pre><code>        /**</code></pre><ul><li><ul><li>将消息发送给所有人</li></ul></li><li>* </li><li><ul><li>@param read</li></ul></li><li>*/</li></ul><pre><code>        public void transmitToAll(String read) {</code></pre><ul><li>for (int i = 0; i &lt; clients.size(); i++) {</li><li>Client c = clients.get(i);</li><li>if (c.Connected == true)</li><li>c.send(read); // 调用每个客户端线程的send方法，一个对象的输出流与对应的客户端连接 dos –&gt;</li><li>// Client</li><li>}</li><li>}</li></ul><pre><code>        /**</code></pre><ul><li><ul><li>将消息发送给某个人，私聊</li></ul></li><li>* </li><li><ul><li>@param read</li></ul></li><li><ul><li>@param clientName</li></ul></li><li>*/</li></ul><pre><code>        public void transmitToPerson(String clientName, String read) {</code></pre><ul><li>boolean isFind = false;</li><li>for (int i = 0; i &lt; clients.size(); i++) {</li><li>Client client = clients.get(i);</li><li>if (client.name.equals(clientName)) {</li><li>client.send(this.name+”:”+read);</li><li>isFind = true;</li><li>}</li><li>}</li><li>send(this.name+”:”+read + (isFind ? “” : “\n抱歉，没有找到此用户”));</li><li>}</li></ul><pre><code>        public void send(String str) {// 在哪里出错就在哪里捕获</code></pre><ul><li>try {</li><li>dos.writeUTF(str);</li><li>} catch (SocketException e) {</li><li>this.Connected = false;</li><li>clients.remove(this);</li><li>} catch (IOException e) {</li><li>e.printStackTrace();</li><li>}</li><li>}</li><li>}</li><li>}        </li><li> </li><li>Client（一个线程用于读取，一个线程用于发送)</li></ul><pre><code>public class ChatClient extends Frame {</code></pre><ul><li>Socket s = null; //将某个对象使得在一个类的各个方法可用，将该对象设置为整个类的成员变量</li><li>DataOutputStream dos = null;//在多个方法中都要使用</li><li>DataInputStream dis = null;</li><li>TextField tfText = new TextField(); // 设置为成员变量方便其他类进行访问</li><li>TextArea taContent = new TextArea();</li><li>boolean started = false;</li><li>Thread recv = null;</li><li></li><li>ChatClient(String name, int x, int y, int w, int h) {</li><li>super(name);</li><li>this.setBounds(x, y, w, h);</li><li>this.setLayout(new BorderLayout());</li><li>this.addWindowListener(new MonitorWindow());</li><li>taContent.setEditable(false);</li><li>this.add(tfText, BorderLayout.SOUTH);</li><li>this.add(taContent, BorderLayout.NORTH);</li><li>tfText.addActionListener(new MonitorText());//对于文本框的监视器必须添加在某个文本框上，只有窗口监视器才能添加到Frame上</li><li>this.pack();</li><li>this.setVisible(true); // 必须放在最后一行，否则之下的组件无法显示</li><li>connect();</li><li>ClientNameDialog dialog = new ClientNameDialog(this,”姓名提示框”,true);</li><li>}</li><li></li></ul><pre><code>    private class ClientNameDialog extends JDialog implements ActionListener{</code></pre><ul><li>JLabel jl = null;</li><li>JTextField jf = null;</li><li>JButton jb = null;</li><li></li><li>ClientNameDialog(Frame  owner,String title,boolean model){</li><li>super(owner,title,model);</li><li>this.setLayout(new BorderLayout());</li><li>this.setBounds(300, 300, 200, 150);</li><li>jl = new JLabel(“请输入您的姓名或昵称:”);</li><li>jf = new JTextField();</li><li>jb = new JButton(“确定”);</li><li>jb.addActionListener(this);</li><li>this.addWindowListener(new WindowAdapter(){</li></ul><pre><code>                public void windowClosing(WindowEvent arg0) {</code></pre><ul><li>setVisible(false);</li><li>System.exit(0);</li><li>}</li><li>});    </li><li>this.add(jl,BorderLayout.NORTH);</li><li>this.add(jf,BorderLayout.CENTER);</li><li>this.add(jb, BorderLayout.SOUTH);</li><li>this.setVisible(true);</li><li>}</li></ul><pre><code>        public void actionPerformed(ActionEvent e) {</code></pre><ul><li>String name = “”;</li><li>name = jf.getText();</li><li>if((name == null || name.equals(“”))){</li><li>JOptionPane.showMessageDialog(this, “姓名不可为空!”);</li><li>return;</li><li>}</li><li>this.setVisible(false);</li><li>send(name);</li><li>JOptionPane.showMessageDialog(this, “欢迎您,”+name);</li><li>launchThread();</li><li>}</li><li></li><li>}    </li></ul><pre><code>    private class MonitorWindow extends WindowAdapter {</code></pre><pre><code>        public void windowClosing(WindowEvent e) {</code></pre><ul><li>setVisible(false);</li><li>disConnect();</li><li>System.exit(0);</li><li>}</li><li>}</li><li></li></ul><pre><code>    private class MonitorText implements ActionListener {</code></pre><ul><li>String str = null;</li><li></li></ul><pre><code>        public void actionPerformed(ActionEvent e) {</code></pre><ul><li></li><li>str = tfText.getText().trim();//注意这是内部类，要找到事件源对象直接引用外部类的TextField即可，不需要getSource(平行类可用)</li><li>tfText.setText(“”);                     //trim可以去掉开头和结尾的空格</li><li>send(str);</li><li>}        </li><li>}</li><li></li></ul><pre><code>    public void send(String str){//为发送数据单独建立一个方法</code></pre><ul><li>try{</li><li>dos.writeUTF(str);</li><li>dos.flush();<ul><li>}catch(IOException e1){</li></ul></li><li>e1.printStackTrace();</li><li>}</li><li>}</li><li></li></ul><pre><code>    public void connect(){ //应为连接单独建立一个方法</code></pre><ul><li>try{<ul><li>s = new Socket(“localhost”,6666);</li></ul></li><li>dos = new DataOutputStream(s.getOutputStream());//一连接就打开输出流</li><li>dis = new DataInputStream(s.getInputStream());  //一连接就打开输入流</li><li>started = true;            </li><li>}catch(IOException e){</li><li>e.printStackTrace();</li><li>}                    </li><li>}</li><li></li></ul><pre><code>    public void launchThread(){</code></pre><ul><li>recv = new Thread(new Receive());</li><li>recv.start();</li><li>}</li><li></li></ul><pre><code>    public void disConnect() {</code></pre><ul><li><p>try{</p></li><li><p>dos.writeUTF(“EXIT”);</p></li><li><p>started = false;</p></li><li><p>//加入到主线程，会等待子线程执行完毕，才会执行下面的语句。这就避免了在读数据的时候将流切断，但是在这里是无效的。但是将线程停止应该先考虑使用join方法                </p></li><li><p>CloseUtil.close(dis,dos);</p></li><li><p>s.close();</p></li><li><p>} catch (IOException e) {</p></li><li><p>e.printStackTrace();</p></li><li><p>}</p></li><li><p>}</p></li><li></li></ul><pre><code>    private class Receive implements Runnable { //同样原因 readUTF是阻塞式的，处于死循环中，不能执行其他语句，所以为其单独设置一个线程</code></pre><ul><li></li></ul><pre><code>        public void run(){</code></pre><ul><li>String str = null;</li><li>try{</li><li>while(started){</li><li>str = dis.readUTF();         //如果在阻塞状态，程序被关闭，那么一定会报错SocketException。关闭了Socket之后还在调用readUTF方法</li><li>taContent.setText(taContent.getText()+str+’\n’);//解决方法是在关闭程序的同时停止线程，不再读取</li><li>(如果使用JTextArea可以使用append方法)</li><li>}    </li><li>}catch (SocketException e){         //将SocketException视为退出。但这种想法是不好的，将异常视为程序正常的一部分</li><li>System.out.println(“Client has quitted!”);</li><li>}catch (EOFException e){</li><li>System.out.println(“Client has quitted!”);</li><li>}catch(IOException e){</li><li>e.printStackTrace();</li><li>}</li><li>}</li><li>}</li></ul><pre><code>    public static void main(String[] args) {</code></pre><ul><li>new ChatClient(“Client”, 200, 200, 300, 200);        </li><li>}        </li><li>}</li></ul><h2 id="Java-NIO-使用"><a href="#Java-NIO-使用" class="headerlink" title="Java NIO 使用"></a>Java NIO 使用</h2><ul><li><p>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。</p></li><li><p>NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p></li><li><p>BIO中的accept是没有客户端连接时阻塞，NIO的accept是没有客户端连接时立即返回。</p></li><li><p>NIO的三个重要组件：Buffer、Channel、Selector。</p></li><li><p>Buffer是用于容纳数据的缓冲区，Channel是与IO设备之间的连接，类似于流。</p></li><li><p>数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p></li><li><p>Selector是Channel的多路复用器。</p><h3 id="Buffer（缓冲区"><a href="#Buffer（缓冲区" class="headerlink" title="Buffer（缓冲区)"></a>Buffer（缓冲区)</h3></li><li></li></ul><ul><li><p>clear 是将position置为0，limit置为capacity；</p></li><li><p>flip是将limit置为position，position置为0；</p><h4 id="MappedByteBuffer（对应OS中的内存映射文件"><a href="#MappedByteBuffer（对应OS中的内存映射文件" class="headerlink" title="MappedByteBuffer（对应OS中的内存映射文件)"></a>MappedByteBuffer（对应OS中的内存映射文件)</h4></li><li><p>ByteBuffer有两种模式:直接/间接。间接模式就是HeapByteBuffer,即操作堆内存 (byte[])。</p></li><li><p>但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存.这时就必须使用”直接”模式,即 MappedByteBuffer。</p></li><li><p>OS中内存映射文件是将一个文件映射为虚拟内存（文件没有真正加载到内存，只是作为虚存)，不需要使用文件系统调用来读写数据，而是直接读写内存。</p></li><li><p>Java中是使用MappedByteBuffer来将文件映射为内存的。通常可以映射整个文件，如果文件比较大的话可以分段进行映射，只要指定文件的那个部分就可以。</p></li><li><p>优点：减少一次数据拷贝</p></li><li><p>之前是  进程空间&lt;-&gt;内核的IO缓冲区&lt;-&gt;文件</p></li><li><p>现在是  进程空间&lt;-&gt;文件</p></li><li><p>MappedByteBuffer可以使用FileChannel.map方法获取。</p></li><li><p>它有更多的优点：</p></li><li><p>a. 读取快</p></li><li><p>b. 写入快</p></li><li><p>c. 随机读写</p></li></ul><ul><li><p>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</p></li><li><p>那么可用堆外内存到底是多少？，即默认堆外内存有多大：</p></li><li><p>① 如果我们没有通过-XX:MaxDirectMemorySize来指定最大的堆外内存。则</p></li><li><p>② 如果我们没通过-Dsun.nio.MaxDirectMemorySize指定了这个属性，且它不等于-1。则</p></li><li><p>③ 那么最大堆外内存的值来自于directMemory = Runtime.getRuntime().maxMemory()，这是一个native方法。</p></li><li><p>在我们使用CMS GC的情况下的实现如下：其实是新生代的最大值-一个survivor的大小+老生代的最大值，也就是我们设置的-Xmx的值里除去一个survivor的大小就是默认的堆外内存的大小了。</p></li><li><p>如果当文件过大，内存不足时，可以通过position参数重新map文件后面的内容。</p></li><li><p>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。</p></li><li></li></ul><h4 id="DirectByteBuffer（堆外内存"><a href="#DirectByteBuffer（堆外内存" class="headerlink" title="DirectByteBuffer（堆外内存)"></a>DirectByteBuffer（堆外内存)</h4><ul><li><p>DirectByteBuffer继承自MappedByteBuffer，它们都是使用的堆外内存，不受JVM堆大小的限制，只是前者仅仅是分配内存，后者是将文件映射到内存中。</p></li><li><p>可以通过ByteBuf.allocateDirect方法获取。</p></li><li><p>堆外内存的特点（大对象；加快内存拷贝；减轻GC压力)<br>- 对于大内存有良好的伸缩性（支持分配大块内存)<br>- 对垃圾回收停顿的改善可以明显感觉到（堆外内存，减少GC对堆内存回收的压力)<br>- 在进程间可以共享，减少虚拟机间的复制，加快复制速度（减少堆内内存拷贝到堆外内存的过程)<br>- 还可以使用 池+堆外内存 的组合方式，来对生命周期较短，但涉及到I/O操作的对象进行堆外内存的再使用。( Netty中就使用了该方式 )</p></li><li><p>堆外内存的一些问题</p><ul><li>1)堆外内存回收问题（不手工回收会导致内存溢出，手工回收就失去了Java的优势)；</li><li>2) 数据结构变得有些别扭。要么就是需要一个简单的数据结构以便于直接映射到堆外内存，要么就使用复杂的数据结构并序列化及反序列化到内存中。很明显使用序列化的话会比较头疼且存在性能瓶颈。使用序列化比使用堆对象的性能还差。</li></ul></li></ul><ul><li><h4 id="堆外内存的释放"><a href="#堆外内存的释放" class="headerlink" title="堆外内存的释放"></a>堆外内存的释放</h4></li><li><p>java.nio.DirectByteBuffer对象在创建过程中会先通过Unsafe接口直接通过os::malloc来分配内存，然后将内存的起始地址和大小存到java.nio.DirectByteBuffer对象里，这样就可以直接操作这些内存。这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，因此如果这些对象大部分都移到了old，但是一直没有触发CMS GC或者Full GC，那么悲剧将会发生，因为你的物理内存被他们耗尽了，因此为了避免这种悲剧的发生，通过-XX:MaxDirectMemorySize来指定最大的堆外内存大小，当使用达到了阈值的时候将调用System.gc来做一次full gc，以此来回收掉没有被使用的堆外内存。</p></li><li><p>GC方式：</p></li><li><p>存在于堆内的DirectByteBuffer对象很小，只存着基地址和大小等几个属性，和一个Cleaner，但它代表着后面所分配的一大段内存，是所谓的冰山对象。通过前面说的Cleaner，堆内的DirectByteBuffer对象被GC时，它背后的堆外内存也会被回收。</p></li><li><p>当新生代满了，就会发生minor gc；如果此时对象还没失效，就不会被回收；撑过几次minorgc后，对象被迁移到老生代；当老生代也满了，就会发生full gc。</p></li><li><p>这里可以看到一种尴尬的情况，因为DirectByteBuffer本身的个头很小，只要熬过了minor gc，即使已经失效了也能在老生代里舒服的呆着，不容易把老生代撑爆触发full gc，如果没有别的大块头进入老生代触发full gc，就一直在那耗着，占着一大片堆外内存不释放。</p></li><li><p>这时，就只能靠前面提到的申请额度超限时触发的System.gc()来救场了。但这道最后的保险其实也不很好，首先它会中断整个进程，然后它让当前线程睡了整整一百毫秒，而且如果gc没在一百毫秒内完成，它仍然会无情的抛出OOM异常。</p></li><li><p>那为什么System.gc()会释放DirectByteBuffer呢?</p></li><li><p>每个DirectByteBuffer关联着其对应的Cleaner，Cleaner是PhantomReference的子类，虚引用主要被用来跟踪对象被垃圾回收的状态，通过查看ReferenceQueue中是否包含对象所对应的虚引用来判断它是否即将被垃圾回收。</p></li><li><p>当GC时发现DirectByteBuffer除了PhantomReference外已不可达，就会把它放进 Reference类pending list静态变量里。然后另有一条ReferenceHandler线程，名字叫 “Reference Handler”的，关注着这个pending list，如果看到有对象类型是Cleaner，就会执行它的clean()，其他类型就放入应用构造Reference时传入的ReferenceQueue中，这样应用的代码可以从Queue里拖出这些理论上已死的对象，做爱做的事情——这是一种比finalizer更轻量更好的机制。</p></li></ul><ul><li>手工方式：</li><li>如果想立即释放掉一个MappedByteBuffer/DirectByteBuffer，因为JDK没有提供公开API，只能使用反射的方法去unmap；</li><li>或者使用Cleaner的clean方法。</li></ul><pre><code>public static void main(String[] args) {    try {        File f = File.createTempFile(&quot;Test&quot;, null);        f.deleteOnExit();        RandomAccessFile file = new RandomAccessFile(f, &quot;rw&quot;);        file.setLength(1024);        FileChannel channel = file.getChannel();        MappedByteBuffer buffer = channel.map(                FileChannel.MapMode.READ_WRITE, 0, 1024);        channel.close();        file.close();        // 手动unmap          Method m = FileChannelImpl.class.getDeclaredMethod(&quot;unmap&quot;,                MappedByteBuffer.class);        m.setAccessible(true);        m.invoke(FileChannelImpl.class, buffer);        if (f.delete())            System.out.println(&quot;Temporary file deleted: &quot; + f);        else            System.err.println(&quot;Not yet deleted: &quot; + f);    } catch (Exception ex) {        ex.printStackTrace();    }}</code></pre><ul><li><h3 id="Channel（通道"><a href="#Channel（通道" class="headerlink" title="Channel（通道)"></a>Channel（通道)</h3></li><li><p>Channel与IO设备的连接，与Stream是平级的概念。</p><h4 id="流与通道的区别"><a href="#流与通道的区别" class="headerlink" title="流与通道的区别"></a>流与通道的区别</h4></li><li><p>1、流是单向的，通道是双向的，可读可写。</p></li><li><p>2、流读写是阻塞的，通道可以异步读写。</p></li><li><p>3、流中的数据可以选择性的先读到缓存中，通道的数据总是要先读到一个缓存中，或从缓存中写入</p></li></ul><ul><li>注意，FileChannel 不能设置为非阻塞模式。</li></ul><h4 id="分散与聚集"><a href="#分散与聚集" class="headerlink" title="分散与聚集"></a>分散与聚集</h4><ul><li><p>分散（scatter)从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter)”到多个Buffer中。</p></li><li><p>聚集（gather)写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather)”后发送到Channel。</p><h4 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h4></li></ul><pre><code>public class PipeTest {    public static void main(String[] args) {        Pipe pipe = null;        ExecutorService exec = Executors.newFixedThreadPool(2);        try {            pipe = Pipe.open();            final Pipe pipeTemp = pipe;            exec.submit(new Callable&lt;Object&gt;() {                @Override                public Object call() throws Exception {                    Pipe.SinkChannel sinkChannel = pipeTemp.sink();//向通道中写数据                    while (true) {                        TimeUnit.SECONDS.sleep(1);                        String newData = &quot;Pipe Test At Time &quot; + System.currentTimeMillis();                        ByteBuffer buf = ByteBuffer.allocate(1024);                        buf.clear();                        buf.put(newData.getBytes());                        buf.flip();                        while (buf.hasRemaining()) {                            System.out.println(buf);                            sinkChannel.write(buf);                        }                    }                }            });            exec.submit(new Callable&lt;Object&gt;() {                @Override                public Object call() throws Exception {                    Pipe.SourceChannel sourceChannel = pipeTemp.source();//向通道中读数据                    while (true) {                        TimeUnit.SECONDS.sleep(1);                        ByteBuffer buf = ByteBuffer.allocate(1024);                        buf.clear();                        int bytesRead = sourceChannel.read(buf);                        System.out.println(&quot;bytesRead=&quot; + bytesRead);                        while (bytesRead &gt; 0) {                            buf.flip();                            byte b[] = new byte[bytesRead];                            int i = 0;                            while (buf.hasRemaining()) {                                b[i] = buf.get();                                System.out.printf(&quot;%X&quot;, b[i]);                                i++;                            }                            String s = new String(b);                            System.out.println(&quot;=================||&quot; + s);                            bytesRead = sourceChannel.read(buf);                        }                    }                }            });        } catch (IOException e) {            e.printStackTrace();        } finally {            exec.shutdown();        }    }}</code></pre><ul><li><h4 id="FileChannel与文件锁"><a href="#FileChannel与文件锁" class="headerlink" title="FileChannel与文件锁"></a>FileChannel与文件锁</h4></li><li><p>在通道中我们可以对文件或者部分文件进行上锁。上锁和我们了解的线程锁差不多，都是为了保证数据的一致性。在文件通道FileChannel中可以对文件进行上锁，通过FileLock可以对文件进行锁的释放。</p></li><li><p>文件加锁是建立在文件通道（FileChannel)之上的，套接字通道（SockeChannel)不考虑文件加锁，因为它是不共享的。它对文件加锁有两种方式：</p></li><li><p>①lock</p></li><li><p>②tryLock</p></li><li><p>两种加锁方式默认都是对整个文件加锁，如果自己配置的话就可以控制加锁的文件范围：position是加锁的开始位置，size是加锁长度，shared是用于控制该锁是共享的还是独占的。 </p></li><li><p>lock是阻塞式的，当有进程对锁进行读取时会等待锁的释放，在此期间它会一直等待；tryLock是非阻塞式的，它尝试获得锁，如果这个锁不能获得，那么它会立即返回。 </p></li><li><p>release可以释放锁。</p></li><li><p>在一个进程中在锁没有释放之前是无法再次获得锁的</p></li><li><p>在java的NIO中，通道包下面有一个FileLock类，它主要是对文件锁工具的一个描述。在上一小节中对文件的锁获取其实是FileChannel获取的（lock与trylock是FileChannel的方法)，它们返回一个FileLock对象。这个类的核心方法有如下这些： </p></li><li><p>boolean isShared() :判断锁是否为共享类型 </p></li><li><p>abstract boolean isValid() ：判断锁是否有效 </p></li><li><p>boolean overlaps()：判断此锁定是否与给定的锁定区域重叠 </p></li><li><p>long position()：返回文件内锁定区域中第一个字节的位置。 </p></li><li><p>abstract void release() ：释放锁 </p></li><li><p>long size() ：返回锁定区域的大小，以字节为单位</p></li><li><p>在文件锁中有3种方式可以释放文件锁：①锁类释放锁，调用FileLock的release方法； ②通道类关闭通道，调用FileChannel的close方法；③jvm虚拟机会在特定情况释放锁。</p></li></ul><ul><li><p>锁类型（独占式和共享式)</p></li><li><p>我们先区分一下在文件锁中两种锁的区别：①独占式的锁就想我们上面测试的那样，只要有一个进程获取了独占锁，那么别的进程只能等待。②共享锁在一个进程获取的情况下，别的进程还是可以读取被锁定的文件，但是别的进程不能写只能读。 </p></li><li></li></ul><h3 id="Selector-（Channel的多路复用器"><a href="#Selector-（Channel的多路复用器" class="headerlink" title="Selector （Channel的多路复用器)"></a>Selector （Channel的多路复用器)</h3><ul><li>Selector可以用单线程去管理多个Channel（多个连接)。</li><li>放在网络编程的环境下：Selector使用单线程，轮询客户端对应的Channel的请求，如果某个Channel需要进行IO，那么分配一个线程去执行IO操作。</li><li>Selector可以去监听的请求有以下几类：<ul><li>1、connect：客户端连接服务端事件，对应值为SelectionKey.OPCONNECT(8) </li><li>2、accept：服务端接收客户端连接事件，对应值为SelectionKey.OPACCEPT(16) </li><li>3、read：读事件，对应值为SelectionKey.OPREAD(1) </li><li>4、write：写事件，对应值为SelectionKey.OPWRITE(4)</li></ul></li><li>每次请求到达服务器，都是从connect开始，connect成功后，服务端开始准备accept，准备就绪，开始读数据，并处理，最后写回数据返回。</li><li>SelectionKey是一个复合事件，绑定到某个selector对应的某个channel上，可能是多个事件的复合或单一事件。</li></ul><h2 id="Java-NIO-实例（文件上传"><a href="#Java-NIO-实例（文件上传" class="headerlink" title="Java NIO 实例（文件上传)"></a>Java NIO 实例（文件上传)</h2><ul><li>服务器主线程先创建Socket，并注册到selector，然后轮询selector。<ul><li>1)如果有客户端需要进行连接，那么selector返回ACCEPT事件，主线程建立连接（accept)，并将该客户端连接注册到selector，结束，继续轮询selector等待下一个客户端事件；</li><li>2)如果有已连接的客户端需要进行读写，那么selector返回READ/WRITE事件，主线程将该请求交给IO线程池中的某个线程执行操作，结束，继续轮询selector等待下一个客户端事件。<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3></li></ul></li></ul><pre><code>public class NIOTCPServer {    private ServerSocketChannel serverSocketChannel;    private final String FILE_PATH = &quot;E:/uploads/&quot;;    private AtomicInteger i;    private final String RESPONSE_MSG = &quot;服务器接收数据成功&quot;;    private Selector selector;    private ExecutorService acceptPool;    private ExecutorService readPool;    public NIOTCPServer() {        try {            serverSocketChannel = ServerSocketChannel.open();            //切换为非阻塞模式            serverSocketChannel.configureBlocking(false);            serverSocketChannel.bind(new InetSocketAddress(9000));            //获得选择器            selector = Selector.open();            //将channel注册到selector上            //第二个参数是选择键，用于说明selector监控channel的状态            //可能的取值：SelectionKey.OP_READ OP_WRITE OP_CONNECT OP_ACCEPT            //监控的是channel的接收状态            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            acceptPool = new ThreadPoolExecutor(50, 100, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;());            readPool = new ThreadPoolExecutor(50, 100, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;());            i = new AtomicInteger(0);            System.out.println(&quot;服务器启动&quot;);        } catch (IOException e) {            e.printStackTrace();        }    }    public void receive() {        try {            //如果有一个及以上的客户端的数据准备就绪            while (selector.select() &gt; 0) {                //获取当前选择器中所有注册的监听事件                for (Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); it.hasNext(); ) {                    SelectionKey key = it.next();                    //如果&quot;接收&quot;事件已就绪                    if (key.isAcceptable()) {                        //交由接收事件的处理器处理                        acceptPool.submit(new ReceiveEventHander());                    } else if (key.isReadable()) {                        //如果&quot;读取&quot;事件已就绪                        //交由读取事件的处理器处理                        readPool.submit(new ReadEventHandler((SocketChannel) key.channel()));                    }                    //处理完毕后，需要取消当前的选择键                    it.remove();                }            }        } catch (IOException e) {            e.printStackTrace();        }    }    class ReceiveEventHander implements Runnable {        public ReceiveEventHander() {        }        @Override        public void run() {            SocketChannel client = null;            try {                client = serverSocketChannel.accept();                // 接收的客户端也要切换为非阻塞模式                client.configureBlocking(false);                // 监控客户端的读操作是否就绪                client.register(selector, SelectionKey.OP_READ);                System.out.println(&quot;服务器连接客户端:&quot; + client.toString());            } catch (IOException e) {                e.printStackTrace();            }        }    }    class ReadEventHandler implements Runnable {        private ByteBuffer buf;        private SocketChannel client;        public ReadEventHandler(SocketChannel client) {            this.client = client;            buf = ByteBuffer.allocate(1024);        }        @Override        public void run() {            FileChannel fileChannel = null;            try {                int index = 0;                synchronized (client) {                    while (client.read(buf) != -1) {                        if (fileChannel == null) {                            index = i.getAndIncrement();                            fileChannel = FileChannel.open(Paths.get(FILE_PATH, index + &quot;.jpeg&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);                        }                        buf.flip();                        fileChannel.write(buf);                        buf.clear();                    }                }                if (fileChannel != null) {                    fileChannel.close();                    System.out.println(&quot;服务器写来自客户端&quot; + client + &quot; 文件&quot; + index + &quot; 完毕&quot;);                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        NIOTCPServer server = new NIOTCPServer();        server.receive();    }}</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code>public class NIOTCPClient {    private SocketChannel clientChannel;    private ByteBuffer buf;    public NIOTCPClient() {        try {            clientChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9000));            //设置客户端为非阻塞模式            clientChannel.configureBlocking(false);            buf = ByteBuffer.allocate(1024);        } catch (IOException e) {            e.printStackTrace();        }    }    public void send(String fileName) {        try {            FileChannel fileChannel = FileChannel.open(Paths.get(fileName), StandardOpenOption.READ);            while (fileChannel.read(buf) != -1) {                buf.flip();                clientChannel.write(buf);                buf.clear();            }            System.out.println(&quot;客户端已发送文件&quot; + fileName);            fileChannel.close();            clientChannel.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        ExecutorService pool = new ThreadPoolExecutor(50, 100, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;&gt;());        Instant begin = Instant.now();        for (int i = 0; i &lt; 200; i++) {            pool.submit(() -&gt; {                NIOTCPClient client = new NIOTCPClient();                client.send(&quot;E:/1.jpeg&quot;);            });        }        pool.shutdown();        Instant end = Instant.now();        System.out.println(Duration.between(begin,end));    }}</code></pre><ul><li><h2 id="Java-AIO-使用"><a href="#Java-AIO-使用" class="headerlink" title="Java AIO 使用"></a>Java AIO 使用</h2></li><li><p>对AIO来说，它不是在IO准备好时再通知线程，而是在IO操作已经完成后，再给线程发出通知。因此AIO是不会阻塞的，此时我们的业务逻辑将变成一个回调函数，等待IO操作完成后，由系统自动触发。</p></li><li><p>AIO的四步：</p></li><li><p>1、进程向操作系统请求数据 </p></li><li><p>2、操作系统把外部数据加载到内核的缓冲区中， </p></li><li><p>3、操作系统把内核的缓冲区拷贝到进程的缓冲区 </p></li><li><p>4、进程获得数据完成自己的功能</p></li><li><p>JDK1.7主要增加了三个新的异步通道：</p></li><li><p>AsynchronousFileChannel: 用于文件异步读写；</p></li><li><p>AsynchronousSocketChannel: 客户端异步socket；</p></li><li><p>AsynchronousServerSocketChannel: 服务器异步socket。</p></li><li><p>因为AIO的实施需充分调用OS参与，IO需要操作系统支持、并发也同样需要操作系统的</p></li><li><p>在AIO socket编程中，服务端通道是AsynchronousServerSocketChannel，这个类提供了一个open()静态工厂，一个bind()方法用于绑定服务端IP地址（还有端口号)，另外还提供了accept()用于接收用户连接请求。在客户端使用的通道是AsynchronousSocketChannel,这个通道处理提供open静态工厂方法外，还提供了read和write方法。</p></li><li><p>在AIO编程中，发出一个事件（accept read write等)之后要指定事件处理类（回调函数)，AIO中的事件处理类是CompletionHandler&lt;V,A&gt;，这个接口定义了如下两个方法，分别在异步操作成功和失败时被回调。</p></li><li><p>void completed(V result, A attachment);</p></li><li><p>void failed(Throwable exc, A attachment);</p></li></ul><pre><code>public class AIOServer {    private static int PORT = 8080;    private static int BUFFER_SIZE = 1024;    private static String CHARSET = &quot;utf-8&quot;; //默认编码      private static CharsetDecoder decoder = Charset.forName(CHARSET).newDecoder(); //解码      private AsynchronousServerSocketChannel serverChannel;    public AIOServer() {        this.decoder = Charset.forName(CHARSET).newDecoder();    }    private void listen() throws Exception {        //打开一个服务通道          //绑定服务端口          this.serverChannel = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT), 100);        this.serverChannel.accept(this, new AcceptHandler());    }    /**     * accept到一个请求时的回调     */    private class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, AIOServer&gt; {        @Override        public void completed(final AsynchronousSocketChannel client, AIOServer server) {            try {                System.out.println(&quot;远程地址：&quot; + client.getRemoteAddress());                //tcp各项参数                  client.setOption(StandardSocketOptions.TCP_NODELAY, true);                client.setOption(StandardSocketOptions.SO_SNDBUF, 1024);                client.setOption(StandardSocketOptions.SO_RCVBUF, 1024);                if (client.isOpen()) {                    System.out.println(&quot;client.isOpen：&quot; + client.getRemoteAddress());                    final ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);                    buffer.clear();                    client.read(buffer, client, new ReadHandler(buffer));                }            } catch (Exception e) {                e.printStackTrace();            } finally {                server.serverChannel.accept(server, this);// 监听新的请求，递归调用。              }        }        @Override        public void failed(Throwable e, AIOServer attachment) {            try {                e.printStackTrace();            } finally {                attachment.serverChannel.accept(attachment, this);// 监听新的请求，递归调用。              }        }    }    /**     * Read到请求数据的回调     */    private class ReadHandler implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; {        private ByteBuffer buffer;        public ReadHandler(ByteBuffer buffer) {            this.buffer = buffer;        }        @Override        public void completed(Integer result, AsynchronousSocketChannel client) {            try {                if (result &lt; 0) {// 客户端关闭了连接                      AIOServer.close(client);                } else if (result == 0) {                    System.out.println(&quot;空数据&quot;); // 处理空数据                  } else {                    // 读取请求，处理客户端发送的数据                      buffer.flip();                    CharBuffer charBuffer = AIOServer.decoder.decode(buffer);                    System.out.println(charBuffer.toString()); //接收请求                      //响应操作，服务器响应结果                      buffer.clear();                    String res = &quot;hellworld&quot;;                    buffer = ByteBuffer.wrap(res.getBytes());                    client.write(buffer, client, new WriteHandler(buffer));//Response：响应。                  }            } catch (Exception e) {                e.printStackTrace();            }        }        @Override        public void failed(Throwable exc, AsynchronousSocketChannel attachment) {            exc.printStackTrace();            AIOServer.close(attachment);        }    }    /**     * Write响应完请求的回调     */    private class WriteHandler implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; {        private ByteBuffer buffer;        public WriteHandler(ByteBuffer buffer) {            this.buffer = buffer;        }        @Override        public void completed(Integer result, AsynchronousSocketChannel attachment) {            buffer.clear();            AIOServer.close(attachment);        }        @Override        public void failed(Throwable exc, AsynchronousSocketChannel attachment) {            exc.printStackTrace();            AIOServer.close(attachment);        }    }    private static void close(AsynchronousSocketChannel client) {        try {            client.close();        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        try {            System.out.println(&quot;正在启动服务...&quot;);            AIOServer AIOServer = new AIOServer();            AIOServer.listen();            Thread t = new Thread(new Runnable() {                @Override                public void run() {                    while (true) {                    }                }            });            t.start();        } catch (Exception e) {            e.printStackTrace();        }    }}  </code></pre><ul><li><h2 id="Java-NIO-源码"><a href="#Java-NIO-源码" class="headerlink" title="Java NIO 源码"></a>Java NIO 源码</h2></li><li><p>关于Selector源码过于难以理解，可以先放过。</p><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3></li></ul><pre><code>public abstract class Buffer {    /**     * The characteristics of Spliterators that traverse and split elements     * maintained in Buffers.     */    static final int SPLITERATOR_CHARACTERISTICS =        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;    // Invariants: mark &lt;= position &lt;= limit &lt;= capacity    private int mark = -1;    private int position = 0;    private int limit;    private int capacity;    // Used only by direct buffers    // NOTE: hoisted here for speed in JNI GetDirectBufferAddress    long address;    // Creates a new buffer with the given mark, position, limit, and capacity,    // after checking invariants.    //    Buffer(int mark, int pos, int lim, int cap) {       // package-private        if (cap &lt; 0)            throw new IllegalArgumentException(&quot;Negative capacity: &quot; + cap);        this.capacity = cap;        limit(lim);        position(pos);        if (mark &gt;= 0) {            if (mark &gt; pos)                throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;                                                   + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);            this.mark = mark;        }    }</code></pre><ul><li>}</li><li>ByteBuffer有两种实现：HeapByteBuffer和DirectByteBuffer。</li><li>ByteBuffer#allocate</li></ul><pre><code>public static ByteBuffer allocate(int capacity) {    if (capacity &lt; 0)        throw new IllegalArgumentException();    return new HeapByteBuffer(capacity, capacity);}</code></pre><ul><li>ByteBuffer#allocateDirect</li></ul><pre><code>public static ByteBuffer allocateDirect(int capacity) {    return new DirectByteBuffer(capacity);}</code></pre><h3 id="HeapByteBuffer（间接模式"><a href="#HeapByteBuffer（间接模式" class="headerlink" title="HeapByteBuffer（间接模式)"></a>HeapByteBuffer（间接模式)</h3><ul><li>底层基于byte数组。<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4></li></ul><pre><code>HeapByteBuffer(int cap, int lim) {            // package-private    super(-1, 0, lim, cap, new byte[cap], 0);}</code></pre><ul><li>调用的是ByteBuffer的初始化方法</li></ul><pre><code>ByteBuffer(int mark, int pos, int lim, int cap,   // package-private             byte[] hb, int offset){    super(mark, pos, lim, cap);    this.hb = hb;    this.offset = offset;}</code></pre><ul><li>ByteBuffer的独有成员变量：</li><li>final byte[] hb;                  // Non-null only for heap buffers<br>final int offset;<br>boolean isReadOnly;                 // Valid only for heap buffers</li></ul><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code>public byte get() {    return hb[ix(nextGetIndex())];}</code></pre><pre><code>final int nextGetIndex() {                          // package-private    if (position &gt;= limit)        throw new BufferUnderflowException();    return position++;}</code></pre><ul><li>protected int ix(int i) {<br>  return i + offset;<br>}</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><pre><code>public ByteBuffer put(byte x) {    hb[ix(nextPutIndex())] = x;    return this;}</code></pre><pre><code>final int nextPutIndex() {                          // package-private    if (position &gt;= limit)        throw new BufferOverflowException();    return position++;}</code></pre><ul><li><h3 id="DirectByteBuffer（直接模式"><a href="#DirectByteBuffer（直接模式" class="headerlink" title="DirectByteBuffer（直接模式)"></a>DirectByteBuffer（直接模式)</h3></li><li><p>底层基于c++的malloc分配的堆外内存，是使用Unsafe类分配的，底层调用了native方法。</p></li><li><p>在创建DirectByteBuffer的同时，创建一个与其对应的cleaner，cleaner是一个虚引用。</p></li><li><p>回收堆外内存的几种情况：</p><ul><li>1)程序员手工释放，需要使用sun的非公开API实现。</li><li>2)申请新的堆外内存而内存不足时，会进行调用Cleaner（作为一个Reference)的静态方法tryHandlePending(false)，它又会调用cleaner的clean方法释放内存。</li><li>3)当DirectByteBuffer失去强引用,只有虚引用时，当等到某一次System.gc（full gc)（比如堆外内存达到XX:MaxDirectMemorySize)时，当DirectByteBuffer对象从pending状态 -&gt; enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4></li></ul></li><li><p>重要成员变量：</p></li></ul><pre><code>private final Cleaner cleaner;</code></pre><ul><li>// Cached unsafe-access object<br>protected static final Unsafe unsafe = Bits.unsafe();</li><li>Unsafe中很多都是native方法，底层调用c++代码。</li></ul><pre><code>DirectByteBuffer(int cap) {                   // package-private    super(-1, 0, cap, cap);</code></pre><ul><li><p>// 内存是否按页分配对齐<br>  boolean pa = VM.isDirectMemoryPageAligned();</p></li><li><p>// 获取每页内存大小<br>  int ps = Bits.pageSize();</p></li><li><p>// 分配内存的大小，如果是按页对齐方式，需要再加一页内存的容量<br>  long size = Math.max(1L, (long)cap + (pa ? ps : 0));</p></li><li><p>// 用Bits类保存总分配内存(按页分配)的大小和实际内存的大小<br>  Bits.reserveMemory(size, cap);</p><p>  long base = 0;<br>  try {</p></li><li><p>// 在堆外内存的基地址，指定内存大小</p><pre><code>  base = unsafe.allocateMemory(size);</code></pre><p>  } catch (OutOfMemoryError x) {</p><pre><code>  Bits.unreserveMemory(size, cap);  throw x;</code></pre><p>  }<br>  unsafe.setMemory(base, size, (byte) 0);</p><ul><li>// 计算堆外内存的基地址<br>if (pa &amp;&amp; (base % ps != 0)) {<br>  // Round up to page boundary<br>  address = base + ps - (base &amp; (ps - 1));<br>} else {<br>  address = base;<br>}<br>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));<br>att = null;<br>}</li></ul></li><li><p>第一行super调用的是其父类MappedByteBuffer的构造方法</p></li></ul><pre><code>MappedByteBuffer(int mark, int pos, int lim, int cap) { // package-private    super(mark, pos, lim, cap);    this.fd = null;}</code></pre><ul><li>而它的super又调用了ByteBuffer的构造方法</li></ul><pre><code>ByteBuffer(int mark, int pos, int lim, int cap) { // package-private    this(mark, pos, lim, cap, null, 0);}</code></pre><ul><li><p>Bits#reserveMemory</p></li><li><p>该方法用于在系统中保存总分配内存(按页分配)的大小和实际内存的大小。</p></li><li><p>总的来说，Bits.reserveMemory(size, cap)方法在可用堆外内存不足以分配给当前要创建的堆外内存大小时，会实现以下的步骤来尝试完成本次堆外内存的创建：</p></li><li><p>① 触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。</p></li><li><p>② 如果进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则进行 System.gc()。System.gc()会触发一个full gc，但你需要知道，调用System.gc()并不能够保证full gc马上就能被执行。所以在后面打代码中，会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试之前，都对延迟等待时间，已给JVM足够的时间去完成full gc操作。</p></li><li><p>这里之所以用使用full gc的很重要的一个原因是：System.gc()会对新生代和老生代都会进行内存回收，这样会比较彻底地回收DirectByteBuffer对象以及他们关联的堆外内存.</p></li><li><p>DirectByteBuffer对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象.</p></li><li><p>我们做young gc的时候会将新生代里的不可达的DirectByteBuffer对象及其堆外内存回收了，但是无法对old里的DirectByteBuffer对象及其堆外内存进行回收，这也是我们通常碰到的最大的问题。(并且堆外内存多用于生命期中等或较长的对象)</p></li><li><p>如果有大量的DirectByteBuffer对象移到了old，但是又一直没有做cms gc或者full gc，而只进行ygc，那么我们的物理内存可能被慢慢耗光，但是我们还不知道发生了什么，因为heap明明剩余的内存还很多(前提是我们禁用了System.gc – JVM参数DisableExplicitGC)。</p></li><li><p>注意，如果你设置了-XX:+DisableExplicitGC，将会禁用显示GC，这会使System.gc()调用无效。</p></li><li><p>③ 如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(“Direct buffer memory”)异常。</p></li><li><p>static void reserveMemory(long size, int cap) {</p><p>  if (!memoryLimitSet &amp;&amp; VM.isBooted()) {</p><pre><code>  maxMemory = VM.maxDirectMemory();  memoryLimitSet = true;</code></pre><p>  }</p><p>  // optimist!<br>  if (tryReserveMemory(size, cap)) {</p><pre><code>  return;</code></pre><p>  }</p><p>  final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();<br>  // 如果系统中内存( 即，堆外内存 )不够的话：</p></li><li><p>jlra.tryHandlePendingReference()会触发一次非堵塞的Reference#tryHandlePending(false)。该方法会将已经被JVM垃圾回收的DirectBuffer对象的堆外内存释放。</p></li><li><p>  // retry while helping enqueue pending Reference objects<br>  // which includes executing pending Cleaner(s) which includes<br>  // Cleaner(s) that free direct buffer memory<br>  while (jlra.tryHandlePendingReference()) {</p><pre><code>  if (tryReserveMemory(size, cap)) {      return;  }</code></pre><p>  }<br>  // 如果在进行一次堆外内存资源回收后，还不够进行本次堆外内存分配的话，则<br>  // trigger VM’s Reference processing<br>  System.gc();</p><p>  // a retry loop with exponential back-off delays<br>  // (this gives VM some time to do it’s job)<br>  boolean interrupted = false;<br>  try {</p><pre><code>  long sleepTime = 1;  int sleeps = 0;  while (true) {      if (tryReserveMemory(size, cap)) {          return;      }</code></pre></li><li><p>// 9</p><pre><code>      if (sleeps &gt;= MAX_SLEEPS) {          break;      }      if (!jlra.tryHandlePendingReference()) {          try {              Thread.sleep(sleepTime);              sleepTime &lt;&lt;= 1;              sleeps++;          } catch (InterruptedException e) {              interrupted = true;          }      }  }  // 如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(&quot;Direct buffer memory”)异常。  // no luck  throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</code></pre><p>  } finally {</p><pre><code>  if (interrupted) {      // don&#39;t swallow interrupts      Thread.currentThread().interrupt();  }</code></pre><p>  }<br>}</p></li><li><p>Reference#tryHandlePending</p></li><li><p>static boolean tryHandlePending(boolean waitForNotify) {<br>  Reference<Object> r;<br>  Cleaner c;<br>  try {</p><pre><code>  synchronized (lock) {      if (pending != null) {          r = pending;          // &#39;instanceof&#39; might throw OutOfMemoryError sometimes          // so do this before un-linking &#39;r&#39; from the &#39;pending&#39; chain...          c = r instanceof Cleaner ? (Cleaner) r : null;          // unlink &#39;r&#39; from &#39;pending&#39; chain          pending = r.discovered;          r.discovered = null;      } else {          // The waiting on the lock may cause an OutOfMemoryError          // because it may try to allocate exception objects.          if (waitForNotify) {              lock.wait();          }          // retry if waited          return waitForNotify;      }  }</code></pre><p>  } catch (OutOfMemoryError x) {</p><pre><code>  // Give other threads CPU time so they hopefully drop some live references  // and GC reclaims some space.  // Also prevent CPU intensive spinning in case &#39;r instanceof Cleaner&#39; above  // persistently throws OOME for some time...  Thread.yield();  // retry  return true;</code></pre><p>  } catch (InterruptedException x) {</p><pre><code>  // retry  return true;</code></pre><p>  }</p><p>  // Fast path for cleaners<br>  if (c != null) {</p><pre><code>  c.clean();  return true;</code></pre><p>  }</p><p>  ReferenceQueue&lt;? super Object&gt; q = r.queue;<br>  if (q != ReferenceQueue.NULL) q.enqueue(r);<br>  return true;<br>}</p></li></ul><h4 id="Deallocator"><a href="#Deallocator" class="headerlink" title="Deallocator"></a>Deallocator</h4><ul><li>后面是调用unsafe的分配堆外内存的方法，然后初始化了该DirectByteBuffer对应的cleaner。</li><li>注：在Cleaner 内部中通过一个列表，维护了一个针对每一个 directBuffer 的一个回收堆外内存的 线程对象(Runnable)，回收操作是发生在 Cleaner 的 clean() 方法中。</li></ul><pre><code>private static class Deallocator    implements Runnable{    private static Unsafe unsafe = Unsafe.getUnsafe();    private long address;    private long size;    private int capacity;    private Deallocator(long address, long size, int capacity) {        assert (address != 0);        this.address = address;        this.size = size;        this.capacity = capacity;    }    public void run() {        if (address == 0) {            // Paranoia            return;        }        unsafe.freeMemory(address);        address = 0;        Bits.unreserveMemory(size, capacity);    }}</code></pre><h4 id="Cleaner（回收"><a href="#Cleaner（回收" class="headerlink" title="Cleaner（回收)"></a>Cleaner（回收)</h4><pre><code>public class Cleaner extends PhantomReference&lt;Object&gt; {    private static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue();    private static Cleaner first = null;    private Cleaner next = null;    private Cleaner prev = null;    private final Runnable thunk;    private static synchronized Cleaner add(Cleaner var0) {        if (first != null) {            var0.next = first;            first.prev = var0;        }        first = var0;        return var0;    }    private static synchronized boolean remove(Cleaner var0) {        if (var0.next == var0) {            return false;        } else {            if (first == var0) {                if (var0.next != null) {                    first = var0.next;                } else {                    first = var0.prev;                }            }            if (var0.next != null) {                var0.next.prev = var0.prev;            }            if (var0.prev != null) {                var0.prev.next = var0.next;            }            var0.next = var0;            var0.prev = var0;            return true;        }    }    private Cleaner(Object var1, Runnable var2) {        super(var1, dummyQueue);        this.thunk = var2;    }    // var0是DirectByteBuffer，var1是Deallocator线程对象    public static Cleaner create(Object var0, Runnable var1) {        return var1 == null ? null : add(new Cleaner(var0, var1));    }    public void clean() {        if (remove(this)) {            try {</code></pre><pre><code>// 回收该DirectByteBuffer对应的堆外内存                this.thunk.run();            } catch (final Throwable var2) {                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {                    public Void run() {                        if (System.err != null) {                            (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();                        }                        System.exit(1);                        return null;                    }                });            }        }    }}</code></pre><ul><li>Cleaner的构造方法中又调用了父类虚引用的构造方法：</li></ul><pre><code>public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) {    super(referent, q);}</code></pre><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><pre><code>public byte get() {    return ((unsafe.getByte(ix(nextGetIndex()))));}</code></pre><h4 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h4><pre><code>public ByteBuffer put(byte x) {    unsafe.putByte(ix(nextPutIndex()), ((x)));    return this;}</code></pre><ul><li><h3 id="FileChannel（阻塞式"><a href="#FileChannel（阻塞式" class="headerlink" title="FileChannel（阻塞式)"></a>FileChannel（阻塞式)</h3></li><li><p>FileChannel的read、write和map通过其实现类FileChannelImpl实现。</p></li><li><p>FileChannelImpl的Oracle JDK没有提供源码，只能在OpenJDK中查看。</p><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4></li></ul><pre><code>public static FileChannel open(Path path, OpenOption... options)    throws IOException{    Set&lt;OpenOption&gt; set = new HashSet&lt;OpenOption&gt;(options.length);    Collections.addAll(set, options);    return open(path, set, NO_ATTRIBUTES);}</code></pre><pre><code>public static FileChannel open(Path path,                               Set&lt;? extends OpenOption&gt; options,                               FileAttribute&lt;?&gt;... attrs)    throws IOException{    FileSystemProvider provider = path.getFileSystem().provider();    return provider.newFileChannel(path, options, attrs);}</code></pre><ul><li>WindowsFileSystemProvider#newFileChannel</li></ul><pre><code>public FileChannel newFileChannel(Path path,                                  Set&lt;? extends OpenOption&gt; options,                                  FileAttribute&lt;?&gt;... attrs)    throws IOException{    if (path == null)        throw new NullPointerException();    if (!(path instanceof WindowsPath))        throw new ProviderMismatchException();    WindowsPath file = (WindowsPath)path;    WindowsSecurityDescriptor sd = WindowsSecurityDescriptor.fromAttribute(attrs);    try {        return WindowsChannelFactory            .newFileChannel(file.getPathForWin32Calls(),                            file.getPathForPermissionCheck(),                            options,                            sd.address());    } catch (WindowsException x) {        x.rethrowAsIOException(file);        return null;    } finally {        if (sd != null)            sd.release();    }}</code></pre><ul><li><p>WindowsChannelFactory#newFileChannel</p></li><li><p>static FileChannel newFileChannel(String pathForWindows,</p><pre><code>                            String pathToCheck,                            Set&lt;? extends OpenOption&gt; options,                            long pSecurityDescriptor)</code></pre><p>  throws WindowsException<br>{<br>  Flags flags = Flags.toFlags(options);</p><p>  // default is reading; append =&gt; writing<br>  if (!flags.read &amp;&amp; !flags.write) {</p><pre><code>  if (flags.append) {      flags.write = true;  } else {      flags.read = true;  }</code></pre><p>  }</p><p>  // validation<br>  if (flags.read &amp;&amp; flags.append)</p><pre><code>  throw new IllegalArgumentException(&quot;READ + APPEND not allowed&quot;);</code></pre><p>  if (flags.append &amp;&amp; flags.truncateExisting)</p><pre><code>  throw new IllegalArgumentException(&quot;APPEND + TRUNCATE_EXISTING not allowed&quot;);</code></pre><p>  FileDescriptor fdObj = open(pathForWindows, pathToCheck, flags, pSecurityDescriptor);<br>  return FileChannelImpl.open(fdObj, pathForWindows, flags.read, flags.write, flags.append, null);<br>}</p></li></ul><pre><code>/** * Opens file based on parameters and options, returning a FileDescriptor * encapsulating the handle to the open file. */private static FileDescriptor open(String pathForWindows,                                   String pathToCheck,                                   Flags flags,                                   long pSecurityDescriptor)    throws WindowsException{    // set to true if file must be truncated after open    boolean truncateAfterOpen = false;    // map options    int dwDesiredAccess = 0;    if (flags.read)        dwDesiredAccess |= GENERIC_READ;    if (flags.write)        dwDesiredAccess |= GENERIC_WRITE;    int dwShareMode = 0;    if (flags.shareRead)        dwShareMode |= FILE_SHARE_READ;    if (flags.shareWrite)        dwShareMode |= FILE_SHARE_WRITE;    if (flags.shareDelete)        dwShareMode |= FILE_SHARE_DELETE;    int dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;    int dwCreationDisposition = OPEN_EXISTING;    if (flags.write) {        if (flags.createNew) {            dwCreationDisposition = CREATE_NEW;            // force create to fail if file is orphaned reparse point            dwFlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;        } else {            if (flags.create)                dwCreationDisposition = OPEN_ALWAYS;            if (flags.truncateExisting) {                // Windows doesn&#39;t have a creation disposition that exactly                // corresponds to CREATE + TRUNCATE_EXISTING so we use                // the OPEN_ALWAYS mode and then truncate the file.                if (dwCreationDisposition == OPEN_ALWAYS) {                    truncateAfterOpen = true;                } else {                    dwCreationDisposition = TRUNCATE_EXISTING;                }            }        }    }    if (flags.dsync || flags.sync)        dwFlagsAndAttributes |= FILE_FLAG_WRITE_THROUGH;    if (flags.overlapped)        dwFlagsAndAttributes |= FILE_FLAG_OVERLAPPED;    if (flags.deleteOnClose)        dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;    // NOFOLLOW_LINKS and NOFOLLOW_REPARSEPOINT mean open reparse point    boolean okayToFollowLinks = true;    if (dwCreationDisposition != CREATE_NEW &amp;&amp;        (flags.noFollowLinks ||         flags.openReparsePoint ||         flags.deleteOnClose))    {        if (flags.noFollowLinks || flags.deleteOnClose)            okayToFollowLinks = false;        dwFlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;    }    // permission check    if (pathToCheck != null) {        SecurityManager sm = System.getSecurityManager();        if (sm != null) {            if (flags.read)                sm.checkRead(pathToCheck);            if (flags.write)                sm.checkWrite(pathToCheck);            if (flags.deleteOnClose)                sm.checkDelete(pathToCheck);        }    }    // open file    long handle = CreateFile(pathForWindows,                             dwDesiredAccess,                             dwShareMode,                             pSecurityDescriptor,                             dwCreationDisposition,                             dwFlagsAndAttributes);    // make sure this isn&#39;t a symbolic link.    if (!okayToFollowLinks) {        try {            if (WindowsFileAttributes.readAttributes(handle).isSymbolicLink())                throw new WindowsException(&quot;File is symbolic link&quot;);        } catch (WindowsException x) {            CloseHandle(handle);            throw x;        }    }    // truncate file (for CREATE + TRUNCATE_EXISTING case)    if (truncateAfterOpen) {        try {            SetEndOfFile(handle);        } catch (WindowsException x) {            CloseHandle(handle);            throw x;        }    }    // make the file sparse if needed    if (dwCreationDisposition == CREATE_NEW &amp;&amp; flags.sparse) {        try {            DeviceIoControlSetSparse(handle);        } catch (WindowsException x) {            // ignore as sparse option is hint        }    }    // create FileDescriptor and return    FileDescriptor fdObj = new FileDescriptor();    fdAccess.setHandle(fdObj, handle);    return fdObj;}</code></pre><ul><li>static long CreateFile(String path,<pre><code>                 int dwDesiredAccess,                 int dwShareMode,                 long lpSecurityAttributes,                 int dwCreationDisposition,                 int dwFlagsAndAttributes)</code></pre>  throws WindowsException<br>{<br>  NativeBuffer buffer = asNativeBuffer(path);<br>  try {<pre><code>  return CreateFile0(buffer.address(),                     dwDesiredAccess,                     dwShareMode,                     lpSecurityAttributes,                     dwCreationDisposition,                     dwFlagsAndAttributes);</code></pre>  } finally {<pre><code>  buffer.release();</code></pre>  }<br>}</li></ul><pre><code>private static native long CreateFile0(long lpFileName,                                       int dwDesiredAccess,                                       int dwShareMode,                                       long lpSecurityAttributes,                                       int dwCreationDisposition,                                       int dwFlagsAndAttributes)    throws WindowsException;</code></pre><ul><li><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4></li></ul><pre><code>public int read(ByteBuffer dst) throws IOException {    ensureOpen();    if (!readable)        throw new NonReadableChannelException();    synchronized (positionLock) {        int n = 0;        int ti = -1;        try {            begin();            ti = threads.add();            if (!isOpen())                return 0;            do {                n = IOUtil.read(fd, dst, -1, nd);            } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());            return IOStatus.normalize(n);        } finally {            threads.remove(ti);            end(n &gt; 0);            assert IOStatus.check(n);        }    }}</code></pre><ul><li><p>IOUtil.read</p></li><li><p>static int read(FileDescriptor fd, ByteBuffer dst, long position,</p><pre><code>          NativeDispatcher nd) IOException {</code></pre><p>  if (dst.isReadOnly())</p><pre><code>  throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</code></pre><p>  if (dst instanceof DirectBuffer)</p><pre><code>  return readIntoNativeBuffer(fd, dst, position, nd);</code></pre><p>  // Substitute a native buffer<br>  ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());<br>  try {</p><pre><code>  int n = readIntoNativeBuffer(fd, bb, position, nd);  bb.flip();  if (n &gt; 0)      dst.put(bb);  return n;</code></pre><p>  } finally {</p><pre><code>  Util.offerFirstTemporaryDirectBuffer(bb);</code></pre><p>  }<br>}</p></li><li><p>通过上述实现可以看出，基于channel的文件数据读取步骤如下： </p></li><li><p>1、申请一块和缓存同大小的DirectByteBuffer bb。 </p></li><li><p>2、读取数据到缓存bb，底层由NativeDispatcher的read实现。 </p></li><li><p>3、把bb的数据读取到dst（用户定义的缓存，在jvm中分配内存)。 </p></li><li><p>read方法导致数据复制了两次。</p></li></ul><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><pre><code>public int write(ByteBuffer src) throws IOException {    ensureOpen();    if (!writable)        throw new NonWritableChannelException();    synchronized (positionLock) {        int n = 0;        int ti = -1;        try {            begin();            ti = threads.add();            if (!isOpen())                return 0;            do {                n = IOUtil.write(fd, src, -1, nd);            } while ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());            return IOStatus.normalize(n);        } finally {            threads.remove(ti);            end(n &gt; 0);            assert IOStatus.check(n);        }    }}</code></pre><ul><li>IOUtil.write</li><li>static int write(FileDescriptor fd, ByteBuffer src, long position,<pre><code>           NativeDispatcher nd) throws IOException {</code></pre>  if (src instanceof DirectBuffer)<pre><code>  return writeFromNativeBuffer(fd, src, position, nd);</code></pre>  // Substitute a native buffer<br>  int pos = src.position();<br>  int lim = src.limit();<br>  assert (pos &lt;= lim);<br>  int rem = (pos &lt;= lim ? lim - pos : 0);<br>  ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);<br>  try {<pre><code>  bb.put(src);  bb.flip();  // Do not update src until we see how many bytes were written  src.position(pos);  int n = writeFromNativeBuffer(fd, bb, position, nd);  if (n &gt; 0) {      // now update src      src.position(pos + n);  }  return n;</code></pre>  } finally {<pre><code>  Util.offerFirstTemporaryDirectBuffer(bb);</code></pre>  }<br>}</li><li>基于channel的文件数据写入步骤如下： </li><li>1、申请一块DirectByteBuffer，bb大小为byteBuffer中的limit - position。 </li><li>2、复制byteBuffer中的数据到bb中。 </li><li>3、把数据从bb中写入到文件，底层由NativeDispatcher的write实现，具体如下：</li></ul><pre><code>private static int writeFromNativeBuffer(FileDescriptor fd,                                         ByteBuffer bb, long position, NativeDispatcher nd)        throws IOException {    int pos = bb.position();    int lim = bb.limit();    assert (pos &lt;= lim);    int rem = (pos &lt;= lim ? lim - pos : 0);    int written = 0;    if (rem == 0)        return 0;    if (position != -1) {        written = nd.pwrite(fd,                ((DirectBuffer) bb).address() + pos,                rem, position);    } else {        written = nd.write(fd, ((DirectBuffer) bb).address() + pos, rem);    }    if (written &gt; 0)        bb.position(pos + written);    return written;}</code></pre><ul><li>write方法也导致了数据复制了两次。</li><li></li></ul><h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><ul><li>它的实现类是ServerSocketChannelImpl，同样是闭源的。<h4 id="open-1"><a href="#open-1" class="headerlink" title="open"></a>open</h4></li></ul><pre><code>public static ServerSocketChannel open() throws IOException {    return SelectorProvider.provider().openServerSocketChannel();}</code></pre><ul><li><p>SelectorProvider.provider()方法在windows平台下返回的是SelectorProvider 的实现类 WindowsSelectorProvider类的实例。</p></li><li><p>WindowsSelectorProvider类的直接父类为SelectorProviderImpl；</p></li><li><p>SelectorProviderImpl 的直接父类是 SelectorProvider。</p></li><li><p>SelectorProviderImpl# openServerSocketChannel</p></li></ul><pre><code>public ServerSocketChannel openServerSocketChannel() throws IOException {    return new ServerSocketChannelImpl(this);}</code></pre><pre><code>- ServerSocketChannelImpl(SelectorProvider var1) throws IOException {super(var1);this.fd = Net.serverSocket(true);this.fdVal = IOUtil.fdVal(this.fd);this.state = 0;</code></pre><p>}<br>    - super(var1)实际上是父类的构造方法</p><ul><li><p>protected AbstractSelectableChannel(SelectorProvider provider) {<br>  this.provider = provider;<br>}</p></li><li><p>Net#serverSocket 创建一个FileDescriptor</p></li><li><p>static FileDescriptor serverSocket(boolean stream) {<br>  return IOUtil.newFD(socket0(isIPv6Available(), stream, true, fastLoopback));<br>}</p></li><li></li></ul><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><pre><code>public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {    synchronized (lock) {        if (!isOpen())            throw new ClosedChannelException();        if (isBound())            throw new AlreadyBoundException();        InetSocketAddress isa = (local == null) ? new InetSocketAddress(0) :            Net.checkAddress(local);        SecurityManager sm = System.getSecurityManager();        if (sm != null)            sm.checkListen(isa.getPort());        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());        Net.bind(fd, isa.getAddress(), isa.getPort());        Net.listen(fd, backlog &lt; 1 ? 50 : backlog);        synchronized (stateLock) {            localAddress = Net.localAddress(fd);        }    }    return this;}</code></pre><ul><li><h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4></li><li><p>Selector是通过Selector.open方法获得的。</p></li><li><p>将这个通道channel注册到指定的selector中，返回一个SelectionKey对象实例。</p></li><li><p>register这个方法在实现代码上的逻辑有以下四点：</p></li><li><p>1、首先检查通道channel是否是打开的，如果不是打开的，则抛异常，如果是打开的，则进行 2。</p></li><li><p>2、检查指定的interest集合是否是有效的。如果没效，则抛异常。否则进行 3。这里要特别强调一下：对于ServerSocketChannel仅仅支持”新的连接”，因此interest集合ops满足ops&amp;~sectionKey.OP_ACCEPT!=0,即对于ServerSocketChannel注册到Selector中时的事件只能包括SelectionKey.OP_ACCEPT。</p></li><li><p>3、对通道进行了阻塞模式的检查，如果不是阻塞模式，则抛异常，否则进行4.</p></li><li><p>4、得到当前通道在指定Selector上的SelectionKey，假设结果用k表示。下面对k是否为null有不同的处理。如果k不为null，则说明此通道channel已经在Selector上注册过了，则直接将指定的ops添加进SelectionKey中即可。如果k为null,则说明此通道还没有在Selector上注册，则需要先进行注册，然后为其对应的SelectionKey设置给定值ops。</p></li><li><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p></li></ul><pre><code>public final SelectionKey register(Selector sel, int ops,                                   Object att)    throws ClosedChannelException{    synchronized (regLock) {        if (!isOpen())            throw new ClosedChannelException();        if ((ops &amp; ~validOps()) != 0)            throw new IllegalArgumentException();        if (blocking)            throw new IllegalBlockingModeException();</code></pre><ul><li>// 得到当前通道在指定Selector上的SelectionKey（复合事件)</li><li>SelectionKey k = findKey(sel);</li><li>如果k不为null，则说明此通道已经在Selector上注册过了，则直接将指定的ops添加进SelectionKey中即可。</li><li>如果k为null,则说明此通道还没有在Selector上注册，则需要先进行注册，然后添加SelectionKey。 <pre><code>  if (k != null) {      k.interestOps(ops);      k.attach(att);  }  if (k == null) {      // New registration      synchronized (keyLock) {          if (!isOpen())              throw new ClosedChannelException();          k = ((AbstractSelector)sel).register(this, ops, att);          addKey(k);      }  }  return k;</code></pre>  }</li></ul><pre><code>private SelectionKey findKey(Selector sel) {    synchronized (keyLock) {        if (keys == null)            return null;        for (int i = 0; i &lt; keys.length; i++)            if ((keys[i] != null) &amp;&amp; (keys[i].selector() == sel))                return keys[i];        return null;    }}</code></pre><ul><li><h3 id="Selector（如何实现Channel多路复用"><a href="#Selector（如何实现Channel多路复用" class="headerlink" title="Selector（如何实现Channel多路复用)"></a>Selector（如何实现Channel多路复用)</h3></li><li><p>SocketChannel、ServerSocketChannel和Selector的实例初始化都通过SelectorProvider类实现，其中Selector是整个NIO Socket的核心实现。</p></li><li><p>SelectorProvider在windows和linux下有不同的实现，provider方法会返回对应的实现。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4></li></ul><p>1.- final class WindowsSelectorImpl extends SelectorImpl<br>2.- {<br>3.</p><pre><code>    private final int INIT_CAP = 8;//选择key集合，key包装集合初始化容量  </code></pre><p>4.</p><pre><code>    private static final int MAX_SELECTABLE_FDS = 1024;//最大选择key数量  </code></pre><p>5.</p><pre><code>    private SelectionKeyImpl channelArray[];//选择器关联通道集合  </code></pre><p>6.</p><pre><code>    private PollArrayWrapper pollWrapper;//存放所有文件描述对象（选择key，唤醒管道的source与sink通道)的集合  </code></pre><p>7.</p><pre><code>    private int totalChannels;//注册到选择的通道数量  </code></pre><p>8.</p><pre><code>    private int threadsCount;//选择线程数  </code></pre><p>9.</p><pre><code>    private final List threads = new ArrayList();//选择操作线程集合  </code></pre><p>10.</p><pre><code>    private final Pipe wakeupPipe = Pipe.open();//唤醒等待选择操作的管道  </code></pre><p>11.</p><pre><code>    private final int wakeupSourceFd;//唤醒管道源通道文件描述  </code></pre><p>12.</p><pre><code>    private final int wakeupSinkFd;//唤醒管道sink通道文件描述  </code></pre><p>13.</p><pre><code>    private Object closeLock;//选择器关闭同步锁  </code></pre><p>14.</p><pre><code>    private final FdMap fdMap = new FdMap();//存放选择key文件描述与选择key映射关系的Map  </code></pre><p>15.</p><pre><code>    private final SubSelector subSelector = new SubSelector();//子选择器  </code></pre><p>16.</p><pre><code>    private long timeout;//超时时间，具体什么意思，现在还没明白，在后面在看  </code></pre><p>17.</p><pre><code>    private final Object interruptLock = new Object();//中断同步锁，在唤醒选择操作线程时，用于同步  </code></pre><p>18.</p><pre><code>    private volatile boolean interruptTriggered;//是否唤醒等待选择操的线程  </code></pre><p>19.</p><pre><code>    private final StartLock startLock = new StartLock();//选择操作开始锁  </code></pre><p>20.</p><pre><code>    private final FinishLock finishLock = new FinishLock();//选择操作结束锁  </code></pre><p>21.</p><pre><code>    private long updateCount;//更新数量，具体什么意思，现在还没明白，在后面在看  </code></pre><p>22.-     static final boolean $assertionsDisabled = !sun/nio/ch/WindowsSelectorImpl.desiredAssertionStatus();<br>23.-     static<br>24.-     {<br>25.-         //加载nio，net资源库<br>26.-         Util.load();<br>27.-     }<br>28.- }  </p><h4 id="open-2"><a href="#open-2" class="headerlink" title="open"></a>open</h4><pre><code>public static Selector open() throws IOException {    return SelectorProvider.provider().openSelector();}</code></pre><ul><li>WindowsSelectorProvider#openSelector</li></ul><pre><code>public AbstractSelector openSelector() throws IOException {    return new WindowsSelectorImpl(this);}</code></pre><ul><li><p>初始化一个wakeupPipe</p><ul><li>WindowsSelectorImpl(SelectorProvider var1) throws IOException {<br>super(var1);<br>this.wakeupSourceFd = ((SelChImpl)this.wakeupPipe.source()).getFDVal();<br>SinkChannelImpl var2 = (SinkChannelImpl)this.wakeupPipe.sink();<br>var2.sc.socket().setTcpNoDelay(true);<br>this.wakeupSinkFd = var2.getFDVal();<br>this.pollWrapper.addWakeupSocket(this.wakeupSourceFd, 0);<br>}</li></ul></li><li><p>SelectorImpl#register</p></li><li><p>第一个参数是ServerSocketChannel，第二个参数是复合事件，第三个是附件。</p></li><li><p>1、以当前channel和selector为参数，初始化SelectionKeyImpl 对象selectionKeyImpl ，并添加附件attachment。 </p></li><li><p>2、如果当前channel的数量totalChannels等于SelectionKeyImpl数组大小，对SelectionKeyImpl数组和pollWrapper进行扩容操作。 </p></li><li><p>3、如果totalChannels % MAXSELECTABLEFDS == 0，则多开一个线程处理selector。 </p></li><li><p>4、pollWrapper.addEntry将把selectionKeyImpl中的socket句柄添加到对应的pollfd。 </p></li><li><p>5、k.interestOps(ops)方法最终也会把event添加到对应的pollfd。</p></li><li><p>所以，不管serverSocketChannel，还是socketChannel，在selector注册的事件，最终都保存在pollArray中。</p></li></ul><pre><code>protected final SelectionKey register(AbstractSelectableChannel ch,                                      int ops,                                      Object attachment) {    if (!(ch instanceof SelChImpl))        throw new IllegalSelectorException();    SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this);    k.attach(attachment);    synchronized (publicKeys) {        implRegister(k);    }    k.interestOps(ops);    return k;}</code></pre><ul><li>WindowsSelectorImpl#implRegister</li><li>protected void implRegister(SelectionKeyImpl ski) {<br>  synchronized (closeLock) {<pre><code>  if (pollWrapper == null)      throw new ClosedSelectorException();  growIfNeeded();  channelArray[totalChannels] = ski;  ski.setIndex(totalChannels);  fdMap.put(ski);  keys.add(ski);  pollWrapper.addEntry(totalChannels, ski);  totalChannels++;</code></pre>  }<br>}</li></ul><h4 id="select（返回有事件发生的SelectionKey数量"><a href="#select（返回有事件发生的SelectionKey数量" class="headerlink" title="select（返回有事件发生的SelectionKey数量)"></a>select（返回有事件发生的SelectionKey数量)</h4><ul><li>var1是timeout时间，无参数的版本对应的timeout为0.</li><li>select(long timeout)和select()一样，除了最长会阻塞timeout毫秒(参数)。</li><li>这个方法并不能提供精确时间的保证，和当执行wait(long timeout)方法时并不能保证会延时timeout道理一样。</li><li>这里的timeout说明如下：</li><li>如果 timeout为正，则select(long timeout)在等待有通道被选择时至多会阻塞timeout毫秒</li><li>如果timeout为零，则永远阻塞直到有至少一个通道准备就绪。</li><li>timeout不能为负数。</li></ul><pre><code>public int select(long timeout)    throws IOException{    if (timeout &lt; 0)        throw new IllegalArgumentException(&quot;Negative timeout&quot;);    return lockAndDoSelect((timeout == 0) ? -1 : timeout);}</code></pre><ul><li>selectNow（非阻塞版本)</li></ul><pre><code>public int selectNow() throws IOException {    return this.lockAndDoSelect(0L);}</code></pre><pre><code>private int lockAndDoSelect(long timeout) throws IOException {    synchronized (this) {        if (!isOpen())            throw new ClosedSelectorException();        synchronized (publicKeys) {            synchronized (publicSelectedKeys) {                return doSelect(timeout);            }        }    }}</code></pre><ul><li><p>WindowsSelectorImpl#doSelect</p></li><li><p>protected int doSelect(long timeout) throws IOException {<br>  if (channelArray == null)</p><pre><code>  throw new ClosedSelectorException();</code></pre><p>  this.timeout = timeout; // set selector timeout<br>  processDeregisterQueue();<br>  if (interruptTriggered) {</p><pre><code>  resetWakeupSocket();  return 0;</code></pre><p>  }<br>  // Calculate number of helper threads needed for poll. If necessary<br>  // threads are created here and start waiting on startLock<br>  adjustThreadsCount();<br>  finishLock.reset(); // reset finishLock<br>  // Wakeup helper threads, waiting on startLock, so they start polling.<br>  // Redundant threads will exit here after wakeup.<br>  startLock.startThreads();<br>  // do polling in the main thread. Main thread is responsible for<br>  // first MAX_SELECTABLE_FDS entries in pollArray.<br>  try {</p><pre><code>  begin();  try {      subSelector.poll();  } catch (IOException e) {      finishLock.setException(e); // Save this exception  }  // Main thread is out of poll(). Wakeup others and wait for them  if (threads.size() &gt; 0)      finishLock.waitForHelperThreads();} finally {    end();}</code></pre><p>  // Done with poll(). Set wakeupSocket to nonsignaled  for the next run.<br>  finishLock.checkForException();<br>  processDeregisterQueue();<br>  int updated = updateSelectedKeys();<br>  // Done with poll(). Set wakeupSocket to nonsignaled  for the next run.<br>  resetWakeupSocket();<br>  return updated;<br>}</p></li><li><p>其中 subSelector.poll() 是select的核心，由native函数poll0实现，readFds、writeFds 和exceptFds数组用来保存底层select的结果，数组的第一个位置都是存放发生事件的socket的总数，其余位置存放发生事件的socket句柄fd。</p></li></ul><pre><code>private int poll() throws IOException {    return this.poll0(WindowsSelectorImpl.this.pollWrapper.pollArrayAddress, Math.min(WindowsSelectorImpl.this.totalChannels, 1024), this.readFds, this.writeFds, this.exceptFds, WindowsSelectorImpl.this.timeout);}</code></pre><pre><code>private native int poll0(long pollAddress, int numfds,     int[] readFds, int[] writeFds, int[] exceptFds, long timeout);</code></pre><ul><li>在src/windows/native/sun/nio/ch/WindowsSelectorImpl.c中找到了该方法的实现</li><li>#define FD_SETSIZE 1024</li></ul><pre><code>Java_sun_nio_ch_WindowsSelectorImpl_00024SubSelector_poll0(JNIEnv *env, jobject this,                                   jlong pollAddress, jint numfds,                                   jintArray returnReadFds, jintArray returnWriteFds,                                   jintArray returnExceptFds, jlong timeout){    DWORD result = 0;    pollfd *fds = (pollfd *) pollAddress;    int i;    FD_SET readfds, writefds, exceptfds;    struct timeval timevalue, *tv;    static struct timeval zerotime = {0, 0};    int read_count = 0, write_count = 0, except_count = 0;#ifdef _WIN64    int resultbuf[FD_SETSIZE + 1];#endif    if (timeout == 0) {        tv = &amp;zerotime;    } else if (timeout &lt; 0) {        tv = NULL;    } else {        tv = &amp;timevalue;        tv-&gt;tv_sec =  (long)(timeout / 1000);        tv-&gt;tv_usec = (long)((timeout % 1000) * 1000);    }    /* Set FD_SET structures required for select */    for (i = 0; i &lt; numfds; i++) {        if (fds[i].events &amp; POLLIN) {           readfds.fd_array[read_count] = fds[i].fd;           read_count++;        }        if (fds[i].events &amp; (POLLOUT | POLLCONN))        {           writefds.fd_array[write_count] = fds[i].fd;           write_count++;        }        exceptfds.fd_array[except_count] = fds[i].fd;        except_count++;    }    readfds.fd_count = read_count;    writefds.fd_count = write_count;    exceptfds.fd_count = except_count;    /* Call select */    if ((result = select(0 , &amp;readfds, &amp;writefds, &amp;exceptfds, tv))                                                             == SOCKET_ERROR) {        /* Bad error - this should not happen frequently */        /* Iterate over sockets and call select() on each separately */        FD_SET errreadfds, errwritefds, errexceptfds;        readfds.fd_count = 0;        writefds.fd_count = 0;        exceptfds.fd_count = 0;        for (i = 0; i &lt; numfds; i++) {            /* prepare select structures for the i-th socket */            errreadfds.fd_count = 0;            errwritefds.fd_count = 0;            if (fds[i].events &amp; POLLIN) {               errreadfds.fd_array[0] = fds[i].fd;               errreadfds.fd_count = 1;            }            if (fds[i].events &amp; (POLLOUT | POLLCONN))            {                errwritefds.fd_array[0] = fds[i].fd;                errwritefds.fd_count = 1;            }            errexceptfds.fd_array[0] = fds[i].fd;            errexceptfds.fd_count = 1;            /* call select on the i-th socket */            if (select(0, &amp;errreadfds, &amp;errwritefds, &amp;errexceptfds, &amp;zerotime)                                                             == SOCKET_ERROR) {                /* This socket causes an error. Add it to exceptfds set */                exceptfds.fd_array[exceptfds.fd_count] = fds[i].fd;                exceptfds.fd_count++;            } else {                /* This socket does not cause an error. Process result */                if (errreadfds.fd_count == 1) {                    readfds.fd_array[readfds.fd_count] = fds[i].fd;                    readfds.fd_count++;                }                if (errwritefds.fd_count == 1) {                    writefds.fd_array[writefds.fd_count] = fds[i].fd;                    writefds.fd_count++;                }                if (errexceptfds.fd_count == 1) {                    exceptfds.fd_array[exceptfds.fd_count] = fds[i].fd;                    exceptfds.fd_count++;                }            }        }    }    /* Return selected sockets. */    /* Each Java array consists of sockets count followed by sockets list */#ifdef _WIN64    resultbuf[0] = readfds.fd_count;    for (i = 0; i &lt; (int)readfds.fd_count; i++) {        resultbuf[i + 1] = (int)readfds.fd_array[i];    }    (*env)-&gt;SetIntArrayRegion(env, returnReadFds, 0,                              readfds.fd_count + 1, resultbuf);    resultbuf[0] = writefds.fd_count;    for (i = 0; i &lt; (int)writefds.fd_count; i++) {        resultbuf[i + 1] = (int)writefds.fd_array[i];    }    (*env)-&gt;SetIntArrayRegion(env, returnWriteFds, 0,                              writefds.fd_count + 1, resultbuf);    resultbuf[0] = exceptfds.fd_count;    for (i = 0; i &lt; (int)exceptfds.fd_count; i++) {        resultbuf[i + 1] = (int)exceptfds.fd_array[i];    }    (*env)-&gt;SetIntArrayRegion(env, returnExceptFds, 0,                              exceptfds.fd_count + 1, resultbuf);#else    (*env)-&gt;SetIntArrayRegion(env, returnReadFds, 0,                              readfds.fd_count + 1, (jint *)&amp;readfds);    (*env)-&gt;SetIntArrayRegion(env, returnWriteFds, 0,                              writefds.fd_count + 1, (jint *)&amp;writefds);    (*env)-&gt;SetIntArrayRegion(env, returnExceptFds, 0,                              exceptfds.fd_count + 1, (jint *)&amp;exceptfds);#endif    return 0;}</code></pre><ul><li><p>执行 selector.select() ，poll0函数把指向socket句柄和事件的内存地址传给底层函数。 </p></li><li><p>1、如果之前没有发生事件，程序就阻塞在select处，当然不会一直阻塞，因为epoll在timeout时间内如果没有事件，也会返回； </p></li><li><p>2、一旦有对应的事件发生，poll0方法就会返回； </p></li><li><p>3、processDeregisterQueue方法会清理那些已经cancelled的SelectionKey； </p></li><li><p>4、updateSelectedKeys方法统计有事件发生的SelectionKey数量，并把符合条件发生事件的SelectionKey添加到selectedKeys哈希表中，提供给后续使用。</p></li><li><p>如何判断是否有事件发生?（native)</p></li><li><p>poll0()会监听pollWrapper中的FD有没有数据进出，这会造成IO阻塞，直到有数据读写事件发生。 </p></li><li><p>比如，由于pollWrapper中保存的也有ServerSocketChannel的FD，所以只要ClientSocket发一份数据到ServerSocket,那么poll0()就会返回； </p></li><li><p>又由于pollWrapper中保存的也有pipe的write端的FD，所以只要pipe的write端向FD发一份数据，也会造成poll0()返回； </p></li><li><p>如果这两种情况都没有发生，那么poll0()就一直阻塞，也就是selector.select()会一直阻塞；如果有任何一种情况发生，那么selector.select()就会返回。</p></li><li><p>在早期的JDK1.4和1.5 update10版本之前，Selector基于select/poll模型实现，是基于IO复用技术的非阻塞IO，不是异步IO。在JDK1.5 update10和linux core2.6以上版本，sun优化了Selctor的实现，底层使用epoll替换了select/poll。</p></li><li><p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。</p></li><li><p>在Windows下是IOCP</p></li></ul><h4 id="WindowsSelectorImpl-wakeup"><a href="#WindowsSelectorImpl-wakeup" class="headerlink" title="WindowsSelectorImpl.wakeup()"></a>WindowsSelectorImpl.wakeup()</h4><pre><code>public Selector wakeup() {    synchronized (interruptLock) {        if (!interruptTriggered) {            setWakeupSocket();            interruptTriggered = true;        }    }    return this;}</code></pre><pre><code>private void setWakeupSocket() {    setWakeupSocket0(wakeupSinkFd);}</code></pre><pre><code>private native void setWakeupSocket0(int wakeupSinkFd);</code></pre><pre><code>Java_sun_nio_ch_WindowsSelectorImpl_setWakeupSocket0(JNIEnv *env, jclass this,                                                jint scoutFd){    /* Write one byte into the pipe */    const char byte = 1;    send(scoutFd, &amp;byte, 1, 0);}</code></pre><ul><li><p>这里完成了向最开始建立的pipe的sink端写入了一个字节，source文件描述符就会处于就绪状态，poll方法会返回，从而导致select方法返回。（原来自己建立一个socket链着自己另外一个socket就是为了这个目的)</p></li><li></li></ul><h2 id="Java-AIO-源码"><a href="#Java-AIO-源码" class="headerlink" title="Java AIO 源码"></a>Java AIO 源码</h2><h3 id="AsynchronousFileChannle（AIO-基于CompletionHandler回调"><a href="#AsynchronousFileChannle（AIO-基于CompletionHandler回调" class="headerlink" title="AsynchronousFileChannle（AIO,基于CompletionHandler回调)"></a>AsynchronousFileChannle（AIO,基于CompletionHandler回调)</h3><ul><li><p>在Java 7中，AsynchronousFileChannel被添加到Java NIO。AsynchronousFileChannel使读取数据，并异步地将数据写入文件成为可能。</p><h4 id="open-3"><a href="#open-3" class="headerlink" title="open"></a>open</h4></li><li><p>Path path = Paths.get(“data/test.xml”);</p></li><li><p>AsynchronousFileChannel fileChannel =</p></li><li><p>AsynchronousFileChannel.open(path, StandardOpenOption.READ);</p></li></ul><pre><code>public static AsynchronousFileChannel open(Path file,                                           Set&lt;? extends OpenOption&gt; options,                                           ExecutorService executor,                                           FileAttribute&lt;?&gt;... attrs)    throws IOException{    FileSystemProvider provider = file.getFileSystem().provider();    return provider.newAsynchronousFileChannel(file, options, executor, attrs);}</code></pre><ul><li><p>WindowsChannelFactory#newAsynchronousFileChannel</p></li><li><p>static AsynchronousFileChannel newAsynchronousFileChannel(String pathForWindows,</p><pre><code>                                                    String pathToCheck,                                                    Set&lt;? extends OpenOption&gt; options,                                                    long pSecurityDescriptor,                                                    ThreadPool pool)</code></pre><p>  throws IOException<br>{<br>  Flags flags = Flags.toFlags(options);</p><p>  // Overlapped I/O required<br>  flags.overlapped = true;</p><p>  // default is reading<br>  if (!flags.read &amp;&amp; !flags.write) {</p><pre><code>  flags.read = true;</code></pre><p>  }</p><p>  // validation<br>  if (flags.append)</p><pre><code>  throw new UnsupportedOperationException(&quot;APPEND not allowed&quot;);</code></pre><p>  // open file for overlapped I/O<br>  FileDescriptor fdObj;<br>  try {</p><pre><code>  fdObj = open(pathForWindows, pathToCheck, flags, pSecurityDescriptor);</code></pre><p>  } catch (WindowsException x) {</p><pre><code>  x.rethrowAsIOException(pathForWindows);  return null;</code></pre><p>  }</p><p>  // create the AsynchronousFileChannel<br>  try {</p><pre><code>  return WindowsAsynchronousFileChannelImpl.open(fdObj, flags.read, flags.write, pool);</code></pre><p>  } catch (IOException x) {</p><pre><code>  // IOException is thrown if the file handle cannot be associated  // with the completion port. All we can do is close the file.  long handle = fdAccess.getHandle(fdObj);  CloseHandle(handle);  throw x;</code></pre><p>  }</p></li><li><p>WindowsAsynchronousFileChannelImpl#open</p></li></ul><pre><code>public static AsynchronousFileChannel open(FileDescriptor fdo,                                           boolean reading,                                           boolean writing,                                           ThreadPool pool)    throws IOException{    Iocp iocp;    boolean isDefaultIocp;    if (pool == null) {        iocp = DefaultIocpHolder.defaultIocp;        isDefaultIocp = true;    } else {        iocp = new Iocp(null, pool).start();        isDefaultIocp = false;    }    try {        return new            WindowsAsynchronousFileChannelImpl(fdo, reading, writing, iocp, isDefaultIocp);    } catch (IOException x) {        // error binding to port so need to close it (if created for this channel)        if (!isDefaultIocp)            iocp.implClose();        throw x;    }}</code></pre><h4 id="read-1"><a href="#read-1" class="headerlink" title="read"></a>read</h4><h4 id="write-1"><a href="#write-1" class="headerlink" title="write"></a>write</h4><ul><li></li><li></li></ul><h2 id="Netty-NIO"><a href="#Netty-NIO" class="headerlink" title="Netty NIO"></a>Netty NIO</h2><ul><li><p>基于这个语境，Netty目前的版本是没有把IO操作交过操作系统处理的，所以是属于同步的。如果别人说Netty是异步非阻塞，如果要深究，那真要看看Netty新的版本是否把IO操作交过操作系统处理，或者看看有否使用JDK1.7中的AIO API，否则他们说的异步其实是指客户端程序调用Netty的IO操作API“不停顿等待”。</p></li><li><p>很多人所讲的异步其实指的是编程模型上的异步（即回调)，而非应用程序的异步。</p><h2 id="NIO与Epoll"><a href="#NIO与Epoll" class="headerlink" title="NIO与Epoll"></a>NIO与Epoll</h2></li><li><p>Linux2.6之后支持epoll</p></li><li><p>windows支持select而不支持epoll</p></li><li><p>不同系统下nio的实现是不一样的，包括Sunos linux 和windows</p></li><li><p>select的复杂度为O(N)</p></li><li><p>select有最大fd限制，默认为1024</p></li><li><p>修改sys/select.h可以改变select的fd数量限制</p><ul><li>epoll的事件模型，无fd数量限制，复杂度O(1),不需要遍历fd</li></ul></li><li></li></ul><h1 id="1-17-动态代理"><a href="#1-17-动态代理" class="headerlink" title="1.17 动态代理"></a>1.17 动态代理</h1><ul><li><p>静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。</p></li><li><p>动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p></li><li><p>JDK动态代理是由Java内部的反射机制+动态生成字节码来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题)。还有一点必须注意：JDK动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，JDK动态代理不能应用。由此可以看出，JDK动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p></li><li><p>前者必须基于接口，后者不需要接口，是基于继承的，但是不能代理final类和final方法；</p></li><li><p>JDK采用反射机制调用委托类的方法，CGLIB采用类似索引的方式直接调用委托类方法；</p></li><li><p>前者效率略低于后者效率，CGLIB效率略高（不是一定的)</p><h2 id="JDK动态代理-使用"><a href="#JDK动态代理-使用" class="headerlink" title="JDK动态代理 使用"></a>JDK动态代理 使用</h2></li><li><p>Proxy类（代理类)的设计用到代理模式的设计思想，Proxy类对象实现了代理目标的所有接口，并代替目标对象进行实际的操作。代理的目的是在目标对象方法的基础上作增强，这种增强的本质通常就是对目标对象的方法进行拦截。所以，Proxy应该包括一个方法拦截器，来指示当拦截到方法调用时作何种处理。InvocationHandler就是拦截器的接口。</p></li><li><p>Proxy (代理) 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 </p></li><li><p>动态代理类（代理类)是一个实现在创建类时在运行时指定的接口列表的类 ，代理接口是代理类实现的一个接口。代理实例 是代理类的一个实例。 </p></li><li><p>每个代理实例都有一个关联的调用处理程序对象，它可以实现接口 InvocationHandler。（拦截器)</p></li><li><p>在Java中怎样实现动态代理呢？</p></li><li><p>第一步，我们要有一个接口，还要有一个接口的实现类，而这个实现类呢就是我们要代理的对象， 所谓代理呢也就是在调用实现类的方法时，可以在方法执行前后做额外的工作。 </p></li><li><p>第二步，我们要自己写一个在代理类的方法要执行时，能够做额外工作的类（拦截器)，而这个类必须继承InvocationHandler接口， 为什么要继承它呢？因为代理类的实例在调用实现类的方法的时候，不会调用真正的实现类的这个方法， 而是转而调用这个类的invoke方法（继承时必须实现的方法)，在这个方法中你可以调用真正的实现类的这个方法。</p></li></ul><h2 id="JDK动态代理-原理"><a href="#JDK动态代理-原理" class="headerlink" title="JDK动态代理 原理"></a>JDK动态代理 原理</h2><ul><li>Proxy#newProxyInstance</li><li>会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。</li></ul><pre><code>public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h)    throws IllegalArgumentException{    Objects.requireNonNull(h);    final Class&lt;?&gt;[] intfs = interfaces.clone();    final SecurityManager sm = System.getSecurityManager();    if (sm != null) {        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    }    /*     * Look up or generate the designated proxy class.     */</code></pre><pre><code>// 生成代理类的class    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    /*     * Invoke its constructor with the designated invocation handler.     */    try {        if (sm != null) {            checkNewProxyPermission(Reflection.getCallerClass(), cl);        }        // 获取代理对象的构造方法（也就是$Proxy0(InvocationHandler h))           final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);        final InvocationHandler ih = h;        if (!Modifier.isPublic(cl.getModifiers())) {            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {                public Void run() {                    cons.setAccessible(true);                    return null;                }            });        }</code></pre><ul><li>// 生成代理类的实例并把InvocationHandlerImpl的实例传给它的构造方法  <pre><code>  return cons.newInstance(new Object[]{h});</code></pre>  } catch (IllegalAccessException|InstantiationException e) {<pre><code>  throw new InternalError(e.toString(), e);</code></pre>  } catch (InvocationTargetException e) {<pre><code>  Throwable t = e.getCause();  if (t instanceof RuntimeException) {      throw (RuntimeException) t;  } else {      throw new InternalError(t.toString(), t);  }</code></pre>  } catch (NoSuchMethodException e) {<pre><code>  throw new InternalError(e.toString(), e);</code></pre>  }<br>}</li></ul><h3 id="1-getProxyClass0（生成代理类的class"><a href="#1-getProxyClass0（生成代理类的class" class="headerlink" title="1)getProxyClass0（生成代理类的class)"></a>1)getProxyClass0（生成代理类的class)</h3><ul><li>最终生成是通过ProxyGenerator的generateProxyClass方法实现的。</li></ul><pre><code>private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,                                       Class&lt;?&gt;... interfaces) {    if (interfaces.length &gt; 65535) {        throw new IllegalArgumentException(&quot;interface limit exceeded&quot;);    }    // If the proxy class defined by the given loader implementing    // the given interfaces exists, this will simply return the cached copy;    // otherwise, it will create the proxy class via the ProxyClassFactory    return proxyClassCache.get(loader, interfaces);}</code></pre><pre><code>private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());</code></pre><ul><li><ul><li>@param <K> type of keys</li><li>@param <P> type of parameters</li><li>@param <V> type of values</li><li>/<br>final class WeakCache&lt;K, P, V&gt; {}</li></ul></li></ul><pre><code>public V get(K key, P parameter) {    Objects.requireNonNull(parameter);    expungeStaleEntries();    Object cacheKey = CacheKey.valueOf(key, refQueue);    // lazily install the 2nd level valuesMap for the particular cacheKey    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);    if (valuesMap == null) {        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap            = map.putIfAbsent(cacheKey,                              valuesMap = new ConcurrentHashMap&lt;&gt;());        if (oldValuesMap != null) {            valuesMap = oldValuesMap;        }    }    // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that    // subKey from valuesMap    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);    Factory factory = null;    while (true) {        if (supplier != null) {            // supplier might be a Factory or a CacheValue&lt;V&gt; instance</code></pre><ul><li><p>// supplier是Factory,这个类定义在WeakCache的内部。</p><pre><code>      V value = supplier.get();      if (value != null) {          return value;      }  }  // else no supplier in cache  // or a supplier that returned null (could be a cleared CacheValue  // or a Factory that wasn&#39;t successful in installing the CacheValue)  // lazily construct a Factory  if (factory == null) {      factory = new Factory(key, parameter, subKey, valuesMap);  }  if (supplier == null) {      supplier = valuesMap.putIfAbsent(subKey, factory);      if (supplier == null) {          // successfully installed Factory          supplier = factory;      }      // else retry with winning supplier  } else {      if (valuesMap.replace(subKey, supplier, factory)) {          // successfully replaced          // cleared CacheEntry / unsuccessful Factory          // with our Factory          supplier = factory;      } else {          // retry with current supplier          supplier = valuesMap.get(subKey);      }  }</code></pre><p>  }<br>}</p></li><li><p>Factory</p></li></ul><pre><code>private final class Factory implements Supplier&lt;V&gt; {    private final K key;    private final P parameter;    private final Object subKey;    private final ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;    Factory(K key, P parameter, Object subKey,            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) {        this.key = key;        this.parameter = parameter;        this.subKey = subKey;        this.valuesMap = valuesMap;    }    @Override    public synchronized V get() { // serialize access        // re-check        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);        if (supplier != this) {            // something changed while we were waiting:            // might be that we were replaced by a CacheValue            // or were removed because of failure -&gt;            // return null to signal WeakCache.get() to retry            // the loop            return null;        }        // else still us (supplier == this)        // create new value</code></pre><ul><li><p>// 创建新的class</p><pre><code>  V value = null;  try {      value = Objects.requireNonNull(valueFactory.apply(key, parameter));  } finally {      if (value == null) { // remove us on failure          valuesMap.remove(subKey, this);      }  }  // the only path to reach here is with non-null value  assert value != null;  // wrap value with CacheValue (WeakReference)  CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value);  // try replacing us with CacheValue (this should always succeed)  if (valuesMap.replace(subKey, this, cacheValue)) {      // put also in reverseMap      reverseMap.put(cacheValue, Boolean.TRUE);  } else {      throw new AssertionError(&quot;Should not reach here&quot;);  }  // successfully replaced us with new CacheValue -&gt; return the value  // wrapped by it  return value;</code></pre><p>  }<br>}</p></li></ul><pre><code>private static final class ProxyClassFactory    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;{    // prefix for all proxy class names    private static final String proxyClassNamePrefix = &quot;$Proxy&quot;;    // next number to use for generation of unique proxy class names    private static final AtomicLong nextUniqueNumber = new AtomicLong();    @Override    public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) {        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length);        for (Class&lt;?&gt; intf : interfaces) {            /*             * Verify that the class loader resolves the name of this             * interface to the same Class object.             */            Class&lt;?&gt; interfaceClass = null;            try {                interfaceClass = Class.forName(intf.getName(), false, loader);            } catch (ClassNotFoundException e) {            }            if (interfaceClass != intf) {                throw new IllegalArgumentException(                    intf + &quot; is not visible from class loader&quot;);            }            /*             * Verify that the Class object actually represents an             * interface.             */            if (!interfaceClass.isInterface()) {                throw new IllegalArgumentException(                    interfaceClass.getName() + &quot; is not an interface&quot;);            }            /*             * Verify that this interface is not a duplicate.             */            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {                throw new IllegalArgumentException(                    &quot;repeated interface: &quot; + interfaceClass.getName());            }        }        String proxyPkg = null;     // package to define proxy class in        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;        /*         * Record the package of a non-public proxy interface so that the         * proxy class will be defined in the same package.  Verify that         * all non-public proxy interfaces are in the same package.         */        for (Class&lt;?&gt; intf : interfaces) {            int flags = intf.getModifiers();            if (!Modifier.isPublic(flags)) {                accessFlags = Modifier.FINAL;                String name = intf.getName();                int n = name.lastIndexOf(&#39;.&#39;);                String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1));                if (proxyPkg == null) {                    proxyPkg = pkg;                } else if (!pkg.equals(proxyPkg)) {                    throw new IllegalArgumentException(                        &quot;non-public interfaces from different packages&quot;);                }            }        }        if (proxyPkg == null) {            // if no non-public proxy interfaces, use com.sun.proxy package            proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;;        }        /*         * Choose a name for the proxy class to generate.         */        long num = nextUniqueNumber.getAndIncrement();        String proxyName = proxyPkg + proxyClassNamePrefix + num;        /*         * Generate the specified proxy class.         */        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(            proxyName, interfaces, accessFlags);        try {            return defineClass0(loader, proxyName,                                proxyClassFile, 0, proxyClassFile.length);        } catch (ClassFormatError e) {            /*             * A ClassFormatError here means that (barring bugs in the             * proxy class generation code) there was some other             * invalid aspect of the arguments supplied to the proxy             * class creation (such as virtual machine limitations             * exceeded).             */            throw new IllegalArgumentException(e.toString());        }    }}</code></pre><ul><li>重点！</li></ul><pre><code>/** * Generate a proxy class given a name and a list of proxy interfaces. * * @param name        the class name of the proxy class * @param interfaces  proxy interfaces * @param accessFlags access flags of the proxy class*/public static byte[] generateProxyClass(final String name,                                        Class&lt;?&gt;[] interfaces,                                        int accessFlags){    ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);    final byte[] classFile = gen.generateClassFile();    if (saveGeneratedFiles) {        java.security.AccessController.doPrivileged(        new java.security.PrivilegedAction&lt;Void&gt;() {            public Void run() {                try {                    int i = name.lastIndexOf(&#39;.&#39;);                    Path path;                    if (i &gt; 0) {                        Path dir = Paths.get(name.substring(0, i).replace(&#39;.&#39;, File.separatorChar));                        Files.createDirectories(dir);                        path = dir.resolve(name.substring(i+1, name.length()) + &quot;.class&quot;);                    } else {                        path = Paths.get(name + &quot;.class&quot;);                    }                    Files.write(path, classFile);                    return null;                } catch (IOException e) {                    throw new InternalError(                        &quot;I/O exception saving generated file: &quot; + e);                }            }        });    }    return classFile;}</code></pre><ul><li>ProxyGenerator#generateClassFIle</li></ul><pre><code>/** * Generate a class file for the proxy class.  This method drives the * class file generation process. */private byte[] generateClassFile() {    /* ============================================================     * Step 1: Assemble ProxyMethod objects for all methods to     * generate proxy dispatching code for.     */    /*     * Record that proxy methods are needed for the hashCode, equals,     * and toString methods of java.lang.Object.  This is done before     * the methods from the proxy interfaces so that the methods from     * java.lang.Object take precedence over duplicate methods in the     * proxy interfaces.     */    addProxyMethod(hashCodeMethod, Object.class);    addProxyMethod(equalsMethod, Object.class);    addProxyMethod(toStringMethod, Object.class);    /*     * Now record all of the methods from the proxy interfaces, giving     * earlier interfaces precedence over later ones with duplicate     * methods.     */    for (Class&lt;?&gt; intf : interfaces) {        for (Method m : intf.getMethods()) {            addProxyMethod(m, intf);        }    }    /*     * For each set of proxy methods with the same signature,     * verify that the methods&#39; return types are compatible.     */    for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {        checkReturnTypes(sigmethods);    }    /* ============================================================     * Step 2: Assemble FieldInfo and MethodInfo structs for all of     * fields and methods in the class we are generating.     */    try {        methods.add(generateConstructor());        for (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) {            for (ProxyMethod pm : sigmethods) {                // add static field for method&#39;s Method object                fields.add(new FieldInfo(pm.methodFieldName,                    &quot;Ljava/lang/reflect/Method;&quot;,                     ACC_PRIVATE | ACC_STATIC));                // generate code for proxy method and add it                methods.add(pm.generateMethod());            }        }        methods.add(generateStaticInitializer());    } catch (IOException e) {        throw new InternalError(&quot;unexpected I/O Exception&quot;, e);    }    if (methods.size() &gt; 65535) {        throw new IllegalArgumentException(&quot;method limit exceeded&quot;);    }    if (fields.size() &gt; 65535) {        throw new IllegalArgumentException(&quot;field limit exceeded&quot;);    }    /* ============================================================     * Step 3: Write the final class file.     */    /*     * Make sure that constant pool indexes are reserved for the     * following items before starting to write the final class file.     */    cp.getClass(dotToSlash(className));    cp.getClass(superclassName);    for (Class&lt;?&gt; intf: interfaces) {        cp.getClass(dotToSlash(intf.getName()));    }    /*     * Disallow new constant pool additions beyond this point, since     * we are about to write the final constant pool table.     */    cp.setReadOnly();    ByteArrayOutputStream bout = new ByteArrayOutputStream();    DataOutputStream dout = new DataOutputStream(bout);    try {        /*         * Write all the items of the &quot;ClassFile&quot; structure.         * See JVMS section 4.1.         */                                    // u4 magic;        dout.writeInt(0xCAFEBABE);                                    // u2 minor_version;        dout.writeShort(CLASSFILE_MINOR_VERSION);                                    // u2 major_version;        dout.writeShort(CLASSFILE_MAJOR_VERSION);        cp.write(dout);             // (write constant pool)                                    // u2 access_flags;        dout.writeShort(accessFlags);                                    // u2 this_class;        dout.writeShort(cp.getClass(dotToSlash(className)));                                    // u2 super_class;        dout.writeShort(cp.getClass(superclassName));                                    // u2 interfaces_count;        dout.writeShort(interfaces.length);                                    // u2 interfaces[interfaces_count];        for (Class&lt;?&gt; intf : interfaces) {            dout.writeShort(cp.getClass(                dotToSlash(intf.getName())));        }                                    // u2 fields_count;        dout.writeShort(fields.size());                                    // field_info fields[fields_count];        for (FieldInfo f : fields) {            f.write(dout);        }                                    // u2 methods_count;        dout.writeShort(methods.size());                                    // method_info methods[methods_count];        for (MethodInfo m : methods) {            m.write(dout);        }                                     // u2 attributes_count;        dout.writeShort(0); // (no ClassFile attributes for proxy classes)    } catch (IOException e) {        throw new InternalError(&quot;unexpected I/O Exception&quot;, e);    }    return bout.toByteArray();}</code></pre><h3 id="2-getConstructor（获取代理类的构造方法"><a href="#2-getConstructor（获取代理类的构造方法" class="headerlink" title="2)getConstructor（获取代理类的构造方法)"></a>2)getConstructor（获取代理类的构造方法)</h3><h3 id="3-newInstance（初始化代理对象"><a href="#3-newInstance（初始化代理对象" class="headerlink" title="3)newInstance（初始化代理对象)"></a>3)newInstance（初始化代理对象)</h3><h2 id="CGLIB动态代理-使用"><a href="#CGLIB动态代理-使用" class="headerlink" title="CGLIB动态代理 使用"></a>CGLIB动态代理 使用</h2><ul><li><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。</p></li><li><p>CGLIB的核心类：</p></li><li><p>net.sf.cglib.proxy.Enhancer – 主要的增强类</p></li><li><p>net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现</p></li><li><p>net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用：</p></li><li><p>Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。</p></li><li><p>net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback)类型，它经常被基于代理的AOP用来实现拦截（intercept)方法的调用。这个接口只定义了一个方法</p></li></ul><pre><code>public Object intercept(Object object, java.lang.reflect.Method method,</code></pre><ul><li>Object[] args, MethodProxy proxy) throws Throwable;</li><li>第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。</li></ul><pre><code>public class CglibProxy implements MethodInterceptor {  </code></pre><ul><li>@Override  </li></ul><pre><code>    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {  </code></pre><ul><li>System.out.println(“++++++before “ + methodProxy.getSuperName() + “++++++”);  </li><li>System.out.println(method.getName());  </li><li>Object o1 = methodProxy.invokeSuper(o, args);  </li><li>System.out.println(“++++++before “ + methodProxy.getSuperName() + “++++++”);  </li><li>return o1;  </li><li>}  </li><li>}</li></ul><pre><code>public class Main {  </code></pre><pre><code>    public static void main(String[] args) {  </code></pre><ul><li>CglibProxy cglibProxy = new CglibProxy();  </li><li></li><li>Enhancer enhancer = new Enhancer();  </li><li>enhancer.setSuperclass(UserServiceImpl.class);  </li><li>enhancer.setCallback(cglibProxy);  </li><li></li><li>UserService o = (UserService)enhancer.create();  <ul><li>o.getName(1);  </li><li>o.getAge(1);  </li></ul></li><li>}  </li><li>}</li><li>我们通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。</li><li>注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理。</li><li>既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型。</li><li>final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。</li></ul><h2 id="CGLIB动态代理-原理"><a href="#CGLIB动态代理-原理" class="headerlink" title="CGLIB动态代理 原理"></a>CGLIB动态代理 原理</h2><ul><li><p>1、生成代理类Class的二进制字节码（基于ASM)； </p></li><li><p>2、通过 Class.forName加载二进制字节码，生成Class对象； </p></li><li><p>3、通过反射机制获取实例构造，并初始化代理类对象。</p></li><li><p>调用委托类的方法是使用invokeSuper</p></li></ul><pre><code>public Object invokeSuper(Object obj, Object[] args) throws Throwable {    try {        init();        FastClassInfo fci = fastClassInfo;        return fci.f2.invoke(fci.i2, obj, args);    } catch (InvocationTargetException e) {        throw e.getTargetException();    }}</code></pre><pre><code>private static class FastClassInfo{    FastClass f1;    FastClass f2;    int i1;    int i2;}</code></pre><ul><li>f1指向委托类对象，f2指向代理类对象</li><li>i1是被代理的方法在对象中的索引位置</li><li>i2是CGLIB$被代理的方法$0在对象中的索引位置<h3 id="FastClass实现机制"><a href="#FastClass实现机制" class="headerlink" title="FastClass实现机制"></a>FastClass实现机制</h3></li><li>FastClass其实就是对Class对象进行特殊处理，提出下标概念index，通过索引保存方法的引用信息，将原先的反射调用，转化为方法的直接调用，从而体现所谓的fast。</li></ul><ul><li>在FastTest中有两个方法， getIndex中对Test类的每个方法根据hash建立索引， invoke根据指定的索引，直接调用目标方法，避免了反射调用。</li></ul><ul><li><h1 id="1-18-反射"><a href="#1-18-反射" class="headerlink" title="1.18 反射"></a>1.18 反射</h1></li><li><p>Java的动态性体现在：反射机制、动态执行脚本语言、动态操作字节码</p></li><li><p>反射：在运行时加载、探知、使用编译时未知的类。</p></li><li><p>Class.forName使用的类加载器是调用者的类加载器</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2></li><li><p>表示Java中的类型（class、interface、enum、annotation、primitive type、void)本身。</p></li></ul><ul><li><p>一个类被加载之后，JVM会创建一个对应该类的Class对象，类的整个结构信息会放在相应的Class对象中。</p></li><li><p>这个Class对象就像一个镜子一样，从中可以看到类的所有信息。</p></li><li><p>反射的核心就是Class</p></li><li><p>如果多次执行forName等加载类的方法，类只会被加载一次；一个类只会形成一个Class对象，无论执行多少次加载类的方法，获得的Class都是一样的。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul><li><p>反射带来灵活性的同时，也有降低程序执行效率的弊端</p></li><li><p>setAccessible方法不仅可以标记某些私有的属性方法为可访问的属性方法，并且可以提高程序的执行效率</p></li><li><p>实际上是启用和禁用访问安全检查的开关。如果做检查就会降低效率；关闭检查就可以提高效率。</p></li><li><p>反射调用方法比直接调用要慢大约30倍，如果跳过安全检查的话比直接调用要慢大约7倍</p></li><li><p>开启和不开启安全检查对于反射而言可能会差4倍的执行效率。</p></li><li><p>为什么慢?</p><ul><li>1)验证等防御代码过于繁琐，这一步本来在link阶段，现在却在计算时进行验证</li><li>2)产生很多临时对象，造成GC与计算时间消耗</li><li>3)由于缺少上下文，丢失了很多运行时的优化，比如JIT(它可以看作JVM的重要评测标准之一)</li></ul></li><li><p>当然，现代JVM也不是非常慢了，它能够对反射代码进行缓存以及通过方法计数器同样实现JIT优化，所以反射不一定慢。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2></li><li><p>反射在Java中可以直接调用，不过最终调用的仍是native方法，以下为主流反射操作的实现。</p></li></ul><h3 id="Class-forName的实现"><a href="#Class-forName的实现" class="headerlink" title="Class.forName的实现"></a>Class.forName的实现</h3><ul><li>Class.forName可以通过包名寻找Class对象，比如Class.forName(“java.lang.String”)。</li><li>在JDK的源码实现中，可以发现最终调用的是native方法forName0()，它在JVM中调用的实际是FindClassFromCaller()，原理与ClassLoader的流程一样。</li></ul><pre><code>public static Class&lt;?&gt; forName(String className)            throws ClassNotFoundException {    Class&lt;?&gt; caller = Reflection.getCallerClass();    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);}</code></pre><pre><code>private static native Class&lt;?&gt; forName0(String name, boolean initialize,                                        ClassLoader loader,                                        Class&lt;?&gt; caller)    throws ClassNotFoundException;</code></pre><pre><code>Java_java_lang_Class_forName0(JNIEnv *env, jclass this, jstring classname,                              jboolean initialize, jobject loader, jclass caller){    char *clname;    jclass cls = 0;    char buf[128];    jsize len;    jsize unicode_len;    if (classname == NULL) {        JNU_ThrowNullPointerException(env, 0);        return 0;    }    len = (*env)-&gt;GetStringUTFLength(env, classname);    unicode_len = (*env)-&gt;GetStringLength(env, classname);    if (len &gt;= (jsize)sizeof(buf)) {        clname = malloc(len + 1);        if (clname == NULL) {            JNU_ThrowOutOfMemoryError(env, NULL);            return NULL;        }    } else {        clname = buf;    }    (*env)-&gt;GetStringUTFRegion(env, classname, 0, unicode_len, clname);    if (VerifyFixClassname(clname) == JNI_TRUE) {        /* slashes present in clname, use name b4 translation for exception */        (*env)-&gt;GetStringUTFRegion(env, classname, 0, unicode_len, clname);        JNU_ThrowClassNotFoundException(env, clname);        goto done;    }    if (!VerifyClassname(clname, JNI_TRUE)) {  /* expects slashed name */        JNU_ThrowClassNotFoundException(env, clname);        goto done;    }    cls = JVM_FindClassFromCaller(env, clname, initialize, loader, caller); done:    if (clname != buf) {        free(clname);    }    return cls;}</code></pre><ul><li><p>JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv <em>env, const char </em>name,</p><pre><code>                                   jboolean init, jclass from))</code></pre><p>JVMWrapper2(“JVM_FindClassFromClass %s”, name);<br>if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {<br>  // It’s impossible to create this class;  the name cannot fit<br>  // into the constant pool.<br>  THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), name);<br>}<br>TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);<br>oop from_class_oop = JNIHandles::resolve(from);<br>Klass* from_class = (from_class_oop == NULL)</p><pre><code>                     ? (Klass*)NULL                     : java_lang_Class::as_Klass(from_class_oop);</code></pre><p>oop class_loader = NULL;<br>oop protection_domain = NULL;<br>if (from_class != NULL) {<br>  class_loader = from_class-&gt;class_loader();<br>  protection_domain = from_class-&gt;protection_domain();<br>}<br>Handle h_loader(THREAD, class_loader);<br>Handle h_prot  (THREAD, protection_domain);<br>jclass result = find_class_from_class_loader(env, h_name, init, h_loader,</p><pre><code>                                         h_prot, true, thread);</code></pre><p>if (TraceClassResolution &amp;&amp; result != NULL) {<br>  // this function is generally only used for class loading during verification.<br>  ResourceMark rm;<br>  oop from_mirror = JNIHandles::resolve_non_null(from);<br>  Klass<em> from_class = java_lang_Class::as_Klass(from_mirror);<br>  const char </em> from_name = from_class-&gt;external_name();</p><p>  oop mirror = JNIHandles::resolve_non_null(result);<br>  Klass<em> to_class = java_lang_Class::as_Klass(mirror);<br>  const char </em> to = to_class-&gt;external_name();<br>  tty-&gt;print(“RESOLVE %s %s (verification)\n”, from_name, to);<br>}</p><p>return result;<br>JVM_END</p></li><li></li></ul><h3 id="getDeclaredFields的实现"><a href="#getDeclaredFields的实现" class="headerlink" title="getDeclaredFields的实现"></a>getDeclaredFields的实现</h3><ul><li><p>在JDK源码中，可以知道class.getDeclaredFields()方法实际调用的是native方法getDeclaredFields0()，它在JVM主要实现步骤如下：</p><ul><li>1)根据Class结构体信息，获取field_count与fields[]字段，这个字段早已在load过程中被放入了</li><li>2)根据field_count的大小分配内存、创建数组</li><li>3)将数组进行forEach循环，通过fields[]中的信息依次创建Object对象</li><li>4)返回数组指针</li></ul></li><li><p>主要慢在如下方面：</p></li><li><p>创建、计算、分配数组对象</p></li><li><p>对字段进行循环赋值</p></li></ul><pre><code>public Field[] getDeclaredFields() throws SecurityException {    checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);    return copyFields(privateGetDeclaredFields(false));}</code></pre><pre><code>private Field[] privateGetDeclaredFields(boolean publicOnly) {    checkInitted();    Field[] res;    ReflectionData&lt;T&gt; rd = reflectionData();    if (rd != null) {        res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;        if (res != null) return res;    }    // No cached value available; request value from VM    res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));    if (rd != null) {        if (publicOnly) {            rd.declaredPublicFields = res;        } else {            rd.declaredFields = res;        }    }    return res;}</code></pre><pre><code>private static Field[] copyFields(Field[] arg) {    Field[] out = new Field[arg.length];    ReflectionFactory fact = getReflectionFactory();    for (int i = 0; i &lt; arg.length; i++) {        out[i] = fact.copyField(arg[i]);    }    return out;}</code></pre><ul><li><h3 id="Method-invoke的实现"><a href="#Method-invoke的实现" class="headerlink" title="Method.invoke的实现"></a>Method.invoke的实现</h3></li><li><p>以下为无同步、无异常的情况下调用的步骤</p><ul><li>1)创建Frame</li><li>2)如果对象flag为native，交给native_handler进行处理</li><li>3)在frame中执行java代码</li><li>4)弹出Frame</li><li>5)返回执行结果的指针</li></ul></li><li><p>主要慢在如下方面：</p></li><li><p>需要完全执行ByteCode而缺少JIT等优化</p></li><li><p>检查参数非常多，这些本来可以在编译器或者加载时完成</p></li></ul><pre><code>public Object invoke(Object obj, Object... args)    throws IllegalAccessException, IllegalArgumentException,       InvocationTargetException{    if (!override) {        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        }    }    MethodAccessor ma = methodAccessor;             // read volatile    if (ma == null) {        ma = acquireMethodAccessor();    }    return ma.invoke(obj, args);}</code></pre><ul><li>NativeMethodAccessorImpl#invoke</li></ul><pre><code>public Object invoke(Object obj, Object[] args)    throws IllegalArgumentException, InvocationTargetException{    // We can&#39;t inflate methods belonging to vm-anonymous classes because    // that kind of class can&#39;t be referred to by name, hence can&#39;t be    // found from the generated bytecode.    if (++numInvocations &gt; ReflectionFactory.inflationThreshold()            &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {        MethodAccessorImpl acc = (MethodAccessorImpl)            new MethodAccessorGenerator().                generateMethod(method.getDeclaringClass(),                               method.getName(),                               method.getParameterTypes(),                               method.getReturnType(),                               method.getExceptionTypes(),                               method.getModifiers());        parent.setDelegate(acc);    }    return invoke0(method, obj, args);}</code></pre><pre><code>private static native Object invoke0(Method m, Object obj, Object[] args);</code></pre><ul><li>Java_sun_reflect_NativeMethodAccessorImpl_invoke0<br>(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)<br>{<br>  return JVM_InvokeMethod(env, m, obj, args);<br>}</li></ul><ul><li><p>JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))<br>JVMWrapper(“JVM_InvokeMethod”);<br>Handle method_handle;<br>if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {<br>  method_handle = Handle(THREAD, JNIHandles::resolve(method));<br>  Handle receiver(THREAD, JNIHandles::resolve(obj));<br>  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));<br>  oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);<br>  jobject res = JNIHandles::make_local(env, result);<br>  if (JvmtiExport::should_post_vm_object_alloc()) {</p><pre><code>oop ret_type = java_lang_reflect_Method::return_type(method_handle());assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);if (java_lang_Class::is_primitive(ret_type)) {  // Only for primitive type vm allocates memory for java object.  // See box() method.  JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);}</code></pre><p>  }<br>  return res;<br>} else {<br>  THROW_0(vmSymbols::java_lang_StackOverflowError());<br>}<br>JVM_END</p></li><li></li></ul><h3 id="class-newInstance的实现"><a href="#class-newInstance的实现" class="headerlink" title="class.newInstance的实现"></a>class.newInstance的实现</h3><pre><code>- 1)检测权限、预分配空间大小等参数- 2)创建Object对象，并分配空间- 3)通过Method.invoke调用构造函数(&lt;init&gt;())- 4)返回Object指针</code></pre><ul><li><p>主要慢在如下方面：</p></li><li><p>参数检查不能优化或者遗漏</p></li><li><p><init>()的查表</p></li><li><p>Method.invoke本身耗时</p></li></ul><pre><code>public T newInstance()    throws InstantiationException, IllegalAccessException{    if (System.getSecurityManager() != null) {        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);    }    // NOTE: the following code may not be strictly correct under    // the current Java memory model.    // Constructor lookup    if (cachedConstructor == null) {        if (this == Class.class) {            throw new IllegalAccessException(                &quot;Can not call newInstance() on the Class for java.lang.Class&quot;            );        }        try {            Class&lt;?&gt;[] empty = {};            final Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);            // Disable accessibility checks on the constructor            // since we have to do the security check here anyway            // (the stack depth is wrong for the Constructor&#39;s            // security check to work)            java.security.AccessController.doPrivileged(                new java.security.PrivilegedAction&lt;Void&gt;() {                    public Void run() {                            c.setAccessible(true);                            return null;                        }                    });            cachedConstructor = c;        } catch (NoSuchMethodException e) {            throw (InstantiationException)                new InstantiationException(getName()).initCause(e);        }    }    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;    // Security check (same as in java.lang.reflect.Constructor)    int modifiers = tmpConstructor.getModifiers();    if (!Reflection.quickCheckMemberAccess(this, modifiers)) {        Class&lt;?&gt; caller = Reflection.getCallerClass();        if (newInstanceCallerCache != caller) {            Reflection.ensureMemberAccess(caller, this, null, modifiers);            newInstanceCallerCache = caller;        }    }    // Run constructor    try {        return tmpConstructor.newInstance((Object[])null);    } catch (InvocationTargetException e) {        Unsafe.getUnsafe().throwException(e.getTargetException());        // Not reached        return null;    }}</code></pre><ul><li><h1 id="1-19-XML"><a href="#1-19-XML" class="headerlink" title="1.19 XML"></a>1.19 XML</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2></li><li><p>OM是用与平台和语言无关的方式表示XML文档的官方W3C标准。DOM是以层次结构组织的节点或信息片断的集合。这个层次结构允许开发人员在树中寻找特定信息。分析该结构通常需要加载整个文档和构造层次结构，然后才能做任何工作。由于它是基于信息层次的，因而DOM被认为是基于树或基于对象的。</p></li><li><p>优点</p></li><li><p>①允许应用程序对数据和结构做出更改。</p></li><li><p>②访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据。</p></li><li><p>缺点</p></li><li><p>①通常需要加载整个XML文档来构造层次结构，消耗资源大。</p></li><li><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2></li><li><p>SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。这对于大型文档来说是个巨大的优点。事实上，应用程序甚至不必解析整个文档；它可以在某个条件得到满足时停止解析。一般来说，SAX还比它的替代者DOM快许多。</p></li><li><p>优点</p></li><li><p>①不需要等待所有数据都被处理，分析就能立即开始。</p></li><li><p>②只在读取数据时检查数据，不需要保存在内存中。</p></li><li><p>③可以在某个条件得到满足时停止解析，不必解析整个文档。</p></li><li><p>④效率和性能较高，能解析大于系统内存的文档。</p></li><li><p>缺点</p></li><li><p>①需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等)，文档越复杂程序就越复杂。</p></li><li><p>②单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。</p></li><li><p>JDOM</p></li><li><p>DOM4J</p></li><li></li></ul><h1 id="1-20-Java8"><a href="#1-20-Java8" class="headerlink" title="1.20 Java8"></a>1.20 Java8</h1><h2 id="Lambda表达式-amp-函数式接口-amp-方法引用-amp-Stream-API"><a href="#Lambda表达式-amp-函数式接口-amp-方法引用-amp-Stream-API" class="headerlink" title="Lambda表达式&amp;函数式接口&amp;方法引用&amp;Stream API"></a>Lambda表达式&amp;函数式接口&amp;方法引用&amp;Stream API</h2><ul><li><p>Java8 stream迭代的优势和区别；lambda表达式？为什么要引入它</p><ul><li>1)流（高级Iterator)：对集合对象进行各种非常便利、高效的聚合操作（aggregate operation)，或者大批量数据操作 (bulk data operation)，隐式迭代等，代码简洁</li><li>2)方便地实现并行（并行流)，比如实现MapReduce</li><li>3)Lamdba：简化匿名内部类的实现，代码更加紧凑</li><li>4)方法引用：方法引用是lambda表达式的另一种表达方式</li></ul></li><li><p>对象::实例方法</p></li><li><p>类::静态方法</p></li><li><p>类::实例方法名</p></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ul><li>Optional仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查。<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><ul><li>1)实现异步API（将任务交给另一线程完成，该线程与调用方异步，通过回调函数或阻塞的方式取得任务结果)</li><li>2)将批量同步操作转为异步操作（并行流/CompletableFuture)</li><li>3)多个异步任务合并<h2 id="时间日期API"><a href="#时间日期API" class="headerlink" title="时间日期API"></a>时间日期API</h2></li></ul></li><li>新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒)、duration（持续时间)和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训)，如果某个实例需要修改，则返回一个新的对象。</li></ul><h2 id="接口中的默认方法与静态方法"><a href="#接口中的默认方法与静态方法" class="headerlink" title="接口中的默认方法与静态方法"></a>接口中的默认方法与静态方法</h2><ul><li>默认方法使得开发者可以在不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</li><li>默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。</li></ul><ul><li><h1 id="1-21-Java9"><a href="#1-21-Java9" class="headerlink" title="1.21 Java9"></a>1.21 Java9</h1><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2></li><li><p>提供了类似于OSGI框架的功能，模块之间存在相互的依赖关系，可以导出一个公共的API，并且隐藏实现的细节，Java提供该功能的主要的动机在于，减少内存的开销，在JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第一步整个jar都会被JVM加载到内存当中去，模块化可以根据模块的需要加载程序运行需要的class。</p></li><li><p>在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。使得JDK可以在更小的设备中使用。采用模块化系统的应用程序只需要这些应用程序所需的那部分JDK模块，而非是整个JDK框架了。</p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2></li><li><p>Java 9的版本中引入了一个新的package:java.net.http，里面提供了对Http访问很好的支持，不仅支持Http1.1而且还支持HTTP/2，以及WebSocket，据说性能特别好。</p><h2 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h2></li><li><p>java9引入了jshell这个交互性工具，让Java也可以像脚本语言一样来运行，可以从控制台启动 jshell ，在 jshell 中直接输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。</p></li><li><p>除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。</p><h2 id="不可变集合工厂方法"><a href="#不可变集合工厂方法" class="headerlink" title="不可变集合工厂方法"></a>不可变集合工厂方法</h2></li><li><p>Java 9增加了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合。</p><h2 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h2></li><li><p>Java 8 为我们提供了接口的默认方法和静态方法，接口也可以包含行为，而不仅仅是方法定义。</p></li><li><p>默认方法和静态方法可以共享接口中的私有方法，因此避免了代码冗余，这也使代码更加清晰。如果私有方法是静态的，那这个方法就属于这个接口的。并且没有静态的私有方法只能被在接口中的实例调用。</p><h2 id="多版本兼容-JAR"><a href="#多版本兼容-JAR" class="headerlink" title="多版本兼容 JAR"></a>多版本兼容 JAR</h2><ul><li>当一个新版本的 Java 出现的时候，你的库用户要花费很长时间才会切换到这个新的版本。这就意味着库要去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</li></ul></li></ul><h2 id="统一-JVM-日志"><a href="#统一-JVM-日志" class="headerlink" title="统一 JVM 日志"></a>统一 JVM 日志</h2><ul><li>Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项-Xlog 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。<h2 id="垃圾收集机制"><a href="#垃圾收集机制" class="headerlink" title="垃圾收集机制"></a>垃圾收集机制</h2></li><li>Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时把G1设为默认的垃圾回收器实现。替代了之前默认使用的Parallel GC，对于这个改变，evens的评论是酱紫的：这项变更是很重要的，因为相对于Parallel来说，G1会在应用线程上做更多的事情，而Parallel几乎没有在应用线程上做任何事情，它基本上完全依赖GC线程完成所有的内存管理。这意味着切换到G1将会为应用线程带来额外的工作，从而直接影响到应用的性能</li></ul><h2 id="I-O-流新特性"><a href="#I-O-流新特性" class="headerlink" title="I/O 流新特性"></a>I/O 流新特性</h2><ul><li><p>java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。<br>- readAllBytes：读取 InputStream 中的所有剩余字节。<br>- readNBytes： 从 InputStream 中读取指定数量的字节到数组中。<br>- transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。</p></li><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="//post/README.html"/>
      <url>//post/README.html</url>
      
        <content type="html"><![CDATA[<ul><li>本github最初的版本是一份word文档，目前只是把word刚刚搬上来了，但是有些图片、排版还没来得急整理，看起来可能还是有点困难</li><li>所以可以先关注一下我的公众号，在我的公众号后台回复 <strong>888</strong> 获取这个github仓库的PDF版本，左侧有导航栏，方便大家阅读。</li></ul><blockquote><p>github必须md格式才能看得舒服些，花了很多时间找word转md的工具，找了几款不太好用，于是自己手动把word改成md格式，后来发现有些重复性工作可以写个程序处理，就写了个程序，把word中的标题、代码都变成md格式，虽然能处理不少，但是还是需要人工校对，还有图片需要上传，真的超级费事，要搞吐了。。。各位也别抱怨我的github格式不好了，毕竟也还没完全处理完，体谅一下~</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g0fkgcpy8cj30760760t7.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合面试题及答案</title>
      <link href="//post/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html"/>
      <url>//post/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-HashMap"><a href="#一-HashMap" class="headerlink" title="一. HashMap"></a>一. HashMap</h1><p><a href="https://blog.csdn.net/jiary5201314/article/details/51439982" target="_blank" rel="noopener">https://blog.csdn.net/jiary5201314/article/details/51439982</a></p><h2 id="1-hashMap的原理"><a href="#1-hashMap的原理" class="headerlink" title="1. hashMap的原理"></a>1. hashMap的原理</h2><p>hashmap  是数组和链表的结合体，数组每个元素存的是链表的头结点 往 hashmap<br>里面放键值对的时候先得到 key 的 hashcode，然后重新计算 hashcode， （让 1 分布均匀因为如果分布不均匀，低位全是 0，则后来计算数组下标的时候会 冲突），然后与 length-1 按位与，计算数组出数组下标 如果该下标对应的链表为空，则直接把键值对作为链表头结点，如果不为空，则 遍历链表看是否有 key 值相同的，有就把 value 替换， 没有就把该对象最为链表的第 一个节点，原有的节点最为他的后续节点</p><h2 id="2-hashcode的计算"><a href="#2-hashcode的计算" class="headerlink" title="2. hashcode的计算"></a>2. hashcode的计算</h2><p><a href="https://www.zhihu.com/question/20733617/answer/111577937" target="_blank" rel="noopener">https://www.zhihu.com/question/20733617/answer/111577937</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/62893086" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/62893086</a><br>Key.hashcode是key的自带的hascode函数是一个int值32位</p><p>hashmap jdk1.8 中 hashmap 重计算 hashcode 方法改动： 高 16 位异或低 16 位</p><blockquote><p>return (key == null) ? 0 : h = key.hashCode() ^ (h &gt;&gt;&gt; 16);<br>首先确认：当 length 总是 2 的n 次方时， h &amp; (length - 1)    等价于    hash 对length 取模 ， 但是&amp;比%具有更高的效率；<br>Jdk1.7 之前：h &amp; (length - 1);//第三步，取模运算</p></blockquote><p> <img src="https://github.com/gzc426/picts/raw/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191002175517.jpg" alt="img"> </p><h2 id="3-hashMap参数以及扩容机制"><a href="#3-hashMap参数以及扩容机制" class="headerlink" title="3. hashMap参数以及扩容机制"></a>3. hashMap参数以及扩容机制</h2><p>初始容量 16，达到阀值扩容，阀值等于最大容量*负载因子，扩容每次 2 倍，总是 2 的n 次方<br>扩容机制：<br>使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里，Java1.重新计算每个元素在数组中的位置。Java1.8 中不是重新计算，而是用了一种更巧妙的方式。</p><h2 id="4-get-方法"><a href="#4-get-方法" class="headerlink" title="4. get()方法"></a>4. get()方法</h2><p><strong>整个过程都不需要加锁</strong><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%871.png" alt=""></p><h2 id="5-put-方法"><a href="#5-put-方法" class="headerlink" title="5. put()方法"></a>5. put()方法</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%872.png" alt=""><br>这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现</p><h2 id="6-HashMap问题-jdk1-8优化"><a href="#6-HashMap问题-jdk1-8优化" class="headerlink" title="6. HashMap问题 jdk1.8优化"></a>6. HashMap问题 jdk1.8优化</h2><p>（1）HashMap如果有很多相同key，后面的链很长的话，你会怎么优化？或者你会用什么数据结构来存储？针对HashMap中某个Entry链太长，查找的时间复杂度可能达到O(n)，怎么优化？<br>Java8 做的改变：</p><ul><li>HashMap 是数组+链表+红黑树（JDK1.8 增加了红黑树部分），当链表长度&gt;=8 时转化为红黑树<br>在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。</li><li>java8  中对 hashmap 扩容不是重新计算所有元素在数组的位置，而是我们使用的是 2 次幂的扩展(指长度扩为原来 2  倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash， 只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引+oldCap”。</li></ul><h2 id="7-一些面试题"><a href="#7-一些面试题" class="headerlink" title="7. 一些面试题"></a>7. 一些面试题</h2><h3 id="7-1-HashMap-和-TreeMap-的区别"><a href="#7-1-HashMap-和-TreeMap-的区别" class="headerlink" title="7.1 HashMap 和 TreeMap 的区别"></a>7.1 HashMap 和 TreeMap 的区别</h3><p>Hashmap 使用的是数组+链表，treemap 是红黑树</p><h3 id="7-2-hashmap-为什么可以插入空值？"><a href="#7-2-hashmap-为什么可以插入空值？" class="headerlink" title="7.2 hashmap 为什么可以插入空值？"></a>7.2 hashmap 为什么可以插入空值？</h3><p>HashMap 中添加 key==null 的 Entry 时会调用 putForNullKey 方法直接去遍历<br>table[0]Entry 链表，寻找 e.key==null 的 Entry 或者没有找到遍历结束</p><p>如果找到了 e.key==null，就保存 null 值对应的原值 oldValue，然后覆盖原值，并返回oldValue<br>如果在 table[0]Entry 链表中没有找到就调用addEntry 方法添加一个 key 为 null 的 Entry</p><h3 id="7-3-Hashmap-为什么线程不安全：-hash-碰撞和扩容导致"><a href="#7-3-Hashmap-为什么线程不安全：-hash-碰撞和扩容导致" class="headerlink" title="7.3 Hashmap 为什么线程不安全：(hash 碰撞和扩容导致)"></a>7.3 Hashmap 为什么线程不安全：(hash 碰撞和扩容导致)</h3><ul><li>HashMap 底层是一个Entry 数组，当发生 hash 冲突的时候，hashmap 是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。假如 A 线程和B 线程同时对同一个数组位置调用 addEntry，两个线程会同时得到现在的头结点，然后 A 写入新的头结点之后，B 也写入新的头结点，那 B 的写入操作就会覆盖A 的写入操作造成A 的写入操作丢失</li><li>删除键值对的代码如上：当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去， 其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改</li><li>当多个线程同时检测到总数量超过门限值的时候就会同时调用 resize 操作，各自生成新的数组并 rehash 后赋给该map 底层的数组 table，结果最终只有最后一个线程生成的新数组被赋给 table 变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的 table 作为原始数组，这样也会有问题。<h3 id="7-4-Hashmap-碰撞严重"><a href="#7-4-Hashmap-碰撞严重" class="headerlink" title="7.4 Hashmap 碰撞严重"></a>7.4 Hashmap 碰撞严重</h3>可以自定义重写 hash——多 hash 函数<h3 id="7-4-HashMap-高并发情况下会出现什么问题？"><a href="#7-4-HashMap-高并发情况下会出现什么问题？" class="headerlink" title="7.4 HashMap 高并发情况下会出现什么问题？"></a>7.4 HashMap 高并发情况下会出现什么问题？</h3>扩容问题<h3 id="7-5-HashMap-的存放自定义类时，需要实现自定义类的什么方法？"><a href="#7-5-HashMap-的存放自定义类时，需要实现自定义类的什么方法？" class="headerlink" title="7.5 HashMap 的存放自定义类时，需要实现自定义类的什么方法？"></a>7.5 HashMap 的存放自定义类时，需要实现自定义类的什么方法？</h3>答：hashCode 和equals。通过 hash(hashCode)然后模运算（其实是与的位操作）定位在Entry 数组中的下标，然后遍历这之后的链表，通过 equals 比较有没有相同的 key，如果有直接覆盖 value，如果没有就重新创建一个 Entry。</li></ul><h3 id="7-6-Hashmap为什么线程不安全"><a href="#7-6-Hashmap为什么线程不安全" class="headerlink" title="7.6 Hashmap为什么线程不安全"></a>7.6 Hashmap为什么线程不安全</h3><p>hash碰撞和扩容导致,HashMap扩容的的时候可能会形成环形链表，造成死循环。</p><h3 id="7-7-Hashmap中的key可以为任意对象或数据类型吗？"><a href="#7-7-Hashmap中的key可以为任意对象或数据类型吗？" class="headerlink" title="7.7 Hashmap中的key可以为任意对象或数据类型吗？"></a>7.7 Hashmap中的key可以为任意对象或数据类型吗？</h3><p>可以为null但不能是可变对象,如果是可变对象的话,对象中的属性改变,则对象 HashCode也进行相应的改变,导致下次无法查找到己存在Map中的效据<br>如果可变对象在 HashMap中被用作键,时就要小心在改变对象状态的时候,不要改变它的哈希值了。我们只需要保证成员变量的改变能保证该对象的哈希值不变即可.</p><h1 id="二-CurrentHashMap"><a href="#二-CurrentHashMap" class="headerlink" title="二. CurrentHashMap"></a>二. CurrentHashMap</h1><p><a href="http://www.importnew.com/21781.html" target="_blank" rel="noopener">http://www.importnew.com/21781.html</a><br><a href="https://blog.csdn.net/dingji_ping/article/details/51005799" target="_blank" rel="noopener">https://blog.csdn.net/dingji_ping/article/details/51005799</a><br><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6842045.html</a><br><a href="http://ifeve.com/hashmap-concurrenthashmap-%E7%9B%B8%E4%BF%A1%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%B2%A1%E4%BA%BA%E8%83%BD%E9%9A%BE%E4%BD%8F%E4%BD%A0%EF%BC%81/" target="_blank" rel="noopener">http://ifeve.com/hashmap-concurrenthashmap-%E7%9B%B8%E4%BF%A1%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E6%B2%A1%E4%BA%BA%E8%83%BD%E9%9A%BE%E4%BD%8F%E4%BD%A0%EF%BC%81/</a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%873.png" alt=""><br>一个ConcurrentHashMap维护一个Segment数组，一个Segment维护一个HashEntry数组。</p><h2 id="2-JDK1-7-ConCurrentHashMap原理"><a href="#2-JDK1-7-ConCurrentHashMap原理" class="headerlink" title="2. JDK1.7 ConCurrentHashMap原理"></a>2. JDK1.7 ConCurrentHashMap原理</h2><p>其中 Segment 继承于 ReentrantLock<br>ConcurrentHashMap 使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问， 能够实现真正的并发访问。</p><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%874.png" alt=""></p><p>Segment继承了ReentrantLock，表明每个segment都可以当做一个锁。这样对每个segment中的数据需要同步操作的话都是使用每个segment容器对象自身的锁来实现。只有对全局需要改变时锁定的是所有的segment。<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%875.png" alt=""></p><h2 id="3-JDK1-7-Get"><a href="#3-JDK1-7-Get" class="headerlink" title="3. JDK1.7 Get"></a>3. JDK1.7 Get</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%876.png" alt=""></p><ul><li>CurrentHashMap是否使用了锁？？？</li></ul><p>它也没有使用锁来同步，只是判断获取的entry的value是否为null，为null时才使用加锁的方式再次去获取。 这里可以看出并没有使用锁，但是value的值为null时候才是使用了加锁！！！</p><ul><li>Get原理：<br>第一步，先判断一下 count != 0；count变量表示segment中存在entry的个数。如果为0就不用找了。假设这个时候恰好另一个线程put或者remove了这个segment中的一个entry，会不会导致两个线程看到的count值不一致呢？看一下count变量的定义： transient volatile int count;<br>它使用了volatile来修改。我们前文说过，Java5之后，JMM实现了对volatile的保证：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。所以，每次判断count变量的时候，即使恰好其他线程改变了segment也会体现出来<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%877.png" alt=""></li></ul><h3 id="3-1-在get代码的①和②之间，另一个线程新增了一个entry"><a href="#3-1-在get代码的①和②之间，另一个线程新增了一个entry" class="headerlink" title="3.1 在get代码的①和②之间，另一个线程新增了一个entry"></a>3.1 在get代码的①和②之间，另一个线程新增了一个entry</h3><p>如果另一个线程新增的这个entry又恰好是我们要get的，这事儿就比较微妙了。下图大致描述了put 一个新的entry的过程。</p><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%878.png" alt=""></p><p>因为每个HashEntry中的next也是final的，没法对链表最后一个元素增加一个后续entry所以新增一个entry的实现方式只能通过头结点来插入了。newEntry对象是通过 new HashEntry(K k , V v, HashEntry next) 来创建的。如果另一个线程刚好new 这个对象时，当前线程来get它。因为没有同步，就可能会出现当前线程得到的newEntry对象是一个没有完全构造好的对象引用。   如果在这个new的对象的后面，则完全不影响，如果刚好是这个new的对象，那么当刚好这个对象没有完全构造好，也就是说这个对象的value值为null,就出现了如下所示的代码，需要重新加锁再次读取这个值！<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%879.png" alt=""></p><h3 id="3-2-在get代码的①和②之间，另一个线程修改了一个entry的value"><a href="#3-2-在get代码的①和②之间，另一个线程修改了一个entry的value" class="headerlink" title="3.2 在get代码的①和②之间，另一个线程修改了一个entry的value"></a>3.2 在get代码的①和②之间，另一个线程修改了一个entry的value</h3><p>value是用volitale修饰的，可以保证读取时获取到的是修改后的值。</p><h3 id="3-3-在get代码的①之后，另一个线程删除了一个entry"><a href="#3-3-在get代码的①之后，另一个线程删除了一个entry" class="headerlink" title="3.3 在get代码的①之后，另一个线程删除了一个entry"></a>3.3 在get代码的①之后，另一个线程删除了一个entry</h3><p>假设我们的链表元素是：e1-&gt; e2 -&gt; e3 -&gt; e4 我们要删除 e3这个entry，因为HashEntry中next的不可变，所以我们无法直接把e2的next指向e4，而是将要删除的节点之前的节点复制一份，形成新的链表。它的实现大致如下图所示：<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8710.png" alt=""><br>如果我们get的也恰巧是e3，可能我们顺着链表刚找到e1，这时另一个线程就执行了删除e3的操作，而我们线程还会继续沿着旧的链表找到e3返回。这里没有办法实时保证了，也就是说没办法看到最新的。<br>我们第①处就判断了count变量，它保障了在 ①处能看到其他线程修改后的。①之后到②之间，如果再次发生了其他线程再删除了entry节点，就没法保证看到最新的了，这时候的get的实际上是未更新过的！！！。<br>不过这也没什么关系，即使我们返回e3的时候，它被其他线程删除了，暴漏出去的e3也不会对我们新的链表造成影响。</p><h3 id="4-JDK1-7-PUT"><a href="#4-JDK1-7-PUT" class="headerlink" title="4. JDK1.7 PUT"></a>4. JDK1.7 PUT</h3><ul><li>1.将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>2.遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li><li>3.不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li><li>4.最后会解除在 1 中所获取当前 Segment 的锁。</li><li>5.可以说是首先找到segment，确定是哪一个segment,然后在这个segment中遍历查找 key值是要查找的key值得entry,如果找到，那么就修改该key,如果没找到，那么就在头部新加一个entry.<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8711.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8712.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8713.png" alt=""><h3 id="5-JDK1-7-Remove"><a href="#5-JDK1-7-Remove" class="headerlink" title="5. JDK1.7 Remove"></a>5. JDK1.7 Remove</h3><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8714.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8715.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8716.png" alt=""><h3 id="6-JDK1-7-amp-JDK1-8-size"><a href="#6-JDK1-7-amp-JDK1-8-size" class="headerlink" title="6. JDK1.7 &amp; JDK1.8 size()"></a>6. JDK1.7 &amp; JDK1.8 size()</h3><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8720.png" alt=""><pre><code>public int size() {  long n = sumCount();  return ((n &lt; 0L) ? 0 :          (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :          (int)n);}</code></pre>volatile 保证内存可见，最大是65535.</li></ul><h3 id="5-JDK-1-8-CurrentHashMap概述"><a href="#5-JDK-1-8-CurrentHashMap概述" class="headerlink" title="5.JDK 1.8 CurrentHashMap概述"></a>5.JDK 1.8 CurrentHashMap概述</h3><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8717.png" alt=""><br>1.其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。<br>2.大于8的时候才去红黑树链表转红黑树的阀值，当table[i]下面的链表长度大于8时就转化为红黑树结构。</p><h3 id="6-JDK1-8-put"><a href="#6-JDK1-8-put" class="headerlink" title="6. JDK1.8 put"></a>6. JDK1.8 put</h3><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8718.png" alt=""></p><ul><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>f即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的  hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据(分为链表写入和红黑树写入）。</li><li>如果数量大于 TREEIFY_THRESHOLD  则要转换为红黑树。</li></ul><h3 id="7-JDK1-8-get方法"><a href="#7-JDK1-8-get方法" class="headerlink" title="7. JDK1.8 get方法"></a>7. JDK1.8 get方法</h3><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8719.png" alt=""></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。<h3 id="8-rehash过程"><a href="#8-rehash过程" class="headerlink" title="8.rehash过程"></a>8.rehash过程</h3></li><li>Redis rehash ：dictRehash每次增量rehash n个元素，由于在自动调整大小时已设置好了ht[1]的大小，因此rehash的主要过程就是遍历ht[0]，取得key，然后将该key按ht[1]的 桶的大小重新rehash，并在rehash完后将ht[0]指向ht[1],然后将ht[0]清空。在这个过程中rehashidx非常重要，它表示上次rehash时在ht[0]的下标位置。</li><li>可以看到，redis对dict的rehash是分批进行的，这样不会阻塞请求，设计的比较优雅。</li><li>但是在调用dictFind的时候，可能需要对两张dict表做查询。唯一的优化判断是，当key在ht[0]不存在且不在rehashing状态时，可以速度返回空。如果在rehashing状态，当在ht[0]没值的时候，还需要在ht[1]里查找。</li><li>dictAdd的时候，如果状态是rehashing，则把值插入到ht[1]，否则ht[0]</li></ul><h1 id="三-Hashtable"><a href="#三-Hashtable" class="headerlink" title="三 Hashtable"></a>三 Hashtable</h1><p><a href="https://blog.csdn.net/ns_code/article/details/36191279" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/36191279</a></p><h2 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h2><p>-（1）table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>-（2）count是Hashtable的大小，它是Hashtable保存的键值对的数量。  </p><ul><li>（3）threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。</li><li>（4）loadFactor就是加载因子。</li><li>（5）modCount是用来实现fail-fast机制的<h2 id="1-put"><a href="#1-put" class="headerlink" title="1.put"></a>1.put</h2>从下面的代码中我们可以看出，Hashtable中的key和value是不允许为空的，当我们想要想Hashtable中添加元素的时候，首先计算key的hash值，然<br>后通过hash值确定在table数组中的索引位置，最后将value值替换或者插入新的元素，如果容器的数量达到阈值，就会进行扩充。<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8721.png" alt=""><h2 id="2-get"><a href="#2-get" class="headerlink" title="2.get"></a>2.get</h2><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8722.png" alt=""><h2 id="3-Remove"><a href="#3-Remove" class="headerlink" title="3.Remove"></a>3.Remove</h2>  在下面代码中，如果prev为null了，那么说明第一个元素就是要删除的元素，那么就直接指向第一个元素的下一个即可。<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8723.png" alt=""><h2 id="4-扩容"><a href="#4-扩容" class="headerlink" title="4.扩容"></a>4.扩容</h2></li><li>默认初始容量为11</li><li>线程安全，但是速度慢，不允许key/value为null</li><li>加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容</li><li>扩容增量：2*原数组长度+1如 HashTable的容量为11，一次扩容后是容量为23</li></ul><h1 id="四-一些面试题"><a href="#四-一些面试题" class="headerlink" title="四. 一些面试题"></a>四. 一些面试题</h1><h2 id="4-1-hashtable和hashmap的区别"><a href="#4-1-hashtable和hashmap的区别" class="headerlink" title="4.1  hashtable和hashmap的区别"></a>4.1  hashtable和hashmap的区别</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8724.png" alt="">    </p><h2 id="4-2-HashMap和ConCurrentHashMap区别"><a href="#4-2-HashMap和ConCurrentHashMap区别" class="headerlink" title="4.2  HashMap和ConCurrentHashMap区别"></a>4.2  HashMap和ConCurrentHashMap区别</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8725.png" alt=""></p><h2 id="4-3-ConcurrentHashMap和HashTable区别"><a href="#4-3-ConcurrentHashMap和HashTable区别" class="headerlink" title="4.3 ConcurrentHashMap和HashTable区别"></a>4.3 ConcurrentHashMap和HashTable区别</h2><ul><li>ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</li><li>hashtable(同一把锁):使用synchronized来保证线程安全，但效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。</li><li>concurrenthashmap(分段锁):(锁分段技术)每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li><li>concurrenthashmap是由Segment数组结构和HahEntry数组结构组成。Segment是一种可重入锁ReentrantLock，扮演锁的角色。HashEntry用于存储键值对数据。一个concurrenthashmap里包含一个Segment数组。Segment的结构和Hashmap类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment。<h2 id="4-4-linkedHashMap"><a href="#4-4-linkedHashMap" class="headerlink" title="4.4  linkedHashMap"></a>4.4  linkedHashMap</h2><a href="https://blog.csdn.net/justloveyou_/article/details/71713781" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/71713781</a><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8728.png" alt="">    <h2 id="4-5-Linkedhashmap与-hashmap的区别"><a href="#4-5-Linkedhashmap与-hashmap的区别" class="headerlink" title="4.5 Linkedhashmap与 hashmap的区别"></a>4.5 Linkedhashmap与 hashmap的区别</h2></li><li>1.LinkedHashMap是HashMap的子类</li><li>2.LinkedHashMap中的Entry增加了两个指针 before 和  after，它们分别用于维护双向链接列表。</li><li>3.在put操作上，虽然LinkedHashMap完全继承了HashMap的put操作，但是在细节上还是做了一定的调整，比如，在LinkedHashMap中向哈希表中插入新Entry的同时，还会通过Entry的addBefore方法将其链入到双向链表中。</li><li>4.在扩容操作上，虽然LinkedHashMap完全继承了HashMap的resize操作，但是鉴于性能和LinkedHashMap自身特点的考量，LinkedHashMap对其中的重哈希过程(transfer方法)进行了重写</li><li>5.在读取操作上，LinkedHashMap中重写了HashMap中的get方法，通过HashMap中的getEntry方法获取Entry对象。在此基础上，进一步获取指定键对应的值。<h2 id="4-6-HashSet"><a href="#4-6-HashSet" class="headerlink" title="4.6 HashSet"></a>4.6 HashSet</h2><blockquote><p>对于HashSet而言，它是基于HashMap实现的<br>Hashset源码 <a href="http://zhangshixi.iteye.com/blog/673143" target="_blank" rel="noopener">http://zhangshixi.iteye.com/blog/673143</a></p></blockquote></li></ul><p><strong>Hashset 如何保证集合的没有重复元素？</strong><br>可以看出hashset底层是hashmap但是存储的是一个对象，hashset实际将该元素e作为key放入hashmap,当key值(该元素e)相同时，只是进行更新value，并不会新增加，所以set中的元素不会进行改变。<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8729.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8730.png" alt="">    </p><h2 id="4-7-hashmap与hashset区别"><a href="#4-7-hashmap与hashset区别" class="headerlink" title="4.7 hashmap与hashset区别"></a>4.7 hashmap与hashset区别</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8731.png" alt=""></p><h2 id="4-8-Collections-sort-内部原理"><a href="#4-8-Collections-sort-内部原理" class="headerlink" title="4.8 Collections.sort 内部原理"></a>4.8 Collections.sort 内部原理</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8732.png" alt=""><br>重写 Collections.sort()</p><pre><code>import java.util.*;class xd{    int a;    int b;    xd(int a,int b){        this.a = a;        this.b = b;    }}public class Main {    public static void main(String[] arg) {        xd a = new xd(2,3);        xd b = new xd(4,1);        xd c = new xd(1,2);        ArrayList&lt;xd&gt; array = new ArrayList&lt;&gt;();        array.add(a);        array.add(b);        array.add(c);        Collections.sort(array, new Comparator&lt;xd&gt;() {            @Override            public int compare(xd o1, xd o2) {                if(o1.a &gt; o2.a)                    return 1;                else if(o1.a &lt; o2.a)                    return -1;                return 0;            }        });        for(int i=0;i&lt;array.size();i++)            System.out.println(array.get(i).a);        for(int i=0;i&lt;array.size();i++)            System.out.println(array.get(i).b);    }}</code></pre><h2 id="4-9-hash算法"><a href="#4-9-hash算法" class="headerlink" title="4.9  hash算法"></a>4.9  hash算法</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8733.png" alt=""></p><h1 id="五-ArrayList，LinkedList和Vector的区别和实现原理"><a href="#五-ArrayList，LinkedList和Vector的区别和实现原理" class="headerlink" title="五.ArrayList，LinkedList和Vector的区别和实现原理"></a>五.ArrayList，LinkedList和Vector的区别和实现原理</h1><pre><code>Vector : https://blog.csdn.net/chenssy/article/details/37520981</code></pre><h2 id="1-ArrayList与LinkedList区别"><a href="#1-ArrayList与LinkedList区别" class="headerlink" title="1.ArrayList与LinkedList区别"></a>1.ArrayList与LinkedList区别</h2><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p><h2 id="2-Vetor-arraylist-Linkedlist-区别"><a href="#2-Vetor-arraylist-Linkedlist-区别" class="headerlink" title="2. Vetor arraylist Linkedlist 区别"></a>2. Vetor arraylist Linkedlist 区别</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList#"></a>ArrayList#</h3><p><strong>ArrayList## 就是动态数组</strong>，是Array的复杂版本，动态的增加和减少元素.当更多的元素加入到ArrayList中时,其大小将会动态地增长。它的元素可以通过get/set方法直接访问，因为ArrayList本质上是一个数组。初始容量为10。</p><ul><li>1.插入元素的时候可能扩容，删除元素时不会缩小容量。</li><li>2.扩容增长为Arraylist增长原来的0.5倍 </li><li><ol start="3"><li>而Arraylist 没有设置增长空间的方法。</li></ol></li><li>4.线程不同步<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3></li></ul><p><strong>Vector</strong> 和ArrayList类似, 区别在于Vector是同步类(synchronized).因此,开销就比ArrayList要大。初始容量为10。实现了随机访问接口，可以随机访问。Vector是内部是以动态数组的形式来存储数据的。</p><ul><li>1.Vector还可以设置增长的空间大小，</li><li><ol start="2"><li>及Vector增长原来的1倍3.vector 线程同步<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3>LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比。它还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.</li></ol></li></ul><p>ArrayList和LinkedList的使用场景，其中add方法的实现ArrayList,LinkedList的实现以及插入，查找，删除的过程</p><h2 id="3-使用ArrayList的迭代器会出现什么问题？"><a href="#3-使用ArrayList的迭代器会出现什么问题？" class="headerlink" title="3.使用ArrayList的迭代器会出现什么问题？"></a>3.使用ArrayList的迭代器会出现什么问题？</h2><p>单线程和多线程环境下；<br>常用的迭代器设计模式，iterator方法返回一个父类实现的迭代器。</p><ul><li>1、迭代器的hasNext方法的作用是判断当前位置是否是数组最后一个位置，相等为false，否则为true。</li><li>2、迭代器next方法用于返回当前的元素，并把指针指向下一个元素，值得注意的是，每次使用next方法的时候，都会判断创建迭代器获取的这个容器的计数器modCount是否与此时的不相等，不相等说明集合的大小被修改过，如果是会抛出ConcurrentModificationException异常，如果相等调用get方法返回元素即可。<h2 id="4-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#4-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="4. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>4. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h2>答：不同点：定义上：Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。容量上：Array大小固定，ArrayList的大小是动态变化的。操作上：ArrayList提供更多的方法和特性，如：addAll()，removeAll()，iterator()等等。使用基本数据类型或者知道数据元素数量的时候可以考虑Array;ArrayList处理固定数量的基本类型数据类型时会自动装箱来减少编码工作量，但是相对较慢。<h2 id="5-ArrayList和Vector有何异同点？"><a href="#5-ArrayList和Vector有何异同点？" class="headerlink" title="5.ArrayList和Vector有何异同点？"></a>5.ArrayList和Vector有何异同点？</h2><h3 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h3></li><li>（1）两者都是基于索引的，都是基于数组的。</li><li>（2）两者都维护插入顺序，我们可以根据插入顺序来获取元素。</li><li>（3）ArrayList和Vector的迭代器实现都是fail-fast的。</li><li>（4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3></li><li>（1）Vector是同步，线程安全，而ArrayList非同步，线程不安全。对于ArrayList，如果迭代时改变列表，应该使用CopyOnWriteArrayList。</li><li>（2）但是，ArrayList比Vector要快，它因为有同步，不会过载。</li><li>（3）在使用上，ArrayList更加通用，因为Collections工具类容易获取同步列表和只读列表。<h2 id="6-快速失败-fail-fast-和安全失败-fail-safe"><a href="#6-快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="6. 快速失败(fail-fast)和安全失败(fail-safe)"></a>6. 快速失败(fail-fast)和安全失败(fail-safe)</h2><h3 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h3></li><li>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li><li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。<h3 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h3></li><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</li></ul><blockquote><p>快速失败和安全失败是对迭代器而言的。 快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败</p></blockquote><h3 id="Iterator和ListIterator的区别是什么？"><a href="#Iterator和ListIterator的区别是什么？" class="headerlink" title="Iterator和ListIterator的区别是什么？"></a>Iterator和ListIterator的区别是什么？</h3><p>答：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h3 id="快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><p>答：Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h3 id="Enumeration接口和Iterator接口的区别有哪些？"><a href="#Enumeration接口和Iterator接口的区别有哪些？" class="headerlink" title="Enumeration接口和Iterator接口的区别有哪些？"></a>Enumeration接口和Iterator接口的区别有哪些？</h3><p>答：Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="//post/Redis.html"/>
      <url>//post/Redis.html</url>
      
        <content type="html"><![CDATA[<p style="text-align:center;font-size:100px;">Redis</p><h1 id="一、从NoSQL说起"><a href="#一、从NoSQL说起" class="headerlink" title="一、从NoSQL说起"></a>一、从NoSQL说起</h1><p>NoSQL是Not only SQL的缩写，大意为“不只是SQL”，说明这项技术是<b><font color="red">传统关系型数据库的补充</font></b>而非替代。在整个NoSQL技术栈中<b><font color="blue">MemCache</font></b>、<b><font color="blue">Redis</font></b>、<b><font color="blue">MongoDB</font></b>被称为NoSQL三剑客。那么时代为什么需要NoSQL数据库呢？我们来做个对比：</p><table><thead><tr><th></th><th>关系型数据库</th><th>NoSQL数据库</th></tr></thead><tbody><tr><td>数据存储位置</td><td>硬盘</td><td>内存</td></tr><tr><td>数据结构</td><td>高度组织化结构化数据</td><td>没有预定义的模式</td></tr><tr><td>数据操作方式</td><td>SQL</td><td>所有数据都是键值对，没有声明性查询语言</td></tr><tr><td>事务控制</td><td>严格的基础事务ACID原则</td><td>CAP定理</td></tr></tbody></table><p>所以NoSQL数据库的最大优势体现为：高性能、高可用性和可伸缩性。</p><h1 id="二、Redis简介"><a href="#二、Redis简介" class="headerlink" title="二、Redis简介"></a>二、Redis简介</h1><p>Redis英文官网介绍：</p><pre class="line-numbers language-html"><code class="language-html">Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and geospatial indexes with radius queries. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Redis中文官网介绍：</p><pre class="line-numbers language-html"><code class="language-html">Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Redis命令参考文档网址：<a href="http://redisdoc.com" target="_blank" rel="noopener">http://redisdoc.com</a></p><h1 id="三、Redis安装"><a href="#三、Redis安装" class="headerlink" title="三、Redis安装"></a>三、Redis安装</h1><h2 id="1-上传并解压"><a href="#1-上传并解压" class="headerlink" title="1.上传并解压"></a>1.上传并解压</h2><p>redis-4.0.2.tar.gz</p><h2 id="2-安装C语言编译环境"><a href="#2-安装C语言编译环境" class="headerlink" title="2.安装C语言编译环境"></a>2.安装C语言编译环境</h2><p>[建议先拍快照]<br/></p><p>yum install -y gcc-c++</p><h2 id="3-修改安装位置"><a href="#3-修改安装位置" class="headerlink" title="3.修改安装位置"></a>3.修改安装位置</h2><p>vim redis解压目录/src/Makefile</p><pre class="line-numbers language-html"><code class="language-html">PREFIX?=/usr/local/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就Redis自身而言是不需要修改的，这里修改的目的是让Redis的运行程序不要和其他文件混杂在一起。</p><h2 id="4-编译安装"><a href="#4-编译安装" class="headerlink" title="4.编译安装"></a>4.编译安装</h2><p>编译：进入Redis解压目录执行make命令<br/></p><p>[建议先拍快照]<br/></p><p>安装：make install</p><h2 id="5-启动Redis服务器"><a href="#5-启动Redis服务器" class="headerlink" title="5.启动Redis服务器"></a>5.启动Redis服务器</h2><h3 id="①默认启动"><a href="#①默认启动" class="headerlink" title="①默认启动"></a>①默认启动</h3><pre class="line-numbers language-html"><code class="language-html">[root@rich ~]# /usr/local/redis/bin/redis-server7239:C 07 Oct 18:59:12.144 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo7239:C 07 Oct 18:59:12.144 # Redis version=4.0.2, bits=64, commit=00000000, modified=0, pid=7239, just started7239:C 07 Oct 18:59:12.144 # Warning: no config file specified, using the default config. In order to specify a config file use /usr/local/redis/bin/redis-server /path/to/redis.conf7239:M 07 Oct 18:59:12.145 * Increased maximum number of open files to 10032 (it was originally set to 1024).                _._                                                             _.-``__ ''-._                                                   _.-``    `.  `_.  ''-._           Redis 4.0.2 (00000000/0) 64 bit  .-`` .-```.  ```\/    _.,_ ''-._                                    (    '      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379 |    `-._   `._    /     _.-'    |     PID: 7239  `-._    `-._  `-./  _.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |           http://redis.io          `-._    `-._`-.__.-'_.-'    _.-'                                    |`-._`-._    `-.__.-'    _.-'_.-'|                                   |    `-._`-._        _.-'_.-'    |                                    `-._    `-._`-.__.-'_.-'    _.-'                                         `-._    `-.__.-'    _.-'                                                 `-._        _.-'                                                         `-.__.-'                                               7239:M 07 Oct 18:59:12.148 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.7239:M 07 Oct 18:59:12.148 # Server initialized7239:M 07 Oct 18:59:12.148 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.7239:M 07 Oct 18:59:12.148 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.7239:M 07 Oct 18:59:12.148 * Ready to accept connections<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止Redis服务器</p><pre class="line-numbers language-html"><code class="language-html">/usr/local/redis/bin/redis-cli shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html">7239:M 07 Oct 19:00:53.208 # User requested shutdown...7239:M 07 Oct 19:00:53.208 * Saving the final RDB snapshot before exiting.7239:M 07 Oct 19:00:53.214 * DB saved on disk7239:M 07 Oct 19:00:53.214 # Redis is now ready to exit, bye bye...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②定制配置项启动"><a href="#②定制配置项启动" class="headerlink" title="②定制配置项启动"></a>②定制配置项启动</h3><h4 id="1-准备配置文件"><a href="#1-准备配置文件" class="headerlink" title="[1]准备配置文件"></a>[1]准备配置文件</h4><p>cp /opt/redis-4.0.2/redis.conf /usr/local/redis/</p><h4 id="2-修改配置项"><a href="#2-修改配置项" class="headerlink" title="[2]修改配置项"></a>[2]修改配置项</h4><table><thead><tr><th>配置项名称</th><th>作用</th><th>取值</th></tr></thead><tbody><tr><td>daemonize</td><td>控制是否以守护进程形式运行Redis服务器</td><td>yes</td></tr><tr><td>logfile</td><td>指定日志文件位置</td><td>“/var/logs/redis.log”</td></tr><tr><td>dir</td><td>Redis工作目录</td><td>/usr/local/redis</td></tr></tbody></table><p>注意：/var/logs目录需要我们提前创建好</p><h4 id="3-让Redis根据指定的配置文件启动"><a href="#3-让Redis根据指定的配置文件启动" class="headerlink" title="[3]让Redis根据指定的配置文件启动"></a>[3]让Redis根据指定的配置文件启动</h4><p>格式</p><pre class="line-numbers language-html"><code class="language-html">redis-server文件路径 redis.conf文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例</p><pre class="line-numbers language-html"><code class="language-html">/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-客户端登录"><a href="#6-客户端登录" class="headerlink" title="6.客户端登录"></a>6.客户端登录</h2><p>/usr/local/redis/bin/redis-cli</p><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6379> pingPONG127.0.0.1:6379> exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="四、Redis五种常用数据结构"><a href="#四、Redis五种常用数据结构" class="headerlink" title="四、Redis五种常用数据结构"></a>四、Redis五种常用数据结构</h1><h2 id="1-总体结构"><a href="#1-总体结构" class="headerlink" title="1.总体结构"></a>1.总体结构</h2><table>    <tr>        <td rowspan="6">KEY</td>        <td>VALUE</td>    </tr>    <tr>        <td>string</td>    </tr>    <tr>        <td>list</td>    </tr>    <tr>        <td>set</td>    </tr>    <tr>        <td>hash</td>    </tr>    <tr>        <td>zset</td>    </tr></table><p>Redis中的数据，总体上是键值对，不同数据类型指的是键值对中值的类型。</p><h2 id="2-string类型"><a href="#2-string类型" class="headerlink" title="2.string类型"></a>2.string类型</h2><p>Redis中最基本的类型，它是key对应的一个单一值。二进制安全，不必担心由于编码等问题导致二进制数据变化。所以redis的string可以包含任何数据，比如jpg图片或者序列化的对象。Redis中一个字符串值的最大容量是512M。</p><h2 id="3-list类型"><a href="#3-list类型" class="headerlink" title="3.list类型"></a>3.list类型</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。说明它的底层是基于链表实现的，所以它操作时头尾效率高，中间效率低。</p><p><img src="images/p01.png" alt="p01"></p><h2 id="2-set类型"><a href="#2-set类型" class="headerlink" title="2.set类型"></a>2.set类型</h2><p>Redis的set是string类型的无序集合。它是基于哈希表实现的。</p><h2 id="3-hash类型"><a href="#3-hash类型" class="headerlink" title="3.hash类型"></a>3.hash类型</h2><p>本身就是一个键值对集合。可以当做Java中的Map&lt;String,Object&gt;对待。</p><h2 id="4-zset类型"><a href="#4-zset类型" class="headerlink" title="4.zset类型"></a>4.zset类型</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p><h1 id="五、Redis命令行操作"><a href="#五、Redis命令行操作" class="headerlink" title="五、Redis命令行操作"></a>五、Redis命令行操作</h1><h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h2><h3 id="①切换数据库"><a href="#①切换数据库" class="headerlink" title="①切换数据库"></a>①切换数据库</h3><pre class="line-numbers language-html"><code class="language-html">Redis默认有16个数据库。115 # Set the number of databases. The default database is DB 0, you can select116 # a different one on a per-connection basis using SELECT <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dbid</span><span class="token punctuation">></span></span> where117 # dbid is a number between 0 and 'databases'-1118 databases 16使用select进行切换，数据库索引从0开始127.0.0.1:6379> select 2OK127.0.0.1:6379[2]> select 0OK127.0.0.1:6379> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②查看数据库长度"><a href="#②查看数据库长度" class="headerlink" title="②查看数据库长度"></a>②查看数据库长度</h3><pre class="line-numbers language-html"><code class="language-html">    127.0.0.1:6379> dbsize    (integer) 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-KEY操作"><a href="#2-KEY操作" class="headerlink" title="2.KEY操作"></a>2.KEY操作</h2><pre class="line-numbers language-html"><code class="language-html">●KEYS PATTERN●TYPE KEY    返回KEY对应的值的类型●MOVE KEY DB    把一组键值对数据移动到另一个数据库中●DEL KEY [KEY ...]    根据KEY进行删除，至少要指定一个KEY●EXISTS KEY    检查指定的KEY是否存在。指定一个KEY时，存在返回1，不存在返回0。可以指定多个，返回存在的KEY的数量。●RANDOMKEY    在现有的KEY中随机返回一个●RENAME KEY NEWKEY    重命名一个KEY，NEWKEY不管是否是已经存在的都会执行，如果NEWKEY已经存在则会被覆盖。●RENAMENX KEY NEWKEY    只有在NEWKEY不存在时能够执行成功，否则失败●TIME    返回当前UNIX时间戳●TTL KEY    以秒为单位查看KEY还能存在多长时间●PTTL KEY    以毫秒为单位查看KEY还能存在多长时间●EXPIRE KEY SECONDS    给一个KEY设置在SECONDS秒后过期，过期会被Redis移除。●EXPIREAT KEY TIMESTAMP    设置一个KEY在TIMESTAMP指定的时间过期●PEXPIRE KEY MILLISECONDS    以毫秒为单位指定过期时间●PEXPIREAT KEY MILLISECONDS-TIMESTAMP    以毫秒为单位指定过期的时间戳●PERSIST KEY    移除过期时间，变成永久key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-string操作"><a href="#2-string操作" class="headerlink" title="2.string操作"></a>2.string操作</h2><pre class="line-numbers language-html"><code class="language-html">●SET KEY VALUE [EX SECONDS] [PX MILLISECONDS] [NX|XX]    给KEY设置一个string类型的值。    EX参数用于设置存活的秒数。    PX参数用于设置存活的毫秒数。    NX参数表示当前命令中指定的KEY不存在才行。    XX参数表示当前命令中指定的KEY存在才行。●GET KEY    根据key得到值，只能用于string类型。●APPEND KEY VALUE    把指定的value追加到KEY对应的原来的值后面，返回值是追加后字符串长度●STRLEN KEY    直接返回字符串长度●INCR KEY    自增1●DECR KEY    自减1●INCRBY KEY INCREMENT    原值+INCREMENT●DECRBY KEY DECREMENT    原值-DECREMENT●GETRANGE KEY START END    从字符串中取指定的一段●SETRANGE KEY OFFSET VALUE    从offset开始使用VALUE进行替换●SETEX KEY SECONDS VALUE    设置KEY,VALUE时指定存在秒数●SETNX KEY VALUE    新建字符串类型的键值对●MSET KEY VALUE [KEY VALUE ...]    一次性设置一组多个键值对●MGET KEY [KEY ...]    一次性指定多个KEY，返回它们对应的值，没有值的KEY返回值是(nil)●MSETNX KEY VALUE [KEY VALUE ...]    一次性新建多个值●GETSET KEY VALUE    设置新值，同时能够将旧值返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-list操作"><a href="#3-list操作" class="headerlink" title="3.list操作"></a>3.list操作</h2><pre class="line-numbers language-html"><code class="language-html">●LPUSH key value [value ...]●RPUSH key value [value ...]●LRANGE key start stop    根据list集合的索引打印元素数据    正着数：0,1,2,3,...    倒着数：-1,-2,-3,...●LLEN key●LPOP key    从左边弹出一个元素。    弹出=返回+删除。●RPOP key    从右边弹出一个元素。●RPOPLPUSH source destination    从source中RPOP一个元素，LPUSH到destination中●LINDEX key index    根据索引从集合中取值●LINSERT key BEFORE|AFTER pivot value    在pivot指定的值前面或后面插入value●LPUSHX key value    只能针对存在的list执行LPUSH●LREM key count value    根据count指定的数量从key对应的list中删除value●LSET key index value    把指定索引位置的元素替换为另一个值●LTRIM key start stop    仅保留指定区间的数据，两边的数据被删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-set操作"><a href="#4-set操作" class="headerlink" title="4.set操作"></a>4.set操作</h2><pre class="line-numbers language-html"><code class="language-html">●SADD key member [member ...]●SMEMBERS key●SCARD key    返回集合中元素的数量●SISMEMBER key member    检查当前指定member是否是集合中的元素●SREM key member [member ...]    从集合中删除元素●SINTER key [key ...]    将指定的集合进行“交集”操作    集合A：a,b,c    集合B：b,c,d    交集：b,c●SINTERSTORE destination key [key ...]    取交集后存入destination●SDIFF key [key ...]    将指定的集合执行“差集”操作    集合A：a,b,c    集合B：b,c,d    A对B执行diff：a    相当于：A-交集部分●SDIFFSTORE destination key [key ...]●SUNION key [key ...]    将指定的集合执行“并集”操作    集合A：a,b,c    集合B：b,c,d    并集：a,b,c,d●SUNIONSTORE destination key [key ...]●SMOVE source destination member    把member从source移动到destination●SPOP key [count]    从集合中随机弹出count个数量的元素，count不指定就弹出1个●SRANDMEMBER key [count]    从集合中随机返回count个数量的元素，count不指定就返回1个●SSCAN key cursor [MATCH pattern] [COUNT count]    基于游标的遍历<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-hash操作"><a href="#5-hash操作" class="headerlink" title="5.hash操作"></a>5.hash操作</h2><pre class="line-numbers language-html"><code class="language-html">●HSET key field value●HGETALL key●HGET key field●HLEN key●HKEYS key●HVALS key●HEXISTS key field●HDEL key field [field ...]●HINCRBY key field increment●HMGET key field [field ...]●HMSET key field value [field value ...]●HSETNX key field value●HSCAN key cursor [MATCH pattern] [COUNT count]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-zset操作"><a href="#6-zset操作" class="headerlink" title="6.zset操作"></a>6.zset操作</h2><pre class="line-numbers language-html"><code class="language-html">●ZADD key [NX|XX] [CH] [INCR] score member [score member ...]●ZRANGE key start stop [WITHSCORES]●ZCARD key●ZCOUNT key min max    根据分数在min，max之间查找元素●ZSCORE key member●ZINCRBY key increment member●ZLEXCOUNT key min max●ZRANGEBYLEX key min max [LIMIT offset count]    按照字母顺序在区间内返回member    min和max使用“[a”表示闭区间，使用“(a”表示开区间    -表示负无穷    +表示正无穷●ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]    在分数的指定区间内返回数据●ZRANK key member    先对分数进行升序排序，返回member的排名●ZREM key member [member ...]●ZREMRANGEBYLEX key min max●ZREMRANGEBYRANK key start stop●ZREMRANGEBYSCORE key min max●ZREVRANGE key start stop [WITHSCORES]●ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]●ZREVRANK key member●ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]●ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]    把指定集合的member取交集，分数会相加●ZSCAN key cursor [MATCH pattern] [COUNT count]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="六、Redis持久化机制"><a href="#六、Redis持久化机制" class="headerlink" title="六、Redis持久化机制"></a>六、Redis持久化机制</h1><p><a href="https://redis.io/topics/persistence#snapshotting" target="_blank" rel="noopener">官网描述</a></p><p>Redis工作时数据都存储在内存中，万一服务器断电，则所有数据都会丢失。针对这种情况，Redis采用持久化机制来增强数据安全性。</p><h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1.RDB"></a>1.RDB</h2><h3 id="①机制描述"><a href="#①机制描述" class="headerlink" title="①机制描述"></a>①机制描述</h3><p>每隔一定的时间把内存中的数据作为一个快照保存到硬盘上的文件中。Redis默认开启RDB机制。</p><h3 id="②触发时机"><a href="#②触发时机" class="headerlink" title="②触发时机"></a>②触发时机</h3><h4 id="1-基于默认配置"><a href="#1-基于默认配置" class="headerlink" title="[1]基于默认配置"></a>[1]基于默认配置</h4><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">save</span> <span class="token attr-value">900 1</span><span class="token attr-name">save</span> <span class="token attr-value">300 10</span><span class="token attr-name">save</span> <span class="token attr-value">60 10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>含义</p><table><thead><tr><th>配置</th><th>含义</th></tr></thead><tbody><tr><td>save 900 1</td><td>900秒内至少有一次修改则触发保存操作</td></tr><tr><td>save 300 10</td><td>300秒内至少有10次修改则触发保存操作</td></tr><tr><td>save 60 10000</td><td>60秒内至少有1万次修改则触发保存操作</td></tr></tbody></table><h4 id="2-使用保存命令"><a href="#2-使用保存命令" class="headerlink" title="[2]使用保存命令"></a>[2]使用保存命令</h4><p>save或bgsave</p><h4 id="3-使用flushall命令"><a href="#3-使用flushall命令" class="headerlink" title="[3]使用flushall命令"></a>[3]使用flushall命令</h4><p>这个命令也会产生dump.rdb文件，但里面是空的，没有意义</p><h4 id="4-服务器关闭"><a href="#4-服务器关闭" class="headerlink" title="[4]服务器关闭"></a>[4]服务器关闭</h4><p>如果执行SHUTDOWN命令让Redis正常退出，那么此前Redis就会执行一次持久化保存。</p><h3 id="③相关配置"><a href="#③相关配置" class="headerlink" title="③相关配置"></a>③相关配置</h3><table><thead><tr><th>配置项</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>save</td><td>“”</td><td>禁用RDB机制</td></tr><tr><td>dbfilename</td><td>文件名，例如：dump.rdb</td><td>设置RDB机制下，数据存储文件的文件名</td></tr><tr><td>dir</td><td>Redis工作目录路径</td><td>指定存放持久化文件的目录的路径。注意：这里指定的必须是目录不能是文件名</td></tr></tbody></table><h3 id="④思考"><a href="#④思考" class="headerlink" title="④思考"></a>④思考</h3><p>RDB机制能够保证数据的绝对安全吗？</p><h2 id="2-AOF"><a href="#2-AOF" class="headerlink" title="2.AOF"></a>2.AOF</h2><h3 id="①机制描述-1"><a href="#①机制描述-1" class="headerlink" title="①机制描述"></a>①机制描述</h3><p>根据配置文件中指定的策略，把生成数据的命令保存到硬盘上的文件中。一个AOF文件的内容可以参照下面的例子：</p><pre class="line-numbers language-properties"><code class="language-properties">*2$6SELECT$10*3$3set$3num$210*2$4incr$3num*2$4incr$3num*2$4incr$3num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成上面文件内容的Redis命令是：</p><pre class="line-numbers language-html"><code class="language-html">set num 10incr numincr numincr num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="②AOF基本配置"><a href="#②AOF基本配置" class="headerlink" title="②AOF基本配置"></a>②AOF基本配置</h3><table><thead><tr><th>配置项</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>appendonly</td><td>yes</td><td>启用AOF持久化机制</td></tr><tr><td></td><td>no</td><td>禁用AOF持久化机制[默认值]</td></tr><tr><td>appendfilename</td><td>“文件名”</td><td>AOF持久化文件名</td></tr><tr><td>dir</td><td>Redis工作目录路径</td><td>指定存放持久化文件的目录的路径。注意：这里指定的必须是目录不能是文件名</td></tr><tr><td>appendfsync</td><td>always</td><td>每一次数据修改后都将执行文件写入操作，缓慢但是最安全。</td></tr><tr><td></td><td>everysec</td><td>每秒执行一次写入操作。折中。</td></tr><tr><td></td><td>no</td><td>由操作系统在适当的时候执行写入操作，最快。</td></tr></tbody></table><h3 id="③AOF重写"><a href="#③AOF重写" class="headerlink" title="③AOF重写"></a>③AOF重写</h3><p>对比下面两组命令：</p><table><thead><tr><th>AOF重写前</th><th>AOF重写后</th></tr></thead><tbody><tr><td>set count 1<br />incr count<br />incr count<br />incr count</td><td>set count 4</td></tr></tbody></table><p>两组命令执行后对于count来说最终的值是一致的，但是进行AOF重写后省略了中间过程，可以让AOF文件体积更小。而Redis会根据AOF文件的体积来决定是否进行AOF重写。参考的配置项如下：</p><table><thead><tr><th>配置项</th><th>含义</th></tr></thead><tbody><tr><td>auto-aof-rewrite-percentage 100</td><td>文件体积增大100%时执行AOF重写</td></tr><tr><td>auto-aof-rewrite-min-size 64mb</td><td>文件体积增长到64mb时执行AOF重写</td></tr></tbody></table><p>实际工作中不要进行频繁的AOF重写，因为CPU资源和硬盘资源二者之间肯定是CPU资源更加宝贵，所以不应该过多耗费CPU性能去节省硬盘空间。</p><h2 id="3-持久化文件损坏修复"><a href="#3-持久化文件损坏修复" class="headerlink" title="3.持久化文件损坏修复"></a>3.持久化文件损坏修复</h2><p>Redis服务器启动时如果读取了损坏的持久化文件会导致启动失败，此时为了让Redis服务器能够正常启动，需要对损坏的持久化文件进行修复。这里以AOF文件为例介绍修复操作的步骤。</p><ul><li><p>第一步：备份要修复的appendonly.aof文件</p></li><li><p>第二步：执行修复程序</p><p>/usr/local/redis/bin/redis-check-aof –fix /usr/local/redis/appendonly.aof</p></li><li><p>第三步：重启Redis</p></li></ul><p>注意：所谓修复持久化文件仅仅是把损坏的部分去掉，而没法把受损的数据找回。</p><h2 id="4-扩展阅读：两种持久化机制的取舍"><a href="#4-扩展阅读：两种持久化机制的取舍" class="headerlink" title="4.扩展阅读：两种持久化机制的取舍"></a>4.扩展阅读：两种持久化机制的取舍</h2><h3 id="①RDB"><a href="#①RDB" class="headerlink" title="①RDB"></a>①RDB</h3><h4 id="1-优势"><a href="#1-优势" class="headerlink" title="[1]优势"></a>[1]优势</h4><p>适合大规模的数据恢复，速度较快</p><h4 id="2-劣势"><a href="#2-劣势" class="headerlink" title="[2]劣势"></a>[2]劣势</h4><p>会丢失最后一次快照后的所有修改，不能绝对保证数据的高度一致性和完整性。Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑，但上述成立有条件，Linux也有优化手段</p><h3 id="②AOF"><a href="#②AOF" class="headerlink" title="②AOF"></a>②AOF</h3><h4 id="1-优势-1"><a href="#1-优势-1" class="headerlink" title="[1]优势"></a>[1]优势</h4><p>选择appendfsync always方式运行时理论上能够做到数据完整一致，但此时性能又不好。文件内容具备一定可读性，能够用来分析Redis工作情况。</p><h4 id="2-劣势-1"><a href="#2-劣势-1" class="headerlink" title="[2]劣势"></a>[2]劣势</h4><p>持久化相同的数据，文件体积比RDB大，恢复速度比RDB慢。效率在同步写入时低于RDB，不同步写入时与RDB相同。</p><h3 id="③RDB和AOF并存"><a href="#③RDB和AOF并存" class="headerlink" title="③RDB和AOF并存"></a>③RDB和AOF并存</h3><p>Redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</p><p>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)、快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p><h3 id="④使用建议"><a href="#④使用建议" class="headerlink" title="④使用建议"></a>④使用建议</h3><p>如果Redis仅仅作为缓存可以不使用任何持久化方式。</p><p>其他应用方式综合考虑性能和完整性、一致性要求。</p><p>RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。如果不开启AOF，仅靠Master-Slave Replication 实现高可用性能也不错。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构。</p><h1 id="七、Redis事务控制"><a href="#七、Redis事务控制" class="headerlink" title="七、Redis事务控制"></a>七、Redis事务控制</h1><h2 id="1-Redis事务控制的相关命令"><a href="#1-Redis事务控制的相关命令" class="headerlink" title="1.Redis事务控制的相关命令"></a>1.Redis事务控制的相关命令</h2><table><thead><tr><th>命令名</th><th>作用</th></tr></thead><tbody><tr><td>MULTI</td><td>表示开始收集命令，后面所有命令都不是马上执行，而是加入到一个队列中。</td></tr><tr><td>EXEC</td><td>执行MULTI后面命令队列中的所有命令。</td></tr><tr><td>DISCARD</td><td>放弃执行队列中的命令。</td></tr><tr><td>WATCH</td><td>“观察“、”监控“一个KEY，在当前队列外的其他命令操作这个KEY时，放弃执行自己队列的命令</td></tr><tr><td>UNWATCH</td><td>放弃监控一个KEY</td></tr></tbody></table><h2 id="2-命令队列执行失败的两种情况"><a href="#2-命令队列执行失败的两种情况" class="headerlink" title="2.命令队列执行失败的两种情况"></a>2.命令队列执行失败的两种情况</h2><h3 id="①加入队列时失败"><a href="#①加入队列时失败" class="headerlink" title="①加入队列时失败"></a>①加入队列时失败</h3><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6379> multiOK127.0.0.1:6379> set age 20QUEUED127.0.0.1:6379> incr ageQUEUED127.0.0.1:6379> incr age www(error) ERR wrong number of arguments for 'incr' command127.0.0.1:6379> exec(error) EXECABORT Transaction discarded because of previous errors.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遇到了入队时即可检测到的错误，整个队列都不会执行。</p><h3 id="②执行队列时失败"><a href="#②执行队列时失败" class="headerlink" title="②执行队列时失败"></a>②执行队列时失败</h3><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6379> multiOK127.0.0.1:6379> set age 30QUEUED127.0.0.1:6379> incrby age 5QUEUED127.0.0.1:6379> incrby age 5QUEUED127.0.0.1:6379> incrby age wwQUEUED127.0.0.1:6379> incrby age 5QUEUED127.0.0.1:6379> EXEC1) OK2) (integer) 353) (integer) 404) (error) ERR value is not an integer or out of range5) (integer) 45127.0.0.1:6379> get age"45"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误在入队时检测不出来，整个队列执行时有错的命令执行失败，但是其他命令并没有回滚。</p><h3 id="③Redis为什么不支持回滚"><a href="#③Redis为什么不支持回滚" class="headerlink" title="③Redis为什么不支持回滚"></a>③Redis为什么不支持回滚</h3><p>官方解释如下：</p><blockquote><pre><code>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。以下是这种做法的优点：1.Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。    2.因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</code></pre></blockquote><h2 id="3-悲观锁和乐观锁"><a href="#3-悲观锁和乐观锁" class="headerlink" title="3.悲观锁和乐观锁"></a>3.悲观锁和乐观锁</h2><p>在使用WATCH命令监控一个KEY后，当前队列中的命令会由于外部命令的执行而放弃，这是乐观锁的体现。</p><ul><li><p>悲观锁</p><p>认为当前环境非常容易发生碰撞，所以执行操作前需要把数据锁定，操作完成后释放锁，其他操作才可以继续操作。</p></li><li><p>乐观锁</p><p>认为当前环境不容易发生碰撞，所以执行操作前不锁定数据，万一碰撞真的发生了，那么放弃自己的操作。</p></li></ul><h1 id="八、Redis主从复制机制"><a href="#八、Redis主从复制机制" class="headerlink" title="八、Redis主从复制机制"></a>八、Redis主从复制机制</h1><p><img src="images/p02.png" alt="p02"></p><h2 id="1-读写分离的好处："><a href="#1-读写分离的好处：" class="headerlink" title="1.读写分离的好处："></a>1.读写分离的好处：</h2><ul><li>性能优化：主服务器专注于写操作，可以用更适合写入数据的模式工作；同样，从服务器专注于读操作，可以用更适合读取数据的模式工作。</li><li>强化数据安全，避免单点故障：由于数据同步机制的存在，各个服务器之间数据保持一致，所以其中某个服务器宕机不会导致数据丢失或无法访问。从这个角度说参与主从复制的Redis服务器构成了一个<b><font color="blue">集群</font></b>。</li></ul><h2 id="2-搭建步骤"><a href="#2-搭建步骤" class="headerlink" title="2.搭建步骤"></a>2.搭建步骤</h2><h3 id="①思路"><a href="#①思路" class="headerlink" title="①思路"></a>①思路</h3><p>Redis集群在运行时使用的是同一个可执行文件，只是对应的配置文件不同。</p><p><img src="images/p03.png" alt="p03"></p><p>每个配置文件中相同的参数是：</p><pre class="line-numbers language-html"><code class="language-html">daemonize yesdir /usr/local/cluster-redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不同的参数有：</p><table><thead><tr><th>配置项名称</th><th>作用</th><th>取值</th></tr></thead><tbody><tr><td>port</td><td>Redis服务器启动后监听的端口号</td><td>6000<br />7000<br />8000</td></tr><tr><td>dbfilename</td><td>RDB文件存储位置</td><td>dump6000.rdb<br />dump7000.rdb<br />dump8000.rdb</td></tr><tr><td>logfile</td><td>日志文件位置</td><td>/var/logs/redis6000.log<br />/var/logs/redis7000.log<br />/var/logs/redis8000.log</td></tr><tr><td>pidfile</td><td>pid文件位置</td><td>/var/run/redis6000.pid<br />/var/run/redis7000.pid<br />/var/run/redis8000.pid</td></tr></tbody></table><h3 id="②步骤"><a href="#②步骤" class="headerlink" title="②步骤"></a>②步骤</h3><ul><li>第一步：创建/usr/local/cluster-redis目录</li><li>第二步：把原始未经修改的redis.conf复制到/usr/local/cluster-redis目录</li><li>第三步：把/usr/local/cluster-redis目录下的redis.conf复制为redis6000.conf</li><li>第四步：按照既定计划修改redis6000.conf中的相关配置项<ul><li>daemonize yes</li><li>dir</li><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li><li>第五步：复制redis6000.conf为redis7000.conf</li><li>第六步：修改redis7000.conf中的相关配置项<ul><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li><li>第七步：复制redis6000.conf为redis8000.conf</li><li>第八步：修改redis8000.conf中的相关配置项<ul><li>port</li><li>dbfilename</li><li>logfile</li><li>pidfile</li></ul></li></ul><h3 id="③启动Redis主从复制集群"><a href="#③启动Redis主从复制集群" class="headerlink" title="③启动Redis主从复制集群"></a>③启动Redis主从复制集群</h3><pre class="line-numbers language-html"><code class="language-html">/usr/local/redis/bin/redis-server /usr/local/cluster-redis/redis6000.conf/usr/local/redis/bin/redis-server /usr/local/cluster-redis/redis7000.conf/usr/local/redis/bin/redis-server /usr/local/cluster-redis/redis8000.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用redis-cli停止指定服务器的命令格式如下：<br/><br>/usr/local/bin/redis-cli -h IP地址 -p 端口号 shutdown</p><h2 id="3-主从关系"><a href="#3-主从关系" class="headerlink" title="3.主从关系"></a>3.主从关系</h2><h3 id="①查看主从关系"><a href="#①查看主从关系" class="headerlink" title="①查看主从关系"></a>①查看主从关系</h3><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6000> info replication# Replicationrole:masterconnected_slaves:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>刚刚启动的集群服务器中每一个节点服务器都认为自己是主服务器。需要建立主从关系。</p><h3 id="②设定主从关系"><a href="#②设定主从关系" class="headerlink" title="②设定主从关系"></a>②设定主从关系</h3><p>在从机上指定主机位置即可</p><pre class="line-numbers language-html"><code class="language-html">SLAVEOF 127.0.0.1 6000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="③取消主从关系"><a href="#③取消主从关系" class="headerlink" title="③取消主从关系"></a>③取消主从关系</h3><p>在从机上执行命令</p><pre class="line-numbers language-html"><code class="language-html">SLAVEOF NO ONE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-初步测试"><a href="#4-初步测试" class="headerlink" title="4.初步测试"></a>4.初步测试</h2><ul><li>测试1：在主机写入数据，在从机查看</li><li>测试2：在从机写入数据报错。配置文件中的依据是：slave-read-only yes</li><li>测试3：主机执行SHUTDOWN看从机状态</li><li>测试4：主机恢复启动，看从机状态</li><li>测试5：从机SHUTDOWN，此时主机写入数据，从机恢复启动查看状态。重新设定主从关系后看新写入的数据是否同步。</li></ul><h2 id="5-哨兵模式"><a href="#5-哨兵模式" class="headerlink" title="5.哨兵模式"></a>5.哨兵模式</h2><h3 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h3><p>通过哨兵服务器监控master/slave实现主从复制集群的自动管理。</p><p><img src="images/p04.png" alt="p04"></p><h3 id="②相关概念"><a href="#②相关概念" class="headerlink" title="②相关概念"></a>②相关概念</h3><h4 id="1-主观下线"><a href="#1-主观下线" class="headerlink" title="[1]主观下线"></a>[1]主观下线</h4><p>1台哨兵检测到某节点服务器下线。</p><h4 id="2-客观下线"><a href="#2-客观下线" class="headerlink" title="[2]客观下线"></a>[2]客观下线</h4><p>认为某个节点服务器下线的哨兵服务器达到指定数量。这个数量后面在哨兵的启动配置文件中指定。</p><h3 id="③配置方式"><a href="#③配置方式" class="headerlink" title="③配置方式"></a>③配置方式</h3><p>简单起见我们只配置一台哨兵。我们所需要做的就是创建一个哨兵服务器运行所需要的配置文件。</p><p>vim /usr/local/cluster-redis/sentinel.conf</p><table><thead><tr><th>格式</th><th>sentinel monitor 为主机命名 主机IP 主机端口号 将主机判定为下线时需要Sentinel同意的数量</th></tr></thead><tbody><tr><td>例子</td><td>sentinel monitor mymaster 127.0.0.1 6000 1</td></tr></tbody></table><h3 id="④启动哨兵"><a href="#④启动哨兵" class="headerlink" title="④启动哨兵"></a>④启动哨兵</h3><p>/usr/local/redis/bin/redis-server /usr/local/cluster-redis/sentinel.conf –sentinel</p><pre class="line-numbers language-html"><code class="language-html">+sdown master mymaster 127.0.0.1 6379 【主观下线】+odown master mymaster 127.0.0.1 6379 #quorum 1/1【客观下线】……+vote-for-leader 17818eb9240c8a625d2c8a13ae9d99ae3a70f9d2 1【选举leader】……+failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379【把一个从机设置为主机】-------------挂掉的主机又重新启动----------------------sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381【离开主观下线状态】+convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381【转换为从机】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="九、发布订阅"><a href="#九、发布订阅" class="headerlink" title="九、发布订阅"></a>九、发布订阅</h1><h2 id="1-订阅一个频道"><a href="#1-订阅一个频道" class="headerlink" title="1.订阅一个频道"></a>1.订阅一个频道</h2><pre class="line-numbers language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> SUBSCRIBE cctvReading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>1<span class="token punctuation">)</span> <span class="token string">"subscribe"</span>2<span class="token punctuation">)</span> <span class="token string">"cctv"</span>3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-在一个频道上发布信息"><a href="#2-在一个频道上发布信息" class="headerlink" title="2.在一个频道上发布信息"></a>2.在一个频道上发布信息</h2><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6379> PUBLISH cctv hai(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-html"><code class="language-html">127.0.0.1:6379> SUBSCRIBE cctvReading messages... (press Ctrl-C to quit)1) "subscribe"2) "cctv"3) (integer) 11) "message"2) "cctv"3) "hai"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="十、Jedis"><a href="#十、Jedis" class="headerlink" title="十、Jedis"></a>十、Jedis</h1><h2 id="1-一个对比"><a href="#1-一个对比" class="headerlink" title="1.一个对比"></a>1.一个对比</h2><table><thead><tr><th></th><th>MySQL</th><th>Redis</th></tr></thead><tbody><tr><td>连接</td><td>Connection</td><td>Jedis</td></tr><tr><td>连接池</td><td>C3P0等等</td><td>JedisPool</td></tr><tr><td>操作完成</td><td>关闭连接</td><td>关闭连接</td></tr></tbody></table><h2 id="2-Redis准备"><a href="#2-Redis准备" class="headerlink" title="2.Redis准备"></a>2.Redis准备</h2><h3 id="①理解Redis配置文件中bind配置项含义"><a href="#①理解Redis配置文件中bind配置项含义" class="headerlink" title="①理解Redis配置文件中bind配置项含义"></a>①理解Redis配置文件中bind配置项含义</h3><p>bind后面跟的ip地址是客户端访问Redis时使用的IP地址。看下面例子：<br>| bind值      | 访问方式     |<br>| ———- | ——— |<br>| 127.0.0.1 | ./redis-cli -h 127.0.0.1     |<br>| 192.168.200.100   | ./redis-cli -h 192.168.200.100 |</p><h3 id="②查看Linux系统本机IP"><a href="#②查看Linux系统本机IP" class="headerlink" title="②查看Linux系统本机IP"></a>②查看Linux系统本机IP</h3><p>远程客户端访问Linux服务器时不能使用127.0.0.1，要使用网络上的实际IP。可以用ifconfig命令查看。</p><h3 id="③将Redis配置文件中的bind配置项设置为本机IP。"><a href="#③将Redis配置文件中的bind配置项设置为本机IP。" class="headerlink" title="③将Redis配置文件中的bind配置项设置为本机IP。"></a>③将Redis配置文件中的bind配置项设置为本机IP。</h3><pre class="line-numbers language-html"><code class="language-html">bind [你的实际IP]bind 192.168.200.100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-Jedis"><a href="#3-Jedis" class="headerlink" title="3.Jedis"></a>3.Jedis</h2><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定Redis服务器的IP地址和端口号</span>Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"192.168.200.100"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行ping命令</span>String ping <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ping<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭连接</span>jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-JedisPool"><a href="#4-JedisPool" class="headerlink" title="4.JedisPool"></a>4.JedisPool</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//声明Linux服务器IP地址</span>String host <span class="token operator">=</span> <span class="token string">"192.168.200.100"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明Redis端口号</span><span class="token keyword">int</span> port <span class="token operator">=</span> Protocol<span class="token punctuation">.</span>DEFAULT_PORT<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建连接池对象</span>JedisPool jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取Jedis对象连接Redis</span>Jedis jedis <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行具体操作</span>String ping <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ping<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//关闭连接</span>jedisPool<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识点和答案</title>
      <link href="//post/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E7%AD%94%E6%A1%88.html"/>
      <url>//post/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E7%AD%94%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-Java-8种基本类型有哪些？"><a href="#1-1-Java-8种基本类型有哪些？" class="headerlink" title="1.1. Java 8种基本类型有哪些？"></a>1.1. Java 8种基本类型有哪些？</h1><p>Byte  short  int  long float  double  boolean  char</p><p><img src="https://ws4.sinaimg.cn/large/006Xmmmgly1g5v04dixr0j30d80ck0uu.jpg" alt=""></p><h1 id="1-2-什么是装箱和拆箱？"><a href="#1-2-什么是装箱和拆箱？" class="headerlink" title="1.2 什么是装箱和拆箱？"></a>1.2 什么是装箱和拆箱？</h1><p>装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。<br>比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。</p><ul><li><p>原始类型: boolean，char，byte，short，int，long，float，double</p></li><li><p>封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p></li><li><p>示例：</p><pre><code>Integer i = 10;这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：Integer i = 10;  //装箱int n = i;   //拆箱</code></pre><h1 id="1-3-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#1-3-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="1.3  short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?"></a>1.3  short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 +=1;有什么错?</h1></li><li><p>对于short s1=1;s1=s1+1来说，在s1+1运算时会自动提升表达式的类型为int，那么将int赋予给short类型的变量s1会出现类型转换错误。</p></li><li><p>对于short s1=1;s1+=1来说 +=是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p></li></ul><h1 id="1-4-int和Integer的区别"><a href="#1-4-int和Integer的区别" class="headerlink" title="1.4 int和Integer的区别"></a>1.4 int和Integer的区别</h1><p><a href="https://www.cnblogs.com/guodongdidi/p/6953217.html" target="_blank" rel="noopener">https://www.cnblogs.com/guodongdidi/p/6953217.html</a></p><ul><li>Integer是int的包装类，int则是java的一种基本数据类型 </li><li>Integer变量必须实例化后才能使用，而int变量不需要 </li><li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </li><li>Integer的默认值是null，int的默认值是0</li></ul><p>延伸：<br>关于Integer和int的比较<br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><pre><code>Integer i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false</code></pre><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><pre><code>Integer i = new Integer(100);int j = 100；System.out.print(i == j); //true</code></pre><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</p><pre><code>Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false</code></pre><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><pre><code>Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false</code></pre><p>对于第4条的原因：<br>java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p><pre><code>public static Integer valueOf(int i){    assert IntegerCache.high &gt;= 127;    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high){        return IntegerCache.cache[i + (-IntegerCache.low)];    }    return new Integer(i);}</code></pre><p>java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p><h1 id="1-5-字节和字符的区别"><a href="#1-5-字节和字符的区别" class="headerlink" title="1.5 字节和字符的区别"></a>1.5 字节和字符的区别</h1><p>字节是存储容量的基本单位，字符是数子，字母，汉子以及其他语言的各种符号。1字节=8个二进制单位：一个一个字符由一个字节或多个字节的二进制单位组成。</p><h1 id="1-6-基本类型和引用类型的区别"><a href="#1-6-基本类型和引用类型的区别" class="headerlink" title="1.6 基本类型和引用类型的区别"></a>1.6 基本类型和引用类型的区别</h1><p>基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所处的位置/地址）</p><h1 id="1-7-Java的四个基本特性及多态的理解？"><a href="#1-7-Java的四个基本特性及多态的理解？" class="headerlink" title="1.7 Java的四个基本特性及多态的理解？"></a>1.7 Java的四个基本特性及多态的理解？</h1><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w2pliuhij30js0b8n1z.jpg" alt=""></p><h1 id="1-8-重载和重写的区别？"><a href="#1-8-重载和重写的区别？" class="headerlink" title="1.8 重载和重写的区别？"></a>1.8 重载和重写的区别？</h1><h2 id="1-8-1-重载"><a href="#1-8-1-重载" class="headerlink" title="1.8.1 重载"></a>1.8.1 重载</h2><p><a href="https://blog.csdn.net/cey009008/article/details/46331619" target="_blank" rel="noopener">https://blog.csdn.net/cey009008/article/details/46331619</a></p><p> 重载（overload），Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。<br>-1.可以在一个类中也可以在继承关系的类中；<br>-2.名相同；  </p><ul><li>3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。<h2 id="1-8-2-重写"><a href="#1-8-2-重写" class="headerlink" title="1.8.2 重写"></a>1.8.2 重写</h2>重写（override)又名覆盖，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。: </li><li>1.不能存在同一个类中，在继承或实现关系的类中；  </li><li>2.名相同，参数列表相同，方法返回值相同，  </li><li>3.子类方法的访问修饰符要大于父类的。  </li><li>4.子类的检查异常类型要小于父类的检查异常。  <h1 id="1-9-Java中是否可以覆盖-override-一个private或者是static的方法？"><a href="#1-9-Java中是否可以覆盖-override-一个private或者是static的方法？" class="headerlink" title="1.9 Java中是否可以覆盖(override)一个private或者是static的方法？"></a>1.9 Java中是否可以覆盖(override)一个private或者是static的方法？</h1>Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。<h1 id="1-10-面向对象的六个基本原则"><a href="#1-10-面向对象的六个基本原则" class="headerlink" title="1.10 面向对象的六个基本原则"></a>1.10 面向对象的六个基本原则</h1><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w39fm22gj30vw0hy13y.jpg" alt=""><h1 id="1-11-Java-创建对象的四种方式"><a href="#1-11-Java-创建对象的四种方式" class="headerlink" title="1.11 Java 创建对象的四种方式"></a>1.11 Java 创建对象的四种方式</h1><a href="https://www.cnblogs.com/yunche/p/9530927.html" target="_blank" rel="noopener">https://www.cnblogs.com/yunche/p/9530927.html</a></li><li>1.使用new创建对象<br>使用new关键字创建对象应该是最常见的一种方式，但我们应该知道，使用new创建对象会增加耦合度。无论使用什么框架，都要减少new的使用以降低耦合度。</li><li>2.使用反射的机制创建对象<br>使用Class类的newInstance方法</li><li>3.采用clone<br>clone时，需要已经有一个分配了内存的源对象，创建新对象时，首先应该分配一个和源对象一样大的内存空间。要调用clone方法需要实现Cloneable接口</li><li>4.采用序列化机制<br>使用序列化时，要实现实现Serializable接口，将一个对象序列化到磁盘上，而采用反序列化可以将磁盘上的对象信息转化到内存中。<h1 id="1-12-String、StringBuffer和StringBuilder的区别"><a href="#1-12-String、StringBuffer和StringBuilder的区别" class="headerlink" title="1.12 String、StringBuffer和StringBuilder的区别"></a>1.12 String、StringBuffer和StringBuilder的区别</h1><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w4mh9b0zj30ur06pn0z.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w4mlg6vej30fe016aa8.jpg" alt=""><h1 id="1-13-String不可变好处"><a href="#1-13-String不可变好处" class="headerlink" title="1.13 String不可变好处"></a>1.13 String不可变好处</h1><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w4oo4m9qj30q60cln0f.jpg" alt=""></li></ul><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w4osa6aij30fe03pgmi.jpg" alt=""></p><h1 id="1-14-String-Pool"><a href="#1-14-String-Pool" class="headerlink" title="1.14 String Pool"></a>1.14 String Pool</h1><p><a href="https://github.com/gzc426/CS-Notes/edit/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md">https://github.com/gzc426/CS-Notes/edit/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md</a></p><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><pre class="line-numbers language-java"><code class="language-java">String s5 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>String s6 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href="https://stackoverflow.com/questions/10578984/what-is-string-interning" target="_blank" rel="noopener">StackOverflow : What is String interning?</a></li><li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析 String#intern</a></li></ul><h1 id="1-15-new-String-“abc”"><a href="#1-15-new-String-“abc”" class="headerlink" title="1.15 new String(“abc”)"></a>1.15 new String(“abc”)</h1><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NewStringTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ...</span>Constant pool<span class="token operator">:</span><span class="token comment" spellcheck="true">// ...</span>   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// java/lang/String</span>   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">19</span>            <span class="token comment" spellcheck="true">// abc</span><span class="token comment" spellcheck="true">// ...</span>  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>String  #<span class="token number">19</span> <span class="token operator">=</span> Utf8               abc<span class="token comment" spellcheck="true">// ...</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// class java/lang/String</span>         <span class="token number">3</span><span class="token operator">:</span> dup         <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String abc</span>         <span class="token number">6</span><span class="token operator">:</span> invokespecial #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String."&lt;init>":(Ljava/lang/String;)V</span>         <span class="token number">9</span><span class="token operator">:</span> astore_1<span class="token comment" spellcheck="true">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="1-16-string有重写-Object的-hashcode和-toString吗-如果重写-equals不重写-hashcode会出现什么问题"><a href="#1-16-string有重写-Object的-hashcode和-toString吗-如果重写-equals不重写-hashcode会出现什么问题" class="headerlink" title="1.16 string有重写 Object的 hashcode和 toString吗?如果重写 equals不重写 hashcode会出现什么问题"></a>1.16 string有重写 Object的 hashcode和 toString吗?如果重写 equals不重写 hashcode会出现什么问题</h1><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5w4sq64ymj30xf0bvtfd.jpg" alt=""></p><p>在存储散列集合时〔如Set类),如果原对象equals新对象,但没有对 hashCode重写,即两个对象拥有不同的hashCode,则在集合中将会存储两个值相同的对象,从而导致混看。因此在重写 equals方法时,必须重写 hashCode</p><h1 id="1-17-String中的“-”是如何实现的？"><a href="#1-17-String中的“-”是如何实现的？" class="headerlink" title="1.17 String中的“+”是如何实现的？"></a>1.17 String中的“+”是如何实现的？</h1><p><a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/6036701.html</a></p><pre><code>String c = &quot;xx&quot; + &quot;yy &quot; + a + &quot;zz&quot; + &quot;mm&quot; + b; 实质上的实现过程是： String c = new StringBuilder(&quot;xxyy &quot;).append(a).append(&quot;zz&quot;).append(&quot;mm&quot;).append(b).toString();底层通过 StringBuilder实现</code></pre><h1 id="1-18-Java-如何进行文件读取？"><a href="#1-18-Java-如何进行文件读取？" class="headerlink" title="1.18 Java 如何进行文件读取？"></a>1.18 Java 如何进行文件读取？</h1><p>FileReader类是将文件按字符流的方式读取char数组或者String.FileInputStream则按字符流的方式读取文件byte数组。</p><ul><li>1.首先获得一个文件句柄。 File fille= new File();file即为文件句柄。两人之间连<br>通电话网络了。接下来可以开始打电话了</li><li>2.通过这条线路读取甲方的信息: new FileInputStream(fe)目前这个信息已经<br>读进来内存当中了。接下来需要解读成乙方可以理解的东西</li><li>3.既然你使用了 FileInputStream()。那么对应的需要使用 InputStreamReader()<br>这个方法进行解读刚才装进来内存当中的数据</li><li>4.解读完成后要输出呀。那当然要转换成IO可以识别的数据呀。那就需要调用字节<br>码读取的方法 Bufferedreader()。同时使用 bufferedReader()的 readline()方<br>法读取txt文件中的每一行数据哈。<h1 id="1-19-反射"><a href="#1-19-反射" class="headerlink" title="1.19 反射"></a>1.19 反射</h1><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5xbl9l6brj30xl0gygyf.jpg" alt=""></li></ul><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5xblf6b2yj30lr0gb7dv.jpg" alt=""></p><p>反射机制中可以获取private成员的值吗（没有set和get函数）</p><h1 id="1-19-JDK和JRE的区别？"><a href="#1-19-JDK和JRE的区别？" class="headerlink" title="1.19 JDK和JRE的区别？"></a>1.19 JDK和JRE的区别？</h1><ul><li>Java运行时环境(JRE)。它包括Java虚拟机、Java核心类库和支持文件。它不包含开发工具（JDK）–编译器、调试器和其他工具。</li><li>Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</li></ul><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5xbpno6p2j311u0knjzt.jpg" alt=""></p><h1 id="1-20-static和final"><a href="#1-20-static和final" class="headerlink" title="1.20 static和final"></a>1.20 static和final</h1><h2 id="1-static和final区别"><a href="#1-static和final区别" class="headerlink" title="(1) static和final区别"></a>(1) static和final区别</h2><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5xbub06cdj30mn08lgot.jpg" alt=""></p><h2 id="2-final的好处："><a href="#2-final的好处：" class="headerlink" title="(2) final的好处："></a>(2) final的好处：</h2><p>1.final关键字提高了性能。JVM和Java应用都会缓存final变量。<br>2.final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。<br>3.使用final关键字，JVM会对方法、变量及类进行优化。</p><h2 id="（3）static方法是否可以覆盖？"><a href="#（3）static方法是否可以覆盖？" class="headerlink" title="（3）static方法是否可以覆盖？"></a>（3）static方法是否可以覆盖？</h2><p>static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p><h1 id="1-21-session和cookie区别"><a href="#1-21-session和cookie区别" class="headerlink" title="1.21 session和cookie区别"></a>1.21 session和cookie区别</h1><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5xc3l5kikj30px075n0q.jpg" alt=""><br>cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：<br>无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。<br>在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。<br>服务器端Session的保存<br>Cookie和session区别<br>session在服务器上以怎样的形式存在session持久化<br>怎么设置session和cookie的有效时间<br>Session的实现原理和应用场景 Session原理; 既然Session是存储在服务器内存的, </p><h1 id="1-22-finalize-finalization-finally"><a href="#1-22-finalize-finalization-finally" class="headerlink" title="1.22 finalize finalization finally"></a>1.22 finalize finalization finally</h1><h2 id="一．finalize用途"><a href="#一．finalize用途" class="headerlink" title="一．finalize用途"></a>一．finalize用途</h2><p>答：垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。</p><h2 id="二．finally"><a href="#二．finally" class="headerlink" title="二．finally"></a>二．finally</h2><p>finally 一定会被执行，如果 finally 里有 return 语句，则覆盖 try/catch 里的 return ，<br>比较爱考的是 finally 里没有 return 语句，这时虽然 finally 里对 return 的值进行了修改，但 return 的值并不改变这种情况</p><h2 id="三．finally代码块和finalize-方法有什么区别？"><a href="#三．finally代码块和finalize-方法有什么区别？" class="headerlink" title="三．finally代码块和finalize()方法有什么区别？"></a>三．finally代码块和finalize()方法有什么区别？</h2><p>无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。</p><h2 id="四-finally到底是在return之前执行还是return之后执行？"><a href="#四-finally到底是在return之前执行还是return之后执行？" class="headerlink" title="四. finally到底是在return之前执行还是return之后执行？"></a>四. finally到底是在return之前执行还是return之后执行？</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485244&amp;idx=1&amp;sn=162035183aa027b887fc642fddc4ad69&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485244&amp;idx=1&amp;sn=162035183aa027b887fc642fddc4ad69&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect</a></p><h2 id="五-final关键字详解"><a href="#五-final关键字详解" class="headerlink" title="五. final关键字详解"></a>五. final关键字详解</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485027&amp;idx=1&amp;sn=f565be7c5ce33e9737d94ce9a58bd0ea&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485027&amp;idx=1&amp;sn=f565be7c5ce33e9737d94ce9a58bd0ea&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect</a></p><h1 id="1-23-public-private-default-protected"><a href="#1-23-public-private-default-protected" class="headerlink" title="1.23 public private default protected"></a>1.23 public private default protected</h1><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5yfwftsjrj30ha06wjsq.jpg" alt=""><br>不写时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。<br>不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖</p><h1 id="1-24-Object有哪些方法？"><a href="#1-24-Object有哪些方法？" class="headerlink" title="1.24 Object有哪些方法？"></a>1.24 Object有哪些方法？</h1><ul><li>hashcode() </li><li>equals() </li><li>toString() </li><li>getClass() </li><li>wait </li><li>notify() </li><li>notifyAll()</li><li>finalize()</li></ul><h1 id="1-25-equals和"><a href="#1-25-equals和" class="headerlink" title="1.25 equals和=="></a>1.25 equals和==</h1><ul><li>（1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的”值”是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。</li><li>（2）equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</li><li>（3）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。</li><li>（4）StringBuffer 和StringBuilder，==和equal都是比较地址<h1 id="1-26-异常"><a href="#1-26-异常" class="headerlink" title="1.26 异常"></a>1.26 异常</h1></li></ul><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g5yhdhue5xj30gk0j2n1r.jpg" alt=""></p><p>Throwable.是ava话言中所有错误和异常的超类(万物即可抛).艺有两个子类:Eror、 Exception<br>异常种类</p><ul><li>Err:Eror为错误,是程序无法处理的,如 Out OfMemoryεror、 Thread Death等,出现这种况你唯一能做的就<br>是听之任之,交由M来处理,不过M在大多数情况下会选择终止程</li><li>Exception: Exception.是程序可以处理的异常。E又分为两种 CheckedException(受捡异常),一种是<br>UncheckedException(不受检异常)<ul><li>CheckException发生在编译阶段,必须要使用ry- catch(或者 throws)否则编译不通过</li><li>UncheckedException发生在运行期,具有不确症性,主要是由于程序的逻辑引起的,难以排查，如除0的产生的异常,我们一般都需要纵观全局才能够发现这类的异常错误,所以在程序设计中我们需要认真考虐,好好写代码,尽量处理异常,即使产生了异常,也能尽量保证程序朝着有利方向发展，ClassCastException(类转换异常) IndexOutOfBoundsException(数组越界) NullPointerException(空指针) ArrayStoreException(数据存储异常，操作数组时类型不一致) <h1 id="1-27-Runtime"><a href="#1-27-Runtime" class="headerlink" title="1.27 Runtime"></a>1.27 Runtime</h1>Runtime:运行时，是一个封装了JVM的类。每一个JAVA程序实际上都是启动了一个JVM进程，每一个JVM进程都对应一个Runtime实例，此实例是由JVM为其实例化的。所以我们不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。<br>查看官方文档可以看到，Runtime类中没有构造方法，本类的构造方法被私有化了， 所以才会有getRuntime方法返回本来的实例化对象，这与单例设计模式不谋而合<br>public static Runtime getRuntime()<br>直接使用此静态方法可以取得Runtime类的实例</li></ul></li></ul><h1 id="1-28-接口和抽象类"><a href="#1-28-接口和抽象类" class="headerlink" title="1.28 接口和抽象类"></a>1.28 接口和抽象类</h1><p>1.接口和抽象类的区别<br>1，抽象类里可以有构造方法，而接口内不能有构造方法。<br>2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。<br>3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。<br>4，抽象类中的抽象方法的访问类型可以是public ，protected和private，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5，抽象类中可以包含静态方法，接口内不能包含静态方法。<br>6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static类型，并且默认为public static final类型。<br>7，一个类可以实现多个接口，但只能继承一个抽象类。</p><ol><li>Java抽象类可以有构造函数吗？<br>可以有，抽象类可以声明并定义构造函数。因为你不可以创建抽象类的实例，所以构造函数只能通过构造函数链调用（Java中构造函数链指的是从其他构造函数调用一个构造函数），例如，当你创建具体的实现类。现在一些面试官问，如果你不能对抽象类实例化那么构造函数的作用是什么？好吧，它可以用来初始化抽象类内部声明的通用变量，并被各种实现使用。另外，即使你没有提供任何构造函数，编译器将为抽象类添加默认的无参数的构造函数，没有的话你的子类将无法编译，因为在任何构造函数中的第一条语句隐式调用super()，Java中默认超类的构造函数。</li><li>Java抽象类可以实现接口吗？它们需要实现所有的方法吗？<br>可以，抽象类可以通过使用关键字implements来实现接口。因为它们是抽象的，所以它们不需要实现所有的方法。好的做法是，提供一个抽象基类以及一个接口来声明类型 。这样的例子是，java.util.List接口和相应的java.util.AbstractList抽象类。因为AbstractList实现了所有的通用方法，具体的实现像LinkedList和ArrayList不受实现所有方法的负担，它们可以直接实现List接口。这对两方面都很好，你可以利用接口声明类型的优点和抽象类的灵活性在一个地方实现共同的行为。Effective Java有个很好的章节，介绍如何使用Java的抽象类和接口，值得阅读。</li><li>Java抽象类可以是final的吗？<br>不可以，Java抽象类不能是final的。将它们声明为final的将会阻止它们被继承，而这正是使用抽象类唯一的方法。它们也是彼此相反的，关键字abstract强制继承类，而关键字final阻止类被扩张。在现实世界中，抽象表示不完备性，而final是用来证明完整性。底线是，你不能让你的Java类既abstract又final，同时使用，是一个编译时错误。</li><li>Java抽象类可以有static方法吗？<br>可以，抽象类可以声明并定义static方法，没什么阻止这样做。但是，你必须遵守Java中将方法声明为static的准则，<ol start="5"><li>可以创建抽象类的实例吗？<br>不可以，你不能创建Java抽象类的实例，它们是不完全的。即使你的抽象类不包含任何抽象方法，你也不能对它实例化。将类声明为abstract的，就等你你告诉编译器，它是不完全的不应该被实例化。当一段代码尝试实例化一个抽象类时Java编译器会抛错误。</li></ol></li><li>抽象类必须有抽象方法吗？<br>不需要，抽象类有抽象方法不是强制性的。你只需要使用关键字abstract就可以将类声明为抽象类。编译器会强制所有结构的限制来适用于抽象类，例如，现在允许创建一些实例。是否在抽象类中有抽象方法是引起争论的。我的观点是，抽象类应该有抽象方法，因为这是当程序员看到那个类并做假设的第一件事。这也符合最小惊奇原则。</li><li>何时选用抽象类而不是接口？<br>这是对之前抽象类和接口对比问题的后续。如果你知道语法差异，你可以很容易回答这个问题，因为它们可以令你做出抉择。当关心升级时，因为不可能在一个发布的接口中添加一个新方法，用抽象类会更好。类似地，如果你的接口中有很多方法，你对它们的实现感到很头疼，考虑提供一个抽象类作为默认实现。这是Java集合包中的模式，你可以使用提供默认实现List接口的AbstractList。</li><li>Java中的抽象方法是什么？<br>抽象方法是一个没有方法体的方法。你仅需要声明一个方法，不需要定义它并使用关键字abstract声明。Java接口中所有方法的声明默认是abstract的。这是抽象方法的例子<br>public void abstract printVersion();<br>现在，为了实现这个方法，你需要继承该抽象类并重载这个方法。</li><li>Java抽象类中可以包含main方法吗？<br>是的，抽象类可以包含main方法，它只是一个静态方法，你可以使用main方法执行抽象类，但不可以创建任何实例。</li></ol><h1 id="1-29-注解"><a href="#1-29-注解" class="headerlink" title="1.29 注解"></a>1.29 注解</h1><p><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></p><h1 id="1-30-泛型"><a href="#1-30-泛型" class="headerlink" title="1.30 泛型"></a>1.30 泛型</h1><p><a href="http://www.importnew.com/24029.html" target="_blank" rel="noopener">http://www.importnew.com/24029.html</a></p><ul><li><p>(1)Java中的泛型是什么 ? 使用泛型的好处是什么?<br>这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p></li><li><p>(2)Java的泛型是如何工作的 ? 什么是类型擦除 ?<br>这是一道更好的泛型面试题。泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。请阅读我的Java中泛型是如何工作的来了解更多信息。</p></li><li><p>(3)什么是泛型中的限定通配符和非限定通配符 ?<br>这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。</p></li><li><p>(4)List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?<br>这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Integer>或List<Float>。在本段出现的连接中可以找到更多信息。</p></li><li><p>(5)如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?<br>编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样:</p><pre><code>    public V put(K key, V value) {            return cache.put(key, value);    }</code></pre></li><li><p>(6)Java中如何使用泛型编写带有参数的类?<br>这是上一道面试题的延伸。面试官可能会要求你用泛型编写一个类型安全的类，而不是编写一个泛型方法。关键仍然是使用泛型类型来代替原始类型，而且要使用JDK中采用的标准占位符。</p></li><li><p>(7)编写一段泛型程序来实现LRU缓存?<br>对于喜欢Java编程的人来说这相当于是一次练习。给你个提示，LinkedHashMap可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap提供了一个称为removeEldestEntry()的方法，该方法会被put()和putAll()调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。</p></li><li><p>(8)你可以把List<String>传递给一个接受List<Object>参数的方法吗？<br>对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。　</p></li><li><p>(9)Array中可以用泛型吗?<br>这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。</p></li><li><p>(1)) 如何阻止Java中的类型未检查的警告?<br>如果你把泛型和原始类型混合起来使用，例如下列代码，Java 5的javac编译器会产生类型未检查的警告，例如　　</p><pre><code>List&lt;String&gt; rawList = new ArrayList()</code></pre></li></ul><h1 id="1-31-泛型-？与T的区别"><a href="#1-31-泛型-？与T的区别" class="headerlink" title="1.31 泛型 ？与T的区别"></a>1.31 泛型 ？与T的区别</h1><p><a href="https://blog.csdn.net/woshizisezise/article/details/79374460" target="_blank" rel="noopener">https://blog.csdn.net/woshizisezise/article/details/79374460</a></p><pre><code>public static &lt;T&gt; void show1(List&lt;T&gt; list){ for (Object object : list) {        System.out.println(object.toString());    }}public static void show2(List&lt;?&gt; list) {    for (Object object : list) {        System.out.println(object);    }}public static void test(){   List&lt;Student&gt; list1 = new ArrayList&lt;&gt;();   list1.add(new Student(&quot;zhangsan&quot;,18,0));   list1.add(new Student(&quot;lisi&quot;,28,0));   list1.add(new Student(&quot;wangwu&quot;,24,1));   //这里如果add(new Teacher(...));就会报错，因为我们已经给List指定了数据类型为Student   show1(list1);   System.out.println(&quot;************分割线**************&quot;);   //这里我们并没有给List指定具体的数据类型，可以存放多种类型数据   List list2 = new ArrayList&lt;&gt;();   list2.add(new Student(&quot;zhaoliu&quot;,22,1));   list2.add(new Teacher(&quot;sunba&quot;,30,0));   show2(list2);}</code></pre><p>从show2方法可以看出和show1的区别了，list2存放了Student和Teacher两种类型，同样可以输出数据，所以这就是T和?的区别啦</p><h1 id="1-32-字节流和字符流的区别"><a href="#1-32-字节流和字符流的区别" class="headerlink" title="1.32 字节流和字符流的区别"></a>1.32 字节流和字符流的区别</h1><p><a href="https://www.cnblogs.com/huangliting/p/5746950.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangliting/p/5746950.html</a><br><a href="https://www.cnblogs.com/huangliting/p/5746950.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangliting/p/5746950.html</a></p><h2 id="字节流："><a href="#字节流：" class="headerlink" title="字节流："></a>字节流：</h2><p><img src="https://images2015.cnblogs.com/blog/1004782/201608/1004782-20160807193514106-1603602397.png" alt=""><br><img src="https://images2015.cnblogs.com/blog/1004782/201608/1004782-20160807193524637-1218858412.png" alt=""></p><ul><li>(A)FileOutputStream(File name) 创建一个文件输出流，向指定的 File 对象输出数据。</li><li>(B)FileOutputStream(FileDescriptor) 创建一个文件输出流，向指定的文件描述器输出数据。</li><li>(C)FileOutputStream(String name) 创建一个文件输出流，向指定名称的文件输出数据。</li><li>(D)FileOutputStream(String, boolean) 用指定系统的文件名，创建一个输出文件。</li></ul><p><img src="https://images2015.cnblogs.com/blog/1004782/201608/1004782-20160807193558668-1200087629.png" alt=""><br><img src="https://images2015.cnblogs.com/blog/1004782/201608/1004782-20160807193607762-955819376.png" alt=""><br>InputStreamReader 和 OutputStreamReader ：<br>把一个以字节为导向的 stream 转换成一个以字符为导向的 stream 。<br>InputStreamReader 类是从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。<br>使用的编码方式可能由名称指定，或平台可接受的缺省编码方式。<br>InputStreamReader 的 read() 方法之一的每次调用，可能促使从基本字节输入流中读取一个或多个字节。<br>为了达到更高效率，考虑用 BufferedReader 封装 InputStreamReader ，<br>BufferedReader in = new BufferedReader(new InputStreamReader(System.in));</p><h2 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h2><p>InputStream，OutputStream,Reader,writer都是抽象类。所以不能直接new </p><h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？<br>区别：</p><ul><li>1、字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</li><li>2、字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</li><li>3、Reader类的read()方法返回类型为int ：作为整数读取的字符（占两个字节共16位），范围在 0 到 65535 之间 (0x00-0xffff)，如果已到达流的末尾，则返回 -1<br>inputStream的read()虽然也返回int，但由于此类是面向字节流的，一个字节占8个位，所以返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。因此对于不能用0-255来表示的值就得用字符流来读取！比如说汉字.<h2 id="4、字节流与字符流主要的区别是他们的的处理方式"><a href="#4、字节流与字符流主要的区别是他们的的处理方式" class="headerlink" title="4、字节流与字符流主要的区别是他们的的处理方式"></a>4、字节流与字符流主要的区别是他们的的处理方式</h2>字节流：处理字节和字节数组或二进制对象；<br>字符流：处理字符、字符数组或字符串。<h2 id="那开发中究竟用字节流好还是用字符流好呢？"><a href="#那开发中究竟用字节流好还是用字符流好呢？" class="headerlink" title="那开发中究竟用字节流好还是用字符流好呢？"></a>那开发中究竟用字节流好还是用字符流好呢？</h2>一、字符（Reader和 Writer）：中文，字符是只有在内存中才会形成的，操作字符、字符数组或字符串，<br>二、字节（InputStream 和OutputStream）：音频文件、图片、歌曲，所有的硬盘上保存文件或进行传输的时候，操作字节和字节数组或二进制对象,</li></ul><p>*如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。</p><h1 id="1-33-父子类的加载顺序？"><a href="#1-33-父子类的加载顺序？" class="headerlink" title="1.33 父子类的加载顺序？"></a>1.33 父子类的加载顺序？</h1><blockquote><p>面试和笔试经常考</p></blockquote><p>详情可以看：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485357&amp;idx=1&amp;sn=4cfda217b421eb5144d7b873894b5206&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247485357&amp;idx=1&amp;sn=4cfda217b421eb5144d7b873894b5206&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect</a></p><p>类的加载顺序。</p><ul><li>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</li><li>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</li><li>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</li><li>(4) 父类构造函数</li><li>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</li><li>(6) 子类构造函数</li></ul><h1 id="1-34-什么是字符集和编码？"><a href="#1-34-什么是字符集和编码？" class="headerlink" title="1.34 什么是字符集和编码？"></a>1.34 什么是字符集和编码？</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247484848&amp;idx=1&amp;sn=ad7f134c40574ec1214df28b078c88e1&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&amp;mid=2247484848&amp;idx=1&amp;sn=ad7f134c40574ec1214df28b078c88e1&amp;scene=19&amp;token=557705008&amp;lang=zh_CN#wechat_redirect</a></p><h1 id="1-35-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#1-35-Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="1.35 Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>1.35 Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h1><p>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英<br>文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，<br>Math.ceil(11.3)的结果为12,Math.ceil(-11.3)的结果是-11；floor 的英文意义是地板，该方法<br>就表示向下取整，Math.ceil(11.6)的结果为11,Math.ceil(-11.6)的结果是-12；最难掌握的是<br>round 方法，它表示“四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上0.5后再向<br>下取整，所以，Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11。</p><h1 id="1-36-char-型变量中能不能存贮一个中文汉字-为什么"><a href="#1-36-char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="1.36 char 型变量中能不能存贮一个中文汉字?为什么?"></a>1.36 char 型变量中能不能存贮一个中文汉字?为什么?</h1><blockquote><p>作业帮面试题</p></blockquote><p>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，<br>char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编<br>码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编<br>码占用两个字节，所以，char 类型的变量也是占用两个字节。</p><h1 id="1-37"><a href="#1-37" class="headerlink" title="1.37"></a>1.37</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一份薄礼</title>
      <link href="//post/Java%E8%B5%84%E6%BA%90.html"/>
      <url>//post/Java%E8%B5%84%E6%BA%90.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="1、直通BAT算法"><a href="#1、直通BAT算法" class="headerlink" title="1、直通BAT算法"></a>1、直通BAT算法</h3><p>初级班+进阶班：链接: <a href="https://pan.baidu.com/s/1PcwJUt2yLPfrOEvAA2wv7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1PcwJUt2yLPfrOEvAA2wv7Q</a> 提取码: i4q2</p><p>笔者对视频中的知识点做了总结：</p><ul><li>基础篇：<a href="http://www.zhenganwen.top/posts/62859a9a/" target="_blank" rel="noopener">http://www.zhenganwen.top/posts/62859a9a/</a></li><li>进阶篇：<a href="http://www.zhenganwen.top/posts/19e411e9/" target="_blank" rel="noopener">http://www.zhenganwen.top/posts/19e411e9/</a></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="1、MySQL优化"><a href="#1、MySQL优化" class="headerlink" title="1、MySQL优化"></a>1、MySQL优化</h3><p>链接: <a href="https://pan.baidu.com/s/1lc9qK6QwiCIjGEbqFrp6XQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1lc9qK6QwiCIjGEbqFrp6XQ</a> 提取码: y89t</p><p>笔者总结：<a href="http://www.zhenganwen.top/posts/62645e84/" target="_blank" rel="noopener">http://www.zhenganwen.top/posts/62645e84/</a></p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h3 id="1-、计算机网络精讲视频"><a href="#1-、计算机网络精讲视频" class="headerlink" title="1.、计算机网络精讲视频"></a>1.、计算机网络精讲视频</h3><p>链接: <a href="https://pan.baidu.com/s/1KqciniE9OJD9-vFlAaXuxg" target="_blank" rel="noopener">https://pan.baidu.com/s/1KqciniE9OJD9-vFlAaXuxg</a> 提取码: bud4</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1、老汪并发和多线程三阶段"><a href="#1、老汪并发和多线程三阶段" class="headerlink" title="1、老汪并发和多线程三阶段"></a>1、老汪并发和多线程三阶段</h3><blockquote><p>老汪出品必属精品，谁看谁知道，淘宝店“心蓝说Java”，可跟客服砍价</p></blockquote><p>第一阶段、并发和多线程基础：链接: <a href="https://pan.baidu.com/s/1Cnwvlf9jvPAnJsFhqhDF2g" target="_blank" rel="noopener">https://pan.baidu.com/s/1Cnwvlf9jvPAnJsFhqhDF2g</a> 提取码: 9v91</p><p>第二阶段、并发和多线程设计模式：链接: <a href="https://pan.baidu.com/s/1GpzAy8KNON3T2s_oxC85qQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1GpzAy8KNON3T2s_oxC85qQ</a> 提取码: u6d5</p><p>第三阶段、JUC详解：链接: <a href="https://pan.baidu.com/s/1CI8qX-hkaMQuSosnUIP3og" target="_blank" rel="noopener">https://pan.baidu.com/s/1CI8qX-hkaMQuSosnUIP3og</a> 提取码: 7020</p>]]></content>
      
      
      <categories>
          
          <category> 视频教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer解析（Java实现）</title>
      <link href="//post/%E5%85%AD%E3%80%81Java%E5%89%91%E6%8C%87offer.html"/>
      <url>//post/%E5%85%AD%E3%80%81Java%E5%89%91%E6%8C%87offer.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下题目按照牛客网在线编程排序，所有代码示例代码均已通过牛客网OJ。</p></blockquote><h3 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>暴力方法是遍历一遍二维数组，找到<code>target</code>就返回<code>true</code>，时间复杂度为<code>O(M * N)</code>（对于M行N列的二维数组）。</p><p>由题可知输入的数据样本具有高度规律性（单独一行的数据来看是有序的，单独一列的数据来看也是有序的），因此考虑能否有一个比较基准在一次的比较中根据有序性淘汰不必再进行遍历比较的数。<strong>有序</strong>、<strong>查找</strong>，由此不难联想到二分查找，我们可以借鉴二分查找的思路，每次选出一个数作为比较基准进而淘汰掉一些不必比较的数。二分是选取数组的中位数作为比较基准的，因此能够保证每次都淘汰掉二分之一的数，那么此题中有没有这种特性的数呢？我们不妨举例观察一下：</p><p><img src="https://ws1.sinaimg.cn/large/006zweohgy1fzaxy3978uj304x04mt8m.jpg" alt="image"></p><p>不难发现上图中对角线上的数是其所在行和所在列形成的序列的中位数，不妨选取右上角的数作为比较基准，如果不相等，那么我们可以淘汰掉所有它左边的数或者它所有下面的，比如对于<code>target = 6</code>，因为<code>(0,3)</code>位置上的<code>4 &lt; 6</code>，因此<code>(0,3)</code>位置及其同一行的左边的所有数都小于6因此可以直接淘汰掉，淘汰掉之后问题就变为了从剩下的三行中找<code>target</code>，这与原始问题是相似的，也就是说每一次都选取右上角的数据为比较基准然后淘汰掉一行或一列，直到某一轮被选取的数就是<code>target</code>或者已经淘汰得只剩下一个数的时候就一定能得出结果了，因此时间复杂度为被淘汰掉的行数和列数之和，即<code>O(M + N)</code>，经过分析后不难写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> target <span class="token operator">==</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是每次选取的数都是第一行最后一个数，因此前提是第一行有数，那么就对应着输入检查的<code>arr[0] == null || arr[0].length == 0</code>，这点比较容易忽略。</p><blockquote><p>总结：经过分析其实不难发现，此题是在一维有序数组使用二分查找元素的一个变种，我们应该充分利用数据本身的规律性来寻找解题思路。</p></blockquote><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">replaceSpace</span><span class="token punctuation">(</span>StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>此题考查的是字符串这个数据结构的数组实现（对应的还有链表实现）的相关操作。</p></blockquote><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><h5 id="String-replace简单粗暴"><a href="#String-replace简单粗暴" class="headerlink" title="String.replace简单粗暴"></a>String.replace简单粗暴</h5><p>如果可以使用<code>API</code>，那么可以很容易地写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">replaceSpace</span><span class="token punctuation">(</span>StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token comment" spellcheck="true">//null pointer</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//empty str or not exist blank</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"%20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="时间O-n-，空间O-n"><a href="#时间O-n-，空间O-n" class="headerlink" title="时间O(n)，空间O(n)"></a>时间O(n)，空间O(n)</h5><p>但是如果面试官告诉我们不许使用封装好的替换函数，那么目的就是在考查我们对字符串<strong>数组实现</strong>方式的相关操作。由于是连续空间存储，因此需要在创建实例时指定大小，由于每个空格都使用<code>%20</code>替换，因此替换之后的字符串应该比原串多出<code>空格数 * 2</code>个长度，实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">replaceSpace</span><span class="token punctuation">(</span>StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token comment" spellcheck="true">//null pointer</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//empty str or not exist blank</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> source <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> blankCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> source<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        blankCount <span class="token operator">=</span> <span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">?</span> blankCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> blankCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>source<span class="token punctuation">.</span>length <span class="token operator">+</span> blankCount <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> source<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> dest<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>source<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dest<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>            dest<span class="token punctuation">[</span>j<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'2'</span><span class="token punctuation">;</span>            dest<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'%'</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            dest<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> source<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="时间O-n-，空间O-1"><a href="#时间O-n-，空间O-1" class="headerlink" title="时间O(n)，空间O(1)"></a>时间O(n)，空间O(1)</h5><p>如果还要求不能有额外空间，那我们就要考虑如何复用输入的字符串，如果我们从前往后遇到空格就将空格及其之后的两个位置替换为<code>%20</code>，势必会覆盖空格之后的两个字符，比如<code>hello world</code>会被替换成<code>hello%20rld</code>，因此我们需要在长度被扩展后的新串中从后往前确定每个索引上的字符。比如使用一个<code>originalIndex</code>指向原串中的最后一个字符索引，使用<code>newIndex</code>指向新串的最后一个索引，每次将<code>originalIndex</code>上的字符复制到<code>newIndex</code>上并且两个指针前移，如果<code>originalIndex</code>上的字符是空格，则将<code>newIndex</code>依次填充<code>0,2,%</code>，然后两者再前移，直到两者都到首索引位置。</p><p><img src="https://ws1.sinaimg.cn/large/006zweohgy1fzb0mknemyj30ng0df74w.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">replaceSpace</span><span class="token punctuation">(</span>StringBuffer str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token comment" spellcheck="true">//null pointer</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//empty str or not exist blank</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> blankCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        blankCount <span class="token operator">=</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">?</span> blankCount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> blankCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> originalIndex <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> newIndex <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> blankCount <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    str<span class="token punctuation">.</span><span class="token function">setLength</span><span class="token punctuation">(</span>newIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需要重新设置一下字符串的长度，否则会报越界错误</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>originalIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> newIndex <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>originalIndex<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">setCharAt</span><span class="token punctuation">(</span>newIndex<span class="token operator">--</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            str<span class="token punctuation">.</span><span class="token function">setCharAt</span><span class="token punctuation">(</span>newIndex<span class="token operator">--</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            str<span class="token punctuation">.</span><span class="token function">setCharAt</span><span class="token punctuation">(</span>newIndex<span class="token punctuation">,</span> <span class="token string">'%'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            str<span class="token punctuation">.</span><span class="token function">setCharAt</span><span class="token punctuation">(</span>newIndex<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>originalIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        originalIndex<span class="token operator">--</span><span class="token punctuation">;</span>        newIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：要把思维打开，对于数组的操作我们习惯性的以<code>for(int i = 0 ; i &lt; arr.length ; i++)</code>的形式从头到尾来操作数组，但是不要忽略了从尾到头遍历也有它的独到之处。</p></blockquote><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">ReverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><p>此题的难点在于无法通过一个单链表结点获取其前驱结点，因此我们不仅要在反转指针之前保存当前结点的前驱结点，还要保存当前结点的后继结点，并在下一次反转之前更新这两个指针。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/</span><span class="token keyword">public</span> ListNode <span class="token function">ReverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">,</span> p <span class="token operator">=</span> head<span class="token punctuation">,</span> next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">printListFromTailToHead</span><span class="token punctuation">(</span>ListNode listNode<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h4><p>此题的难点在于单链表只有指向后继结点的指针，因此我们无法通过当前结点获取前驱结点，因此不要妄想先遍历一遍链表找到尾结点然后再依次从后往前打印。</p><h5 id="递归，简洁优雅"><a href="#递归，简洁优雅" class="headerlink" title="递归，简洁优雅"></a>递归，简洁优雅</h5><p>由于我们通常是从头到尾遍历链表的，而题目要求从尾到头打印结点，这与前进后出的逻辑是相符的，因此你可以使用一个栈来保存遍历时走过的结点，再通过后进先出的特性实现从尾到头打印结点，但是我们也可以利用递归来帮我们压栈，由于递归简洁不易出错，因此面试中能用递归尽量用递归：只要当前结点不为空，就递归遍历后继结点，当后继结点为空时，递归结束，在递归回溯时将“当前结点”依次添加到集合中</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/***    public class ListNode {*        int val;*        ListNode next = null;**        ListNode(int val) {*            this.val = val;*        }*    }**/</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">printListFromTailToHead</span><span class="token punctuation">(</span>ListNode listNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//input check</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>listNode <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">recursively</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> listNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recursively</span><span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">,</span> ListNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//base case</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//node not null</span>        <span class="token function">recursively</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="反转链表-1"><a href="#反转链表-1" class="headerlink" title="反转链表"></a>反转链表</h5><p>还有一种方法就是将链表指针都反转，这样将反转后的链表从头到尾打印就是结果了。需要注意的是我们不应该在访问用户数据时更改存储数据的结构，因此最后要记得反转回来：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">printListFromTailToHead</span><span class="token punctuation">(</span>ListNode listNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>listNode <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">unrecursively</span><span class="token punctuation">(</span>listNode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">unrecursively</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode newHead <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode p <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>newHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ListNode <span class="token function">reverse</span><span class="token punctuation">(</span>ListNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>    ListNode pre <span class="token operator">=</span> null<span class="token punctuation">,</span> cur <span class="token operator">=</span> node<span class="token punctuation">,</span> next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//save predecessor</span>        next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//reverse pointer</span>        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//move to next</span>        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//cur is null</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：面试时能用递归就用递归，当然了如果面试官就是要考查你的指针功底那你也能<code>just so so</code>不是</p></blockquote><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,2,7,1,5,3,8,6}，则重建二叉树并返回。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h4><p>先序序列的特点是第一个数就是根结点而后是左子树的先序序列和右子树的先序序列，而中序序列的特点是先是左子树的中序序列，然后是根结点，最后是右子树的中序序列。因此我们可以通过先序序列得到根结点，然后通过在中序序列中查找根结点的索引从而得到左子树和右子树的结点数。然后可以将两序列都一分为三，对于其中的根结点能够直接重建，然后根据对应子序列分别递归重建根结点的左子树和右子树。这是一个典型的将复杂问题划分成子问题分步解决的过程。</p><p><img src="https://ws2.sinaimg.cn/large/006zweohgy1fzb43dddiej30f70azjrt.jpg" alt="image"></p><p>递归体的定义，如上图先序序列的左子树序列是<code>2,3,4</code>对应下标<code>1,2,3</code>，而中序序列的左子树序列是<code>3,2,4</code>对应下标<code>0,1,2</code>，因此递归体接收的参数除了保存两个序列的数组之外，还需要指明需要递归重建的子序列分别在两个数组中的索引范围：<code>TreeNode rebuild(int[] pre, int i, int j, int[] in, int m, int n)</code>。然后递归体根据<code>pre</code>的<code>i~j</code>索引范围形成的先序序列和<code>in</code>的<code>m~n</code>索引范围形成的中序序列重建一棵树并返回根结点。</p><p>首先根结点就是先序序列的第一个数，即<code>pre[i]</code>，因此<code>TreeNode root = new TreeNode(pre[i])</code>可以直接确定，然后通过在<code>in</code>的<code>m~n</code>中查找出<code>pre[i]</code>的索引<code>index</code>可以求得左子树结点数<code>leftNodes = index - m</code>，右子树结点数<code>rightNodes = n - index</code>，如果左（右）子树结点数为0则表明左（右）子树为<code>null</code>，否则通过<code>root.left = rebuild(pre, i&#39; ,j&#39; ,in ,m&#39; ,n&#39;)</code>来重建左（右）子树即可。</p><p>这个题的难点也就在这里，即<code>i&#39;,j&#39;,m&#39;,n&#39;</code>的值的确定，笔者曾在此困惑许久，建议通过<code>leftNodes,rightNodes</code>和<code>i,j,m,n</code>来确定：（这个时候了前往不要在脑子里面想这些下标对应关系！！一定要在纸上画，确保准确性和概括性）</p><p><img src="https://wx3.sinaimg.cn/large/006zweohgy1fzbmo2052rj309v088dfy.jpg" alt="image"></p><p>于是容易得出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>leftNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> leftNodes<span class="token punctuation">,</span> in<span class="token punctuation">,</span> m<span class="token punctuation">,</span> m <span class="token operator">+</span> leftNodes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>rightNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i <span class="token operator">+</span> leftNodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> in<span class="token punctuation">,</span> n <span class="token operator">-</span> rightNodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>笔者曾以中序序列的根节点索引来确定<code>i&#39;,j&#39;,m&#39;,n&#39;</code>的对应关系写出如下<strong>错误代码</strong>：</p><p><img src="https://ws4.sinaimg.cn/large/006zweohgy1fzbmvcv9yej306b07adfv.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>leftNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> in<span class="token punctuation">,</span> m<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>rightNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> in<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种对应关系乍一看没错，但是不具有概括性（即囊括所有情况），比如对序列<code>2,3,4</code>、<code>3,2,4</code>重建时：</p><p><img src="https://wx1.sinaimg.cn/large/006zweohgy1fzbn2rz5n5j30cv07v3yh.jpg" alt="image"></p><p>你看这种情况，上述错误代码还适用吗？原因就在于<code>index</code>是在<code>in</code>的<code>m~n</code>中选取的，与数组<code>in</code>是绑定的，和<code>pre</code>没有直接的关系，因此如果用<code>index</code>来表示<code>i&#39;,j&#39;</code>自然是不合理的。</p><p>此题的正确完整代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">reConstructBinaryTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">==</span> null <span class="token operator">||</span> in <span class="token operator">==</span> null <span class="token operator">||</span> pre<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> in<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> pre<span class="token punctuation">.</span>length <span class="token operator">!=</span> in<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> in<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> in<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">rebuild</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> rootVal <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token function">findIndex</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">,</span> in<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> leftNodes <span class="token operator">=</span> index <span class="token operator">-</span> m<span class="token punctuation">,</span> rightNodes <span class="token operator">=</span> n <span class="token operator">-</span> index<span class="token punctuation">;</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>leftNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> leftNodes<span class="token punctuation">,</span> in<span class="token punctuation">,</span> m<span class="token punctuation">,</span> m <span class="token operator">+</span> leftNodes <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rightNodes <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">rebuild</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> i <span class="token operator">+</span> leftNodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> in<span class="token punctuation">,</span> n <span class="token operator">-</span> rightNodes <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> from <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> to <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：</p><ol><li>对于复杂问题，一定要划分成若干子问题，逐一求解。比如二叉树问题，我们通常将其划分成头结点、左子树、右子树。</li><li>对于递归过程的参数对应关系，尽量使用和数据样本本身没有直接关系的变量来表示。比如此题应该选取<code>leftNodes</code>和<code>rightNodes</code>来计算<code>i&#39;,j&#39;,m&#39;,n&#39;</code>而不应该使用头结点在中序序列的下标<code>index</code>（它和<code>in</code>是绑定的，那么可能对<code>pre</code>就不适用了）。</li></ol></blockquote><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><pre class="line-numbers language-java"><code class="language-java">Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h4><p>这道题只要记住以下几点即可：</p><ol><li>一个栈（如<code>stack1</code>）只能用来存，另一个栈（如<code>stack2</code>）只能用来取</li><li>当取元素时首先检查<code>stack2</code>是否为空，如果不空直接<code>stack2.pop()</code>，否则将<code>stack1</code>中的元素<strong>全部倒入</strong><code>stack2</code>，如果倒入之后<code>stack2</code>仍为空则需要抛异常，否则<code>stack2.pop()</code>。</li></ol><p>代码示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Stack<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"no more element！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：只要取元素的栈不为空，取元素时直接弹出其栈顶元素即可，只有当其为空时才考虑将存元素的栈倒入进来，并且要一次性倒完。</p></blockquote><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的<strong>若干</strong>个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个<strong>非减排序</strong>的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minNumberInRotateArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h4><p>此题需先认真审题：</p><ol><li>若干，涵盖了一个元素都不搬的情况，此时数组是一个非减排序序列，因此首元素就是数组的最小元素。</li><li>非减排序，并不代表是递增的，可能会出现若干相邻元素相同的情况，极端的例子是整个数组的所有元素都相同</li></ol><p>由此不难得出如下<code>input check</code>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minNumberInRotateArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//if only one element or no rotate</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//TODO</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的<code>arr[0] &lt; arr[arr.length - 1]</code>不能写成<code>arr[0] &lt;= arr[arr.length - 1]</code>，比如可能会有<code>[1,2,3,3,4] -&gt; [3,4,1,2,3]</code> 的情况，这时你不能返回<code>arr[0]=3</code>。</p><p>如果走到了程序中的<code>TODO</code>，就可以考虑普遍情况下的推敲，数组可以被分成两部分：大于等于<code>arr[0]</code>的左半部分和小于等于<code>arr[arr.length - 1]</code>右半部分，我们不妨借助两个指针从数组的头、尾向中间靠近，这样就能利用二分的思想快速移动指针从而淘汰一些不在考虑范围之内的数。</p><p><img src="https://wx2.sinaimg.cn/large/006zweohgy1fzbpp2dx1dj30a0063aa1.jpg" alt="image"></p><p>如图，我们不能直接通过<code>arr[mid]</code>和<code>arr[l]</code>（或<code>arr[r]</code>）的比较（<code>arr[mid] &gt;= arr[l]</code>）来决定移动<code>l</code>还是<code>r</code>到<code>mid</code>上，因为数组可能存在若干相同且相邻的数，因此我们还需要加上一个限制条件：<code>arr[l + 1] &gt;= arr[l] &amp;&amp; arr[mid] &gt;= arr[l]</code>（对于<code>r</code>来说则是<code>arr[r - 1] &lt;= arr[r] &amp;&amp; arr[mid] &lt;= arr[r]</code>），即当左半部分（右半部分）不止一个数时，我们才可能去移动<code>l</code>（<code>r</code>）指针。完整代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minNumberInRotateArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//input check</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//if only one element or no rotate</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//has rotate, left part is big than right part</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mid<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//l~r has more than 3 elements</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> r <span class="token operator">-</span> l <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//r-l >= 2    ->    mid > l</span>            mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                l <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：审题时要充分考虑数据样本的极端情况，以写出鲁棒性较强的代码。</p></blockquote><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h4><h5 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h5><p>对于公式<code>f(n) = f(n-1) + f(n-2)</code>，明显就是一个递归调用，因此根据<code>f(0) = 0</code>和<code>f(1) = 1</code>我们不难写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>在上述递归过程中，你会发现有很多计算过程是重复的：</p><p><img src="https://ws1.sinaimg.cn/large/006zweohgy1fzbq4avws3j30b507b74a.jpg" alt="image"></p><p><strong>动态规划就在使用递归调用自上而下分析过程中发现有很多重复计算的子过程，于是采用自下而上的方式将每个子状态缓存下来，这样对于上层而言只有当需要的子过程结果不在缓存中时才会计算一次，因此每个子过程都只会被计算一次</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//n1 -> f(n-1), n2 -> f(n-2)</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从f(2)开始算起</span>    <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token operator">++</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//每次计算后更新缓存，当然你也可以使用一个一维数组保存每次的计算结果，只额外空间复杂度就变为O(n)了</span>        res <span class="token operator">=</span> n1 <span class="token operator">+</span> n2<span class="token punctuation">;</span>        n2 <span class="token operator">=</span> n1<span class="token punctuation">;</span>        n1 <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码很多人都能写出来，只是没有意识到这就是动态规划。</p><blockquote><p>总结：当你自上而下分析递归时发现有很多子过程被重复计算，那么就应该考虑能否通过自下而上将每个子过程的计算结果缓存下来。</p></blockquote><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h4><h5 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h5><p>将复杂问题分解：复杂问题就是不断地将<code>target</code>减1或减2（对应跳一级和跳两级台阶）直到<code>target</code>变为1或2（对应只剩下一层或两层台阶）时我们能够很容易地得出结果。因此对于当前的青蛙而言，它能够选择的就是跳一级或跳二级，剩下的台阶有多少种跳法交给子过程来解决：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//base case</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">JumpFloor</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你会发现这其实就是一个斐波那契数列，只不过是从<code>f(1) = 1,f(2) = 2</code>开始的斐波那契数列罢了。自然你也应该能够写出动态规划版本。</p><h4 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h4><h5 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h5><p>本质上还是分解，只不过上一个是分解成两步，而这个是分解成n步：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloorII</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//base case，当target=0时表示某个分解分支跳完了所有台阶，这个分支就是一种跳法</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//本过程要收集的跳法的总数</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//本次选择，选择跳i阶台阶，剩下的台阶交给子过程，每个选择就代表一个分解分支</span>        res <span class="token operator">+=</span> <span class="token function">JumpFloorII</span><span class="token punctuation">(</span>target <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h5><p>这个动态规划就有一点难度了，<strong>首先我们要确定缓存目标</strong>，斐波那契数列中由于<code>f(n)</code>只依赖于<code>f(n-1)</code>和<code>f(n-2)</code>因此我们仅用两个缓存变量实现了动态规划，但是这里<code>f(n)</code>依赖的是<code>f(0),f(1),f(2),...,f(n-1)</code>，因此我们需要通过长度量级为<code>n</code>的表缓存前<code>n</code>个状态（<code>int arr[] = new int[target + 1]</code>，<code>arr[target]</code>表示<code>f(n)</code>）。<strong>然后根据递归版本（通常是<code>base case</code>）确定哪些状态的值是可以直接确定的</strong>，比如由<code>if(target == 0){ return 1 }</code>可知<code>arr[0] = 1</code>，从<code>f(N = 1)</code>开始的所有状态都需要依赖之前（<code>f(n &lt; N)</code>）的所有状态：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> target <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res <span class="token operator">+=</span> <span class="token function">JumpFloorII</span><span class="token punctuation">(</span>target <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此我们可以据此自下而上计算出每个子状态的值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloorII</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这仍不是最优解，因为观察循环体你会发现，每次<code>f(n)</code>的计算都要从<code>f(0)</code>累加到<code>f(n-1)</code>，我们完全可以将这个累加值缓存起来<code>preSum</code>，每计算出一次<code>f(N)</code>之后都将缓存更新为<code>preSum += f(N)</code>。如此得到最优解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">JumpFloorII</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> preSum <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">;</span>        preSum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">RectCover</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h4><h5 id="递归版本-2"><a href="#递归版本-2" class="headerlink" title="递归版本"></a>递归版本</h5><p>有了之前的历练，我们能很快的写出递归版本：先竖着放一个或者先横着放两个，剩下的交给递归处理：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//target 大矩形的边长，也是剩余小矩形的个数</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">RectCover</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> target <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">RectCover</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">RectCover</span><span class="token punctuation">(</span>target <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h5><p>这仍然是个以<code>f(1)=1,f(2)=2</code>开头的斐波那契数列：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//target 大矩形的边长，也是剩余小矩形的个数</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">RectCover</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> target <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//n_1->f(n-1), n_2->f(n-2)，从f(N=3)开始算起</span>    <span class="token keyword">int</span> n_1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> n_2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> N <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token operator">++</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">=</span> n_1 <span class="token operator">+</span> n_2<span class="token punctuation">;</span>        n_2 <span class="token operator">=</span> n_1<span class="token punctuation">;</span>        n_1 <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">NumberOf1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h4><p>题目已经给我们降低了难度：负数用补码（取反加1）表示表明输入的参数为均为正数，我们只需统计其二进制表示中1的个数、运算时只考虑无符号移位即可。</p><p>典型的判断某个二进制位上是否为1的方法是将该二进制数右移至该二进制位为最低位然后与1相与<code>&amp;</code>，由于1的二进制表示中只有最低位为1其余位均为0，因此相与后的结果与该二进制位上的数相同。据此不难写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">NumberOf1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然了，还有一种比较秀的解法就是利用<code>n = n &amp; (n - 1)</code>将<code>n</code>的二进制位中为1的最低位置为0（只要<code>n</code>不为0就说明含有二进位制为1的位，如此这样的操作能做多少次就说明有多少个二进制位为1的位）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">NumberOf1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        n <span class="token operator">&amp;=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">Power</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exponent<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h4><p>这是一道充满危险色彩的题，求职者可能会内心窃喜不假思索的写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">Power</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> exponent <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">*=</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是你有没有想过底数<code>base</code>和幂<code>exponent</code>都是可正、可负、可为0的。如果幂为负数，那么底数就不能为0，否则应该抛出算术异常：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//是否是负数</span><span class="token keyword">boolean</span> minus <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果存在分母</span><span class="token keyword">if</span><span class="token punctuation">(</span>exponent <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    minus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    exponent <span class="token operator">=</span> <span class="token operator">-</span>exponent<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"/ by zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果幂为0，那么根据任何不为0的数的0次方为1，0的0次方未定义，应该有如下判断：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//如果指数为0</span><span class="token keyword">if</span><span class="token punctuation">(</span>exponent <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>base <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"0^0 is undefined"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>剩下的就是计算乘方结果，但是不要忘了如果幂为负需要将结果取倒数：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指数不为0且分母也不为0，正常计算并返回整数或分数</span><span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> exponent <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    res <span class="token operator">*=</span> base<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>minus<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">/</span>res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也许你还可以锦上添花为幂乘方的计算引入二分计算（当幂为偶数时<code>2^n = 2^(n/2) * 2^(n/2)</code>）：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">binaryPower</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>exp <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    res <span class="token operator">*=</span> <span class="token punctuation">(</span><span class="token function">binaryPower</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exp<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">binaryPower</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exp<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> exp <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> res <span class="token operator">:</span> res <span class="token operator">*</span> base<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的<strong>相对位置不变</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reOrderArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h4><p>读题之后发现这个跟快排的<code>partition</code>思路很像，都是选取一个比较基准将数组分成两部分，当然你也可以以<code>arr[i] % 2 == 0</code>为基准将奇数放前半部分，将偶数放有半部分，但是虽然只需<code>O(n)</code>的时间复杂度但不能保证调整后奇数之间、偶数之间的相对位置：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reOrderArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> odd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>odd<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>涉及到排序稳定性，我们自然能够想到插入排序，从数组的第二个元素开始向后依次确定每个元素应处的位置，确定的逻辑是：将该数与前一个数比较，如果比前一个数小则与前一个数交换位置并在交换位置后继续与前一个数比较直到前一个数小于等于该数或者已达数组首部停止。</p><p>此题不过是将比较的逻辑由数值的大小改为：当前的数是否是奇数并且前一个数是偶数，是则递归向前交换位置。代码示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reOrderArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> odd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">FindKthToTail</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-14"><a href="#解析-14" class="headerlink" title="解析"></a>解析</h4><p><strong>倒数</strong>，这又是一个从尾到头的遍历逻辑，而链表对从尾到头遍历是敏感的，前面我们有通过压栈/递归、反转链表的方式实现这个遍历逻辑，自然对于此题同样适用，但是那样未免太麻烦了，我们可以通过两个间距为（k-1）个结点的链表指针来达到此目的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">FindKthToTail</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    ListNode p1 <span class="token operator">=</span> tmp<span class="token punctuation">,</span> p2 <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p1<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        k<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//length &lt; k</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tmp <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//help gc</span>    <span class="token keyword">return</span> p2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里使用了一个技巧，就是创建一个临时结点<code>tmp</code>作为两个指针的初始指向，以模拟<code>p1</code>先走<code>k</code>步之后，<code>p2</code>才开始走，没走时停留在初始位置的逻辑，有利于帮我们梳理指针在对应位置上的意义，这样当<code>p1</code>走到头时（<code>p1=null</code>），<code>p2</code>就是倒数第<code>k</code>个结点。</p><p>这里还有一个坑就是，笔者层试图为了简化代码将上述的<code>9 ~ 12</code>行写成如下偷懒模式而导致排错许久：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p1<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原因是将<code>k--</code>写在<code>while()</code>中，无论判断是否通过都会执行<code>k = k - 1</code>，因此代码总是会在<code>if(k != 0)</code>处返回<code>null</code>，希望读者不要和笔者一样粗心。</p><blockquote><p>总结：当遇到复杂的指针操作时，我们不妨试图多引入几个指针或者临时结点，以方便梳理我们的思路，加强代码的逻辑化，这些空间复杂度<code>O(1)</code>的操作通常也不会影响性能。</p></blockquote><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">Merge</span><span class="token punctuation">(</span>ListNode list1<span class="token punctuation">,</span>ListNode list2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-15"><a href="#解析-15" class="headerlink" title="解析"></a>解析</h4><p><img src="https://ws3.sinaimg.cn/large/006zweohgy1fzbx9j54uuj30jg0ak3yz.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">Merge</span><span class="token punctuation">(</span>ListNode list1<span class="token punctuation">,</span>ListNode list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list1 <span class="token operator">==</span> null <span class="token operator">||</span> list2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> list1 <span class="token operator">==</span> null <span class="token operator">?</span> list2 <span class="token operator">:</span> list1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode newHead <span class="token operator">=</span> list1<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> list2<span class="token punctuation">.</span>val <span class="token operator">?</span> list1 <span class="token operator">:</span> list2<span class="token punctuation">;</span>    ListNode p1 <span class="token operator">=</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> list1<span class="token punctuation">)</span> <span class="token operator">?</span> list1<span class="token punctuation">.</span>next <span class="token operator">:</span> list1<span class="token punctuation">;</span>    ListNode p2 <span class="token operator">=</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> list2<span class="token punctuation">)</span> <span class="token operator">?</span> list2<span class="token punctuation">.</span>next <span class="token operator">:</span> list2<span class="token punctuation">;</span>    ListNode p <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> p2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>            p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>            p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p2<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**public class TreeNode {    int val = 0;    TreeNode left = null;    TreeNode right = null;    public TreeNode(int val) {        this.val = val;    }}*/</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>TreeNode root1<span class="token punctuation">,</span>TreeNode root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> null <span class="token operator">||</span> root2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-16"><a href="#解析-16" class="headerlink" title="解析"></a>解析</h4><p>这是一道典型的分解求解的复杂问题。典型的二叉树分解：遍历头结点、遍历左子树、遍历右子树。首先按照<code>root1</code>和<code>root2</code>的值是否相等划分为两种情况：</p><ol><li>两个头结点的值相等，并且<code>root2.left</code>也是<code>roo1.left</code>的子结构（递归）、<code>root2.right</code>也是<code>root1.right</code>的子结构（递归），那么可返回<code>true</code>。</li><li>否则，要看只有当<code>root2</code>为<code>root1.left</code>的子结构或者<code>root2</code>为<code>root1.right</code>的子结构时，才能返回<code>true</code></li></ol><p>据上述两点很容易得出如下递归逻辑：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">==</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来确定递归的终止条件，如果某个子过程<code>root2=null</code>那么说明在自上而下的比较过程中<code>root2</code>的结点已被罗列比较完了，这时无论<code>root1</code>是否为<code>null</code>，该子过程都应该返回<code>true</code>：</p><p><img src="https://ws4.sinaimg.cn/large/006zweohgy1fzbyis1e3oj30dg04qaa5.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>root2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是如果<code>root2 != null</code>而<code>root1 = null</code>，则应返回<code>false</code></p><p><img src="https://wx3.sinaimg.cn/large/006zweohgy1fzbym9fv0bj30bv05974e.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>完整代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">HasSubtree</span><span class="token punctuation">(</span>TreeNode root1<span class="token punctuation">,</span>TreeNode root2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> null <span class="token operator">||</span> root2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>TreeNode root1<span class="token punctuation">,</span> TreeNode root2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>val <span class="token operator">==</span> root2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">process</span><span class="token punctuation">(</span>root1<span class="token punctuation">.</span>right<span class="token punctuation">,</span> root2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><img src="https://ws1.sinaimg.cn/large/006zweohgy1fzbyup8oq3j306b08kjra.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-17"><a href="#解析-17" class="headerlink" title="解析"></a>解析</h4><p>由图可知获取二叉树的镜像就是将原树的每个结点的左右孩子交换一下位置（这个规律一定要会找），也就是说我们只需遍历每个结点并交换<code>left,right</code>的引用指向就可以了，而我们有成熟的先序遍历：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Mirror</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode tmp <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token function">Mirror</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Mirror</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">printMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-18"><a href="#解析-18" class="headerlink" title="解析"></a>解析</h4><p><img src="https://wx3.sinaimg.cn/large/006zweohgy1fzbzo7qyu0j30gr093q3a.jpg" alt="image"></p><p>只要分析清楚了打印思路（左上角和右下角即可确定一条打印轨迹）后，此题主要考查条件控制的把握。只要给我一个左上角的点<code>(i,j)</code>和右下角的点<code>(m,n)</code>，就可以将这一圈的打印分解为四步：</p><p><img src="https://ws2.sinaimg.cn/large/006zweohgy1fzc01b7bpij309107hweh.jpg" alt="image"></p><p>但是如果左上角和右下角的点在一行或一列上那就没必要分解，直接打印改行或该列即可，打印的逻辑如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">||</span> j <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//only one while will be execute</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> i<span class="token punctuation">,</span> q <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//q == n</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//p == m</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">></span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//q == j</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">></span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//p == i</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着我们将每个圈的左上角和右下角传入该函数即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">printMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printEdge</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">,</span> m<span class="token operator">--</span><span class="token punctuation">,</span> n<span class="token operator">--</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-19"><a href="#解析-19" class="headerlink" title="解析"></a>解析</h4><p>最直接的思路是使用一个变量保存栈中现有元素的最小值，但这只对只存不取的栈有效，当弹出的值不是最小值时还没什么影响，但当弹出最小值后我们就无法获取当前栈中的最小值。解决思路是使用一个最小值栈，栈顶总是保存当前栈中的最小值，每次数据栈存入数据时最小值栈就要相应的将存入后的最小值压入栈顶：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> dataStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    dataStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>minStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> minStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>        minStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>minStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        minStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dataStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        dataStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dataStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> dataStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dataStack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> minStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的<strong>所有数字均不相等</strong>。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的<strong>长度是相等</strong>的）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">IsPopOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-20"><a href="#解析-20" class="headerlink" title="解析"></a>解析</h4><p>可以使用两个指针<code>i,j</code>，初始时<code>i</code>指向压入序列的第一个，<code>j</code>指向弹出序列的第一个，试图将压入序列按照顺序压入栈中：</p><ol><li>如果<code>arr1[i] != arr2[j]</code>，那么将<code>arr1[i]</code>压入栈中并后移<code>i</code>（表示<code>arr1[i]</code>还没到该它弹出的时刻）</li><li>如果某次后移<code>i</code>之后发现<code>arr1[i] == arr2[j]</code>，那么说明此刻的<code>arr1[i]</code>被压入后应该被立即弹出才会产生给定的弹出序列，于是不压入<code>arr1[i]</code>（表示压入并弹出了）并后移<code>i</code>，<code>j</code>也要后移（表示弹出序列的<code>arr2[j]</code>记录已产生，接着产生或许的弹出记录即可）。</li><li>因为步骤2和3都会后移<code>i</code>，因此循环的终止条件是<code>i</code>到达<code>arr1.length</code>，此时若栈中还有元素，那么从栈顶到栈底形成的序列必须与<code>arr2</code>中<code>j</code>之后的序列相同才能返回<code>true</code>。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">IsPopOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//input check</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr1 <span class="token operator">==</span> null <span class="token operator">||</span> arr2 <span class="token operator">==</span> null <span class="token operator">||</span> arr1<span class="token punctuation">.</span>length <span class="token operator">!=</span> arr2<span class="token punctuation">.</span>length <span class="token operator">||</span> arr1<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> arr2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">PrintFromTopToBottom</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-21"><a href="#解析-21" class="headerlink" title="解析"></a>解析</h4><p>使用一个队列来保存当前遍历结点的孩子结点，首先将根节点加入队列中，然后进行队列非空循环：</p><ol><li>从队列头取出一个结点，将该结点的值打印</li><li>如果取出的结点左孩子不空，则将其左孩子放入队列尾部</li><li>如果取出的结点右孩子不空，则将其右孩子放入队列尾部</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">PrintFromTopToBottom</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">VerifySquenceOfBST</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> sequence<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-22"><a href="#解析-22" class="headerlink" title="解析"></a>解析</h4><p>对于二叉树的后序序列，我们能够确定最后一个数就是根结点，还能确定的是前一半部分是左子树的后序序列，后一部分是右子树的后序序列。</p><p>遇到这种复杂问题，我们仍能采用三步走战略（根结点、左子树、右子树）：</p><ol><li>如果当前根结点的左子树<strong>是BST</strong>且其右子树也是BST，那么才可能是BST</li><li>在1的条件下，如果左子树的<strong>最大值</strong>小于根结点且右子树的<strong>最小值</strong>大于根结点，那么这棵树就是BST</li></ol><p>据此我们需要定义一个递归体，该递归体需要收集的信息如下：下层需要向我返回其最大值、最小值、以及是否是BST</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token punctuation">{</span>    <span class="token keyword">boolean</span> isBST<span class="token punctuation">;</span>    <span class="token keyword">int</span> max<span class="token punctuation">;</span>    <span class="token keyword">int</span> min<span class="token punctuation">;</span>    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isBST<span class="token punctuation">,</span> <span class="token keyword">int</span> max<span class="token punctuation">,</span> <span class="token keyword">int</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isBST <span class="token operator">=</span> isBST<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>max <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>min <span class="token operator">=</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归体的定义如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Info <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"invalid input"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//base case : only one node</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> root <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>    Info left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//not exist left child</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">></span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        right <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span>root <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>min <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>isBST<span class="token punctuation">,</span>                         Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> right<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> right<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//not exist right child</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>        left <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span>root <span class="token operator">></span> left<span class="token punctuation">.</span>max <span class="token operator">&amp;&amp;</span> left<span class="token punctuation">.</span>isBST<span class="token punctuation">,</span>                         Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> left<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> left<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>r <span class="token operator">></span> l <span class="token operator">&amp;&amp;</span> r <span class="token operator">-</span> l <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>            r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            l <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    left <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>    right <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> r<span class="token punctuation">,</span> end <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>isBST <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>isBST <span class="token operator">&amp;&amp;</span> root <span class="token operator">></span> left<span class="token punctuation">.</span>max <span class="token operator">&amp;&amp;</span> root <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>min<span class="token punctuation">,</span>                     right<span class="token punctuation">.</span>max<span class="token punctuation">,</span> left<span class="token punctuation">.</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>总结：二叉树相关的信息收集问题分步走：</p><ol><li>分析当前状态需要收集的信息</li><li>根据下层传来的信息加工出当前状态的信息</li><li>确定递归终止条件</li></ol></blockquote><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下<strong>一直到叶结点</strong>所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">FindPath</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-23"><a href="#解析-23" class="headerlink" title="解析"></a>解析</h4><p>审题可知，我们需要有一个自上而下从根结点到每个叶子结点的遍历思路，而先序遍历刚好可以拿来用，我们只需在来到当前结点时将当前结点值加入到栈中，在离开当前结点时再将栈中保存的当前结点的值弹出即可使用栈模拟保存自上而下经过的结点，从而实现在来到每个叶子结点时只需判断栈中数值之和是否为<code>target</code>即可。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">FindPath</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span>                      ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum <span class="token operator">+=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//leaf node</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> sum <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        one<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> target<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> stack<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> target<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    sum <span class="token operator">-=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*public class RandomListNode {    int label;    RandomListNode next = null;    RandomListNode random = null;    RandomListNode(int label) {        this.label = label;    }}*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> RandomListNode <span class="token function">Clone</span><span class="token punctuation">(</span>RandomListNode pHead<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-24"><a href="#解析-24" class="headerlink" title="解析"></a>解析</h4><p>此题主要的难点在于<code>random</code>指针的处理。</p><h5 id="方法一：使用哈希表，额外空间O-n"><a href="#方法一：使用哈希表，额外空间O-n" class="headerlink" title="方法一：使用哈希表，额外空间O(n)"></a>方法一：使用哈希表，额外空间O(n)</h5><p>可以将链表中的结点都复制一份，用一个哈希表来保存，<code>key</code>是源结点，<code>value</code>就是副本结点，然后遍历<code>key</code>取出每个对应的<code>value</code>将副本结点的<code>next</code>指针和<code>random</code>指针设置好：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> RandomListNode <span class="token function">Clone</span><span class="token punctuation">(</span>RandomListNode pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pHead <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    HashMap<span class="token operator">&lt;</span>RandomListNode<span class="token punctuation">,</span> RandomListNode<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RandomListNode p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//copy</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        RandomListNode cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomListNode</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> cp<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//link</span>    p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        RandomListNode cp <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        cp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        cp<span class="token punctuation">.</span>random <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>random <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>random<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pHead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方法二：追加结点，额外空间O-1"><a href="#方法二：追加结点，额外空间O-1" class="headerlink" title="方法二：追加结点，额外空间O(1)"></a>方法二：追加结点，额外空间O(1)</h5><p>首先将每个结点复制一份并插入到对应结点之后，然后遍历链表将副本结点的<code>random</code>指针设置好，最后将源结点和副本结点分离成两个链表</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> RandomListNode <span class="token function">Clone</span><span class="token punctuation">(</span>RandomListNode pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pHead <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    RandomListNode p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        RandomListNode cp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomListNode</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>label<span class="token punctuation">)</span><span class="token punctuation">;</span>        cp<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> cp<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//more than two node</span>    <span class="token comment" spellcheck="true">//link random pointer</span>    p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    RandomListNode cp<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        cp <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cp<span class="token punctuation">.</span>random <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>random <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> p<span class="token punctuation">.</span>random<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//split source and copy</span>    p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    RandomListNode newHead <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p != null -> p.next != null</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        cp <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        cp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><h4 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">Convert</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解析-25"><a href="#解析-25" class="headerlink" title="解析"></a>解析</h4><p>典型的二叉树分解问题，我们可以定义一个黑盒<code>transform</code>，它的目的是将二叉树转换成双向链表，那么对于一个当前结点<code>root</code>，首先将其前驱结点（BST中前驱结点指中序序列的前一个数值，也就是当前结点的左子树上最右的结点，如果左子树为空则没有前驱结点）和后继结点（当前结点的右子树上的最左结点，如果右子树为空则没有后继结点），然后使用黑盒<code>transform</code>将左子树和右子树转换成双向链表，最后将当前结点和左子树形成的链表链起来（通过之前保存的前驱结点）和右子树形成的链表链起来（通过之前保存的后继结点），整棵树的转换完毕。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeNode <span class="token function">Convert</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//head is the most left node</span>    TreeNode head <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        head <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">transform</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//transform a tree to a double-link list</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transform</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode pre <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> next <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> next<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        next <span class="token operator">=</span> next<span class="token punctuation">.</span>left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">transform</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">transform</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//asume the left and right has transformed and what's remaining is link the root</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> pre<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        pre<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        next<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h3><h4 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h4 id="解析-26"><a href="#解析-26" class="headerlink" title="解析"></a>解析</h4><p>定义一个递归体<code>generate(char[] arr, int index, TreeSet&lt;String&gt; res)</code>，其中<code>char[] arr</code>和<code>index</code>组合表示上层状态给当前状态传递的信息，即<code>arr</code>中<code>0 ~ index-1</code>是已生成好的串，现在你（当前状态）要确定<code>index</code>位置上应该放什么字符（你可以从<code>index ~ arr.length - 1</code>上任选一个字符），然后将<code>index + 1</code>应该放什么字符递归交给子过程处理，当某个状态要确定<code>arr.length</code>上应该放什么字符时说明<code>0 ~ arr.length-1</code>位置上的字符已经生成好了，因此递归终止，将生成好的字符串记录下来（这里由于要求不能重复且按字典序排列，因此我们可以使用JDK中红黑树的实现<code>TreeSet</code>来做容器）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">Permutation</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeSet<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">generate</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> set<span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> TreeSet<span class="token operator">&lt;</span>String<span class="token operator">></span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">generate</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：上述代码的第<code>19</code>行有个坑，笔者曾因忘记写第19行而排错许久，由于你任选一个<code>index ~ arr.length - 1</code>位置上的字符与<code>index</code>位置上的交换并将交换生成的结果交给了子过程（第<code>17,18</code>行），但你不应该影响后续选取其他字符放到<code>index</code>位置上而形成的结果，因此需要再交换回来（第<code>19</code>行）</p></blockquote><h3 id="数组中出现次数超过一半的数"><a href="#数组中出现次数超过一半的数" class="headerlink" title="数组中出现次数超过一半的数"></a>数组中出现次数超过一半的数</h3><h4 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">MoreThanHalfNum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解析-27"><a href="#解析-27" class="headerlink" title="解析"></a>解析</h4><h5 id="方法一：基于partition查找数组中第k大的数"><a href="#方法一：基于partition查找数组中第k大的数" class="headerlink" title="方法一：基于partition查找数组中第k大的数"></a>方法一：基于partition查找数组中第k大的数</h5><p>如果我们将数组排序，最快也要<code>O(nlogn)</code>，排序后的中位数自然就是出现次数超过长度一半的数。</p><p>我们知道快排的<code>partition</code>操作能够将数组按照一个基准划分成小于部分和大于等于部分并返回这个基准在数组中的下标，虽然一次<code>partition</code>并不能使数组整体有序，但是能够返回随机选择的数在<code>partition</code>之后的下标<code>index</code>，这个下标标识了它是第<code>index</code>大的数，这也意味着我们要求数组中第<code>k</code>大的数不一定要求数组整体有序。</p><p>于是我们在首次对整个数组<code>partition</code>之后将返回的<code>index</code>与<code>n/2</code>进行比较，并调整下一次<code>partition</code>的范围直到<code>index = n/2</code>为止我们就找到了。</p><p>这个时间复杂度需要使用<code>Master</code>公式计算（计算过程参见 <a href="http://www.zhenganwen.top/62859a9a.html#Master%E5%85%AC%E5%BC%8F），**使用`partition`查找数组中第k大的数时间复杂度为`O(n)`**，最后不要忘了验证一下`index" target="_blank" rel="noopener">http://www.zhenganwen.top/62859a9a.html#Master%E5%85%AC%E5%BC%8F），**使用`partition`查找数组中第k大的数时间复杂度为`O(n)`**，最后不要忘了验证一下`index</a> = n/2`上的数出现的次数是否超过了长度的一半。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">MoreThanHalfNum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> half <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 0 &lt;= half &lt;= arr.length - 1</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index <span class="token operator">!=</span> half<span class="token punctuation">)</span><span class="token punctuation">{</span>        index <span class="token operator">=</span> index <span class="token operator">></span> k <span class="token operator">?</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>count <span class="token operator">:</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> random <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> random<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> small <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>small<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>small<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> small<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><ol><li>使用一个<code>target</code>记录一个数，并使用<code>count</code>记录它出现的次数</li><li>初始时<code>target = arr[0]</code>，<code>count = 1</code>，表示<code>arr[0]</code>出现了1次</li><li>从第二个元素开始遍历数组，如果遇到的数不等于<code>target</code>就将<code>count</code>减1，否则加1</li><li>如果遍历到某个数时，<code>count</code>为0了，那么就将<code>target</code>设置为该数，并将<code>count</code>置1，继续向后遍历</li></ol><p>如果存在出现次数超过一半的数，那么必定是<code>target</code>最后一次被设置时的数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">MoreThanHalfNum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//此题需要抓住出现次数超过数组长度的一半这个点来想</span>    <span class="token comment" spellcheck="true">//使用一个计数器，如果这个数出现一次就自增，否则自减，如果自减为0则更新被记录的数</span>    <span class="token comment" spellcheck="true">//如果存在出现次数大于一半的数，那么最后一次被记录的数就是所求之数</span>    <span class="token keyword">int</span> target <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            target <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            count <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>count <span class="token operator">:</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//不要忘了验证！！！</span>    count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>count <span class="token operator">:</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>count <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> target <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><h4 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">GetLeastNumbers_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-28"><a href="#解析-28" class="headerlink" title="解析"></a>解析</h4><p>与上一题的求数组第k大的数如出一辙，如果某次<code>partition</code>之后你得到了第k大的数的下标，那么根据<code>partitin</code>规则该下标左边的数均比该下标上的数小，最小的k个数自然就是此时的<code>0~k-1</code>下标上的数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">GetLeastNumbers_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//throw new IllegalArgumentException();</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index <span class="token operator">!=</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>        index <span class="token operator">=</span> index <span class="token operator">></span> k <span class="token operator">?</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> random <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> random<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> small <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>small<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>small<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> small<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><h4 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">FindGreatestSumOfSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-29"><a href="#解析-29" class="headerlink" title="解析"></a>解析</h4><h5 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h5><p>暴力法是找出所有子数组，然后遍历求和，时间复杂度为<code>O(n^3)</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">FindGreatestSumOfSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//start</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//end</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//sum</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j <span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h5><p>使用一个<code>sum</code>记录累加和，初始时为0，遍历数组：</p><ol><li>如果遍历到<code>i</code>时，发现<code>sum</code>小于0，那么丢弃这个累加和，将<code>sum</code>重置为<code>0</code></li><li>将当前元素累加到<code>sum</code>上，并更新最大和<code>maxSum</code></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">FindGreatestSumOfSubArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sum <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="整数中1出现的次数（从1到n整数中1出现的次数）"></a>整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h4><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><h4 id="解析-30"><a href="#解析-30" class="headerlink" title="解析"></a>解析</h4><h5 id="遍历一遍不就完了吗"><a href="#遍历一遍不就完了吗" class="headerlink" title="遍历一遍不就完了吗"></a>遍历一遍不就完了吗</h5><p>当然，你可从1遍历到n，然后将当前被遍历的到的数中1出现的次数累加到结果中可以很容易地写出如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">NumberOf1Between1AndN_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">+=</span> <span class="token function">count</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取个位</span>        count <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>count <span class="token operator">:</span> count<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//去掉个位</span>        n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但n多大就会循环多少次，这并不是面试官所期待的，这时我们就需要找规律看是否有捷径可走</p><h5 id="不用数我也知道"><a href="#不用数我也知道" class="headerlink" title="不用数我也知道"></a>不用数我也知道</h5><p>以<code>51234</code>这个数为例，我们可以先将<code>51234</code>划分成<code>1~1234</code>（去掉最高位）和<code>1235~51234</code>两部分来求解。下面先分析<code>1235~51234</code>这个区间的结果：</p><ol><li><p>所有的数中，1在最高位（万位）出现的次数</p><p>对于<code>1235~51234</code>，最高位为1时（即万位为1时）的数有<code>10000~19999</code>这10000个数，也就是说1在最高位（万位）出现的次数为10000，因此我们可以得出结论：如果最高位大于1，那么在最高位上1出现的次数为最高位对应的单位（本例中为一万次）；但如果最高位为1，比如<code>1235~11234</code>，那么次数就为去掉最高位之后的数了，<code>11234</code>去掉最高位后是<code>1234</code>，即1在最高位上出现的次数为<code>1234</code></p></li><li><p>所有的数中，1在非最高位上出现的次数</p><p>我们可以进一步将<code>1235~51234</code>按照最高位的单位划分成4个区间（能划分成几个区间由最高位上的数决定，这里最高位为5，所以能划分5个大小为一万子区间）：</p><ul><li><code>1235~11234</code></li><li><code>11235~21234</code></li><li><code>21235~31234</code></li><li><code>31235~41234</code></li><li><code>41235~51234</code></li></ul><p>而每个数不考虑万位（因为1在万位出现的总次数在步骤1中已统计好了），其余四位（个、十、百、千）取一位放1（比如千位），剩下的3位从<code>0~9</code>中任意选（<code>10 * 10 * 10</code>），那么仅统计1在千位上出现的次数之和就是：<code>5(子区间数) * 10 * 10 * 10</code>，还有百位、十位、个位，结果为：<code>4 * 10 * 10 * 10 * 5</code>。</p><p>因此非高位上1出现的总次数的计算通式为：<code>(n-1) * 10^(n-2) * 十进制最高位上的数</code>（其中<code>n</code>为十进制的总位数）</p><p>于是<code>1235 ~ 51234</code>之间所有的数的所有的位上1出现的次数的综合我们就计算出来了</p></li></ol><p>剩下<code>1 ~ 1234</code>，你会发现这与<code>1 ~ 51234</code>的问题是一样的，因此可以做递归处理，即子过程也会将<code>1 ~ 1234</code>也分成<code>1 ~ 234</code>和<code>235 ~ 1234</code>两部分，并计算<code>235~1234</code>而将<code>1~234</code>又进行递归处理。</p><p>而递归的终止条件如下：</p><ol><li>如果<code>1~n</code>中的<code>n</code>：<code>1 &lt;= n &lt;= 9</code>，那么就可以直接返回1了，因为只有数1出现了一次1</li><li>如果<code>n == 0</code>，比如将<code>10000</code>划分成的两部分是<code>0 ~ 0(10000去掉最高位后的结果)</code>和<code>1 ~ 10000</code>，那么就返回0</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">NumberOf1Between1AndN_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//得到十进制位数</span>    <span class="token keyword">int</span> bitCount <span class="token operator">=</span> <span class="token function">bitCount</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//十进制最高位上的数</span>    <span class="token keyword">int</span> highestBit <span class="token operator">=</span> <span class="token function">numOfBit</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> bitCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1、统计最高位为1时，共有多少个数</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>highestBit <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">+=</span> <span class="token function">powerOf10</span><span class="token punctuation">(</span>bitCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//highestBit == 1</span>        res <span class="token operator">+=</span> n <span class="token operator">-</span> <span class="token function">powerOf10</span><span class="token punctuation">(</span>bitCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2、统计其它位为1的情况</span>    res <span class="token operator">+=</span> <span class="token function">powerOf10</span><span class="token punctuation">(</span>bitCount <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>bitCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> highestBit<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3、剩下的部分交给递归</span>    res <span class="token operator">+=</span> <span class="token function">process</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token function">powerOf10</span><span class="token punctuation">(</span>bitCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//返回10的n次方</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">powerOf10</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> minus <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        n <span class="token operator">=</span> <span class="token operator">-</span>n<span class="token punctuation">;</span>        minus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> minus <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">/</span> res <span class="token operator">:</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bitCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numOfBit</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> bit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>bit<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>笔者曾纠结，对于一个四位数，每个位上出现1时都统计了一遍会不会有重复，比如<code>11111</code>这个数在最高位为1时的<code>10000 ~ 19999</code>统计了一遍，在统计非最高位的其他位上为1时又统计了4次，总共被统计了5次，而这个数1出现的次数也确实是5次，因此没有重复。</p><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><h4 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h4 id="解析-31"><a href="#解析-31" class="headerlink" title="解析"></a>解析</h4><p>这是一个贪心问题，你发现将数组按递增排序之后依次连接起来的结果并不是最优的结果，于是需要寻求贪心策略，对于这类最小数和最小字典序的问题而言，贪心策略是：如果<code>3</code>和<code>32</code>相连的结果大于<code>32</code>和<code>3</code>相连的结果，那么视作<code>3</code>比<code>32</code>大，最后我们需要按照按照这种策略将数组进行升序排序，以得到首尾相连之后的结果是最小数字（最小字典序）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">PrintMinNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>numbers <span class="token operator">==</span> null <span class="token operator">||</span> numbers<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> numbers<span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    StringBuilder res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Integer integer <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer i1<span class="token punctuation">,</span> Integer i2<span class="token punctuation">)</span><span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> i1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String s2 <span class="token operator">=</span> i2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token operator">-</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><h4 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h4><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h4 id="解析-32"><a href="#解析-32" class="headerlink" title="解析"></a>解析</h4><p>老实说，在《剑指offer》上看这道题的时候每太看懂，以至于第一遍在牛客网OJ这道题的时候都是背下来写上去的，直到这第二遍总结时才弄清整个思路，思路的核心就是第一个丑数是1（题目给的），此后的每一个丑数都是由之前的某个丑数与2或3或5的乘积得来</p><p><img src="https://wx4.sinaimg.cn/large/006zweohgy1fzdddzfdfnj30pm0d4jtb.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">GetUglyNumber_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//throw new IllegalArgumentException("index must bigger than one");</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> indexOf2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> indexOf3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> indexOf5 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>indexOf2<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>indexOf3<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>indexOf5<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        indexOf2 <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>indexOf2<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>indexOf2 <span class="token operator">:</span> indexOf2<span class="token punctuation">;</span>        indexOf3 <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>indexOf3<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>indexOf3 <span class="token operator">:</span> indexOf3<span class="token punctuation">;</span>        indexOf5 <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>indexOf5<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">5</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>indexOf5 <span class="token operator">:</span> indexOf5<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><h4 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个字符串(0&lt;=字符串长度&lt;=10000，<strong>全部由字母组成</strong>)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h4 id="解析-33"><a href="#解析-33" class="headerlink" title="解析"></a>解析</h4><p>可以从头遍历字符串，并使用一个表记录每个字符第一次出现的位置（初始时表中记录的位置均为-1），如果记录当前被遍历字符出现的位置时发现之前已经记录过了（通过查表，该字符的位置不是-1而是大于等于0的一个有效索引），那么当前字符不在答案的考虑范围内，通过将表中该字符的出现索引标记为<code>-2</code>来标识。</p><p>遍历一遍字符串并更新表之后，再遍历一遍字符串，如果发现某个字符在表中对应的记录是一个有效索引（大于等于0），那么该字符就是整个串中第一个只出现一次的字符。</p><p>由于题目标注字符串全都由字母组成，而字母可以使用<code>ASCII</code>码表示且<code>ASCII</code>范围为<code>0~255</code>，因此使用了一个长度为<code>256</code>的数组来实现这张表。用字母的<code>ASCII</code>值做索引，索引对应的值就是字母在字符串中第一次出现的位置（初始时为-1，第一次遇到时设置为出现的位置，重复遇到时置为-2）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">FirstNotRepeatingChar</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//全部由字母组成</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> ascii <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//set index of first apearance</span>            arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//repeated apearance, don't care</span>            arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//arr[ascii] == -2 -> do not care</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> ascii <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><h4 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">InversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pairs<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><ol><li>题目保证输入的数组中没有相同的数字</li><li>数据范围：对于%50的数据,size&lt;=10^4；对于%75的数据,size&lt;=10^5；对于%100的数据,size&lt;=2*10^5</li></ol><h4 id="解析-34"><a href="#解析-34" class="headerlink" title="解析"></a>解析</h4><p>借助归并排序的流程，将归并流程中前一个数组的数比后一个数组的数小的情况记录下来。</p><p>归并的原始逻辑是根据输入的无序数组返回一个新建的排好序的数组：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> Info right <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr1<span class="token punctuation">.</span>length <span class="token operator">+</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> arr1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> arr2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            copy<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            copy<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        copy<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        copy<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> copy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而我们需要再此基础上对子状态收集的信息进行改造，假设左右两半部分分别有序了，那么进行<code>merge</code>的时候，不应是从前往后复制了，这样当<code>arr1[p1] &gt; arr2[p2]</code>的时候并不知道<code>arr2</code>的<code>p2</code>后面还有多少元素是比<code>arr1[p1]</code>小的，要想一次比较就统计出<code>arr2</code>中所有比<code>arr1[p1]</code>小的数需要将<code>p1,p2</code>从<code>arr1,arr2</code>的尾往前遍历：</p><p><img src="https://ws4.sinaimg.cn/large/006zweohgy1fzdg2nzuzkj30n006odg2.jpg" alt="image"></p><p>而将比较后较大的数移入辅助数组的逻辑还是一样。这样当前递归状态需要收集左半子数组和右半子数组的变成有序过程中记录的逆序对数和自己<code>merge</code>记录的逆序对数之和就是当前状态要返回的信息，并且<code>merge</code>后形成的有序辅助数组也要返回。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">InversePairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pairs<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pairs<span class="token punctuation">;</span>    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> pairs<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> arr<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pairs <span class="token operator">=</span> pairs<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> Info <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> pairs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Info left <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    Info right <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    pairs <span class="token operator">+=</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>pairs <span class="token operator">+</span> right<span class="token punctuation">.</span>pairs<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> left<span class="token punctuation">.</span>arr<span class="token punctuation">,</span> arr2 <span class="token operator">=</span> right<span class="token punctuation">.</span>arr<span class="token punctuation">,</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr1<span class="token punctuation">.</span>length <span class="token operator">+</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> arr1<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> arr2<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">=</span> copy<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">></span> arr2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pairs <span class="token operator">+=</span> <span class="token punctuation">(</span>p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pairs <span class="token operator">%=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            copy<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>p1<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            copy<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>p2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        copy<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>p1<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        copy<span class="token punctuation">[</span>p<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>p2<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> pairs <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h3><h4 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共结点。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">FindFirstCommonNode</span><span class="token punctuation">(</span>ListNode pHead1<span class="token punctuation">,</span> ListNode pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-35"><a href="#解析-35" class="headerlink" title="解析"></a>解析</h4><p>首先我们要分析两个链表的组合状态，根据有环、无环相互组合只可能会出现如下几种情况：</p><p><img src="https://ws4.sinaimg.cn/large/006zweohgy1fzdz1wxjy8j30pc0cmmzb.jpg" alt="image"></p><p>于是我们首先要判断两个链表是否有环，判断链表是否有环以及有环链表的入环结点在哪已有前人给我们总结好了经验：</p><ol><li>使用一个快指针和一个慢指针同时从首节点出发，快指针一次走两步而慢指针一次走一步，如果两指针相遇则说明有环，否则无环</li><li>如果两指针相遇，先将快指针重新指向首节点，然后两指针均一次走一步，再次相遇时的结点就是入环结点</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">FindFirstCommonNode</span><span class="token punctuation">(</span>ListNode pHead1<span class="token punctuation">,</span> ListNode pHead2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若其中一个链表为空则不存在相交问题</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pHead1 <span class="token operator">==</span> null <span class="token operator">||</span> pHead2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode ringNode1 <span class="token operator">=</span> <span class="token function">ringNode</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode ringNode2 <span class="token operator">=</span> <span class="token function">ringNode</span><span class="token punctuation">(</span>pHead2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果一个有环，另一个无环</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ringNode1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> ringNode2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>       <span class="token punctuation">(</span>ringNode1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> ringNode2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果两者都无环，判断是否共用尾结点</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ringNode1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> ringNode2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">firstCommonNode</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">,</span> pHead2<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//剩下的情况就是两者都有环了</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果入环结点相同，那么第一个相交的结点肯定在入环结点之前</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ringNode1 <span class="token operator">==</span> ringNode2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">firstCommonNode</span><span class="token punctuation">(</span>pHead1<span class="token punctuation">,</span> pHead2<span class="token punctuation">,</span> ringNode1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果入环结点不同，看能否通过ringNode1的后继找到ringNode2</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            ListNode p <span class="token operator">=</span> ringNode1<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> ringNode1<span class="token punctuation">)</span><span class="token punctuation">{</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> ringNode2<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果能找到，那么第一个相交的结点既可以是ringNode1也可以是ringNode2</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> ringNode2<span class="token punctuation">)</span> <span class="token operator">?</span> ringNode1 <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//查找两链表的第一个公共结点，如果两链表无环，则传入common=null，如果都有环且入环结点相同，那么传入common=入环结点</span><span class="token keyword">public</span> ListNode <span class="token function">firstCommonNode</span><span class="token punctuation">(</span>ListNode pHead1<span class="token punctuation">,</span> ListNode pHead2<span class="token punctuation">,</span> ListNode common<span class="token punctuation">)</span><span class="token punctuation">{</span>    ListNode p1 <span class="token operator">=</span> pHead1<span class="token punctuation">,</span> p2 <span class="token operator">=</span> pHead2<span class="token punctuation">;</span>    <span class="token keyword">int</span> len1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> gap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>next <span class="token operator">!=</span> common<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        len1<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>next <span class="token operator">!=</span> common<span class="token punctuation">)</span><span class="token punctuation">{</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        len2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果是两个无环链表，要判断一下是否有公共尾结点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>common <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    gap <span class="token operator">=</span> len1 <span class="token operator">></span> len2 <span class="token operator">?</span> len1 <span class="token operator">-</span> len2 <span class="token operator">:</span> len2 <span class="token operator">-</span> len1<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p1指向长链表，p2指向短链表</span>    p1 <span class="token operator">=</span> len1 <span class="token operator">></span> len2 <span class="token operator">?</span> pHead1 <span class="token operator">:</span> pHead2<span class="token punctuation">;</span>    p2 <span class="token operator">=</span> len1 <span class="token operator">></span> len2 <span class="token operator">?</span> pHead2 <span class="token operator">:</span> pHead1<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断链表是否有环，没有返回null，有则返回入环结点（整个链表是一个环时入环结点就是头结点）</span><span class="token keyword">public</span> ListNode <span class="token function">ringNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode p1 <span class="token operator">=</span> head<span class="token punctuation">,</span> p2 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>next <span class="token operator">==</span> null <span class="token operator">||</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">!=</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        p2 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//可能整个链表就是一个环，这时入环结点就是头结点！！！</span>    <span class="token keyword">return</span> p1 <span class="token operator">==</span> p2 <span class="token operator">?</span> p1 <span class="token operator">:</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><h4 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在排序数组中出现的次数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">GetNumberOfK</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-36"><a href="#解析-36" class="headerlink" title="解析"></a>解析</h4><p>我们可以分两步解决，先找出数值为k的连续序列的左边界，再找右边界。可以采用二分的方式，以查找左边界为例：如果<code>arr[mid]</code>小于<code>k</code>那么移动左指针，否则移动右指针（初始时左指针指向<code>-1</code>，而右指针指向尾元素<code>arr.length</code>），当两个指针相邻时，左指针及其左边的数均小于<code>k</code>而右指针及其右边的数均大于或等于<code>k</code>，因此此时右指针就是要查找的左边界，同样的方式可以求得右边界。</p><p>值得注意的是，笔者曾将左指针初始化为<code>0</code>而右指针初始化为<code>arr.length - 1</code>，这与指针指向的含义是相悖的，因为左指针指向的元素必须是小于<code>k</code>的，而我们并不能保证<code>arr[0]</code>一定小于<code>k</code>，同样的我们也不能保证<code>arr[arr.length - 1]</code>一定大于等于<code>k</code>。</p><p>还有一点就是如果数组中没有<code>k</code>这个算法是否依然会返回一个正确的值（0），这也是需要验证的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">GetNumberOfK</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> end <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">-</span> start <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>            end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            start <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    left <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> end <span class="token operator">></span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">-</span> start <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>            end <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            start <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    right <span class="token operator">=</span> start<span class="token punctuation">;</span>    <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><h4 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解析-37"><a href="#解析-37" class="headerlink" title="解析"></a>解析</h4><ol><li>将<code>TreeDepth</code>看做一个黑盒，假设利用这个黑盒收集到了左子树和右子树的深度，那么当前这棵树的深度就是前面两者的最大值加1</li><li><code>base case</code>，如果当前是一棵空树，那么深度为0</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">TreeDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-38"><a href="#解析-38" class="headerlink" title="解析"></a>解析</h4><p>判断当前这棵树是否是平衡二叉所需要收集的信息：</p><ol><li>左子树、右子树各自是平衡二叉树吗（需要收集子树是否是平衡二叉树）</li><li>如果1成立，还需要收集左子树和右子树的高度，如果高度相差不超过1那么当前这棵树才是平衡二叉树（需要收集子树的高度）</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Info</span><span class="token punctuation">{</span>    <span class="token keyword">boolean</span> isBalanced<span class="token punctuation">;</span>    <span class="token keyword">int</span> height<span class="token punctuation">;</span>    <span class="token function">Info</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isBalanced<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isBalanced <span class="token operator">=</span> isBalanced<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>递归体的定义：（这里高度之差不超过1中的<code>left.height - right.height == 0</code>容易被忽略）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">IsBalanced_Solution</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>isBalanced<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> Info <span class="token function">process</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Info left <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    Info right <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>left<span class="token punctuation">.</span>isBalanced <span class="token operator">||</span> <span class="token operator">!</span>right<span class="token punctuation">.</span>isBalanced<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果左子树或右子树不是平衡二叉树，那么当前这棵树肯定也不是，树高度信息也就没用了</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//高度之差不超过1</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>height <span class="token operator">-</span> right<span class="token punctuation">.</span>height <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> left<span class="token punctuation">.</span>height <span class="token operator">-</span> right<span class="token punctuation">.</span>height <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span>       left<span class="token punctuation">.</span>height <span class="token operator">-</span> right<span class="token punctuation">.</span>height <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>height<span class="token punctuation">,</span> right<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Info</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><h4 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><h4 id="解析-39"><a href="#解析-39" class="headerlink" title="解析"></a>解析</h4><p>如果没有解过类似的题目，思路比较难打开。面试官可能会提醒你，如果是让你求一个整型数组里只有一个数只出现了一次而其它数出现了偶数次呢？你应该联想到：</p><ol><li><strong>偶数次相同的数异或的结果是0</strong></li><li><strong>任何数与0异或的结果是它本身</strong></li></ol><p>于是将数组从头到尾求异或和便可得知结果。那么对于此题，能否将数组分成这样的两部分呢：每个部分只有一个数出现了一次，其他的数都出现偶数次。</p><p>如果我们仍将整个数组从头到尾求异或和，那结果应该和这两个只出现一次的数的异或结果相同，目前我们所能依仗的也就是这个结果了，能否靠这个结果将数组分成想要的两部分？</p><p>由于两个只出现一次的数（用A和B表示）异或结果<code>A ^ B</code>肯定不为0，那么<code>A ^ B</code>的二进制表示中肯定包含数值为1的bit位，而这个位上的1肯定是由A或B提供的，也就是说我们能根据<strong>这个bit位上的数是否为1</strong>来区分A和B，那剩下的数呢？</p><p>由于剩下的数都出现偶数次，因此相同的数都会被分到一边（按照某个bit位上是否为1来分）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FindNumsAppearOnce</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> num1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> xorSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        xorSum <span class="token operator">^=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//取xorSum二进制表示中低位为1的bit位，将其它的bit位 置0</span>    <span class="token comment" spellcheck="true">//比如：xorSum = 1100，那么 (1100 ^ 1011) &amp; 1100 = 0100，只剩下一个为1的bit位</span>    xorSum <span class="token operator">=</span> <span class="token punctuation">(</span>xorSum <span class="token operator">^</span> <span class="token punctuation">(</span>xorSum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> xorSum<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        num1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> xorSum<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> num1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> num <span class="token operator">:</span> num1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        num2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> xorSum<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> num2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> num <span class="token operator">:</span> num2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h3><h4 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token operator">></span> <span class="token function">FindContinuousSequence</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h4><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序    </p><h4 id="解析-40"><a href="#解析-40" class="headerlink" title="解析"></a>解析</h4><p>将<code>1 ~ (S / 2 + 1)</code>区间的数<code>n</code>依次加入到队列中（因为从<code>S/2 + 1</code>之后的任意两个正数之和都大于<code>S</code>）：</p><ol><li>将<code>n</code>加入到队列<code>queue</code>中并将队列元素之和<code>queueSum</code>更新，更新<code>queueSum</code>之后如果发现等于<code>sum</code>，那么将此时的队列快照加入到返回结果<code>res</code>中，并弹出队首元素（<strong>保证下次入队操作时队列元素之和是小于sum的</strong>）</li><li>更新<code>queueSum</code>之后如果发现大于<code>sum</code>，那么循环弹出队首元素直到<code>queueSum &lt;= Sum</code>，如果循环弹出之后发现<code>queueSum == sum</code>那么将队列快照加入到<code>res</code>中，并弹出队首元素（<strong>保证下次入队操作时队列元素之和是小于sum的</strong>）；如果<code>queueSum &lt; sum</code>那么入队下一个<code>n</code></li></ol><p>于是有如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">FindContinuousSequence</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> halfSum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> queueSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> halfSum<span class="token punctuation">)</span><span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        queueSum <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queueSum <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            one<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>            queueSum <span class="token operator">-=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>queueSum <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>queueSum <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>                queueSum <span class="token operator">-=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queueSum <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>                ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                one<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>                queueSum <span class="token operator">-=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        n<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现<code>11~15</code>和<code>20~24</code>行的代码是重复的，于是可以稍微优化一下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">FindContinuousSequence</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> halfSum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> queueSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> halfSum<span class="token punctuation">)</span><span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        queueSum <span class="token operator">+=</span> n<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queueSum <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>queueSum <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>                queueSum <span class="token operator">-=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queueSum <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            one<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token punctuation">;</span>            queueSum <span class="token operator">-=</span> queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        n<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h3><h4 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">FindNumbersWithSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h4><p>对应每个测试案例，输出查找到的两个数，如果有多对，输出乘积最小的两个。</p><h4 id="解析-41"><a href="#解析-41" class="headerlink" title="解析"></a>解析</h4><p>使用指针<code>l,r</code>，初始时<code>l</code>指向首元素，<code>r</code>指向尾元素，当两指针元素之和不等于<code>sum</code>且<code>r</code>指针在<code>l</code>指针右侧时循环：</p><ol><li>如果两指针元素之和大于<code>sum</code>，那么将<code>r</code>指针左移，试图减小两指针之和</li><li>如果两指针元素之和小于<code>sum</code>，那么将<code>l</code>右移，试图增大两指针之和</li><li>如果两指针元素之和等于<code>sum</code>那么就可以返回了，或者<code>r</code>跑到了<code>l</code>的左边表名没有和<code>sum</code>的两个数，也可以返回了。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">FindNumbersWithSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">!=</span> sum <span class="token operator">&amp;&amp;</span> r <span class="token operator">></span> l<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>            r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="旋转字符串"><a href="#旋转字符串" class="headerlink" title="旋转字符串"></a>旋转字符串</h3><h4 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h4><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">LeftRotateString</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-42"><a href="#解析-42" class="headerlink" title="解析"></a>解析</h4><p>将开头的一段子串移到串尾：将开头的子串翻转一下、将剩余的子串翻转一下，最后将整个子串翻转一下。按理来说应该输入<code>char[] str</code>的，这样的话这种算法不会使用额外空间。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">LeftRotateString</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end <span class="token punctuation">;</span> j <span class="token operator">></span> i <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> tmp <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h3><h4 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">LeftRotateString</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-43"><a href="#解析-43" class="headerlink" title="解析"></a>解析</h4><p>先将整个字符串翻转，最后按照标点符号或空格一次将句中的单词翻转。注意：由于最后一个单词后面没有空格，因此需要单独处理！！！</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">ReverseSentence</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//初始化start</span>            start <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">:</span> start<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果是空格，不用担心start>i-1，reverse会忽略它</span>            <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最后一个单词，这里比较容易忽略！！！</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">>=</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">,</span> j <span class="token operator">=</span> end <span class="token punctuation">;</span> j <span class="token operator">></span> i <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> tmp <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h3><h4 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h4 id="解析-44"><a href="#解析-44" class="headerlink" title="解析"></a>解析</h4><p>先将数组排序（5个元素排序时间复杂O(1）），然后遍历数组统计王的数量和相邻非王牌之间的缺口数（需要用几个王来填）。还有一点值得注意：如果发现两种相同的非王牌，则不可能组成五张不同的顺子。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isContinuous</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//5 numbers -> O(1)</span>    Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> zeroCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> slots <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果遇到两张相同的非王牌则不可能组成顺子，这点很容易忽略！！！</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                slots <span class="token operator">+=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        zeroCount <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">++</span>zeroCount <span class="token operator">:</span> zeroCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> zeroCount <span class="token operator">>=</span> slots<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="孩子们的游戏（圆圈中剩下的数）"><a href="#孩子们的游戏（圆圈中剩下的数）" class="headerlink" title="孩子们的游戏（圆圈中剩下的数）"></a>孩子们的游戏（圆圈中剩下的数）</h3><h4 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h4><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h4 id="解析-45"><a href="#解析-45" class="headerlink" title="解析"></a>解析</h4><ol><li><p>报数时，在报到<code>m-1</code>之前，可通过报数求得报数的结点编号：</p><p><img src="https://ws1.sinaimg.cn/large/006zweohgy1fze7t11d3mj30j309ewey.jpg" alt="image"></p></li><li><p>在某个结点（小朋友）出列后的重新编号过程中，可通过新编号求结点的就编号</p><p><img src="https://wx1.sinaimg.cn/large/006zweohgy1fze8z9c5dcj30o40eg0u7.jpg" alt="image"></p><p>因此在某轮重新编号时，我们能在已知新编号<code>x</code>的情况下通过公式<code>y = (x + S + 1) % n</code>求得结点重新标号之前的旧编号，上述两步分析的公式整理如下：</p><ol><li>某一轮报数出列前：<code>编号 = （报数 - 1）% 出列前结点个数</code></li><li>某一轮报数出列后：<code>旧编号 = （新编号 + 出列编号 + 1）% 出列前结点个数</code>，因为出列结点是因为报数<code>m</code>才出列的，所以有：<code>出列编号 = （m - 1）% 出列前结点个数</code></li><li>由2可推出：<code>旧编号 = （新编号 + （m - 1）% 出列前结点个数 + 1）% 出列前结点个数</code> ，若用<code>n</code>表示<strong>出列后</strong>结点个数：<code>y = (x + (m - 1) % n + 1) % n = (x + m - 1) % n + 1</code></li></ol></li></ol><p>经过上面3步的复杂分析之后，我们得出这么一个通式：<code>旧编号 = （新编号 + m - 1 ）% 出列前结点个数 + 1</code>，于是我们就可以自下而上（用链表模拟出列过程是自上而下），求出<strong>最后一轮重新编号为<code>1</code></strong>的小朋友（只剩他一个了）在倒数第二轮重新编号时的旧编号，自下而上可倒推出这个小朋友在第一轮编号时（这时还没有任何一个小朋友出列过）的原始编号，即目标答案。</p><blockquote><p>注意：式子<code>y = (x + m - 1) % n + 1</code>的计算结果不可能为<code>0</code>，因此我们可以按小朋友从<code>1</code>开始编号，将最后的计算结果应题目的要求（小朋友从0开始编号）减一个1即可。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">LastRemaining_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//throw new IllegalArgumentException();</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//最后一次重新编号：最后一个结点编号为1，出列前结点数为2</span>    <span class="token keyword">return</span> <span class="token function">orginalNumber</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//根据出列后的重新编号（newNumber）推导出列前的旧编号（返回值）</span><span class="token comment" spellcheck="true">//n：出列前有多少小朋友，N：总共有多少个小朋友</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">orginalNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> newNumber<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> lastNumber <span class="token operator">=</span> <span class="token punctuation">(</span>newNumber <span class="token operator">+</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> lastNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">orginalNumber</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> lastNumber<span class="token punctuation">,</span> N<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求1-2-3-…-n"><a href="#求1-2-3-…-n" class="headerlink" title="求1+2+3+…+n"></a>求1+2+3+…+n</h3><h4 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h4><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-46"><a href="#解析-46" class="headerlink" title="解析"></a>解析</h4><h5 id="递归轻松解决"><a href="#递归轻松解决" class="headerlink" title="递归轻松解决"></a>递归轻松解决</h5><p>既然不允许遍历求和，不如将计算分解，如果知道了<code>f(n - 1)</code>，<code>f(n)</code>则可以通过<code>f(n - 1) + n</code>算出：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Sum_Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token function">Sum_Solution</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><h4 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h4 id="解析-47"><a href="#解析-47" class="headerlink" title="解析"></a>解析</h4><p>不要忘了加减乘除是人类熟悉的运算方法，而计算机只知道位运算哦！</p><p>我们可以将两数的二进制表示写出来，然后按位与得出进位信息、按位或得出非进位信息，如果进位信息不为0，则循环计算直到进位信息为0，此时异或信息就是两数之和：</p><p><img src="https://ws2.sinaimg.cn/large/006zweohgy1fzeb2umgekj30hf0cvdgs.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span><span class="token keyword">int</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> num2 <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> num1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> num2 <span class="token operator">:</span> num1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> and <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> xor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        and <span class="token operator">=</span> num1 <span class="token operator">&amp;</span> num2<span class="token punctuation">;</span>        xor <span class="token operator">=</span> num1 <span class="token operator">^</span> num2<span class="token punctuation">;</span>        num1 <span class="token operator">=</span> and <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>        num2 <span class="token operator">=</span> xor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>and <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> xor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><h4 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">StrToInt</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><p>输入一个字符串,包括数字字母符号,可以为空</p><h4 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h4><p>如果是合法的数值表达则返回该数字，否则返回0</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>输入：<code>+2147483647</code>，输出：<code>2147483647</code><br>输入：<code>1a33</code>，输出<code>0</code></p><h4 id="解析-48"><a href="#解析-48" class="headerlink" title="解析"></a>解析</h4><ol><li>只有第一个位置上的字符可以是<code>+</code>或<code>-</code>或数字，其他位置上的字符必须是数字</li><li>如果第一个字符是<code>-</code>，返回结果必须是负数</li><li>如果字符串只有一个字符，且为<code>+</code>或<code>-</code>，这情况很容易被忽略</li><li>在对字符串解析转换时，如果发现溢出（包括正数向负数溢出，负数向正数溢出），必须有所处理（此时可以和面试官交涉），但不能视而不见</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">StrToInt</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> minus <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        minus <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果只有一个正负号</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">checkInteger</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">transform</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index<span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> minus<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkInteger</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">transform</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">boolean</span> minus<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> minus <span class="token operator">?</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">-</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>minus <span class="token operator">&amp;&amp;</span> res <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token operator">!</span>minus <span class="token operator">&amp;&amp;</span> res <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArithmeticException</span><span class="token punctuation">(</span><span class="token string">"the str is overflow int"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h3><h4 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Parameters:</span><span class="token comment" spellcheck="true">//    numbers:     an array of integers</span><span class="token comment" spellcheck="true">//    length:      the length of array numbers</span><span class="token comment" spellcheck="true">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span><span class="token comment" spellcheck="true">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span><span class="token comment" spellcheck="true">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span><span class="token comment" spellcheck="true">// Return value:       true if the input is valid, and there are some duplications in the array number</span><span class="token comment" spellcheck="true">//                     otherwise false</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numbers<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> duplication<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-49"><a href="#解析-49" class="headerlink" title="解析"></a>解析</h4><p>认真审题发现输入数据是有特征的，即数组长度为<code>n</code>，数组中的元素都在<code>0~n-1</code>范围内，如果数组中没有重复的元素，那么排序后每个元素和其索引值相同，这就意味着数组中如果有重复的元素，那么数组排序后肯定有元素和它对应的索引是不等的。</p><p>顺着这个思路，我们可以将每个元素放到与它相等的索引上，如果某次放之前发现对应的索引上已有了和索引相同的元素，那么说明这个元素是重复的，由于每个元素最多会被调整两次，因此时间复杂<code>O(n)</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> duplication<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">!=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                duplication<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><h4 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>规律题：</p><p><img src="https://ws2.sinaimg.cn/large/006zweohgy1fzee5lql6fj30ie0513ys.jpg" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">multiply</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">,</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    arr2<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        arr2<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> arr2<span class="token punctuation">[</span>len <span class="token operator">-</span> i<span class="token punctuation">]</span> <span class="token operator">*</span> arr<span class="token punctuation">[</span>len <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><h4 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-50"><a href="#解析-50" class="headerlink" title="解析"></a>解析</h4><p>使用<code>p1</code>指向<code>str</code>中下一个要匹配的字符，使用<code>p2</code>指向<code>pattern</code>中剩下的模式串的首字符</p><ol><li>如果<code>p2 &gt;= pattern.length</code>，表示模式串消耗完了，这时如果<code>p1</code>仍有字符要匹配那么返回<code>false</code>否则返回<code>true</code></li><li>如果<code>p1 &gt;= str.length</code>，表示要匹配的字符都匹配完了，但模式串还没消耗完，这时剩下的模式串必须符合<code>a*b*c*</code>这样的范式以能够作为空串处理，否则返回<code>false</code></li><li><code>p1</code>和<code>p2</code>都未越界，按照<code>p2</code>后面是否是<code>*</code>来讨论<ol><li><code>p2</code>后面如果是<code>*</code>，又可按照<code>pattern[p2]</code>是否能够匹配<code>str[p1]</code>分析：<ol><li><code>pattern[p2] == ‘.’ || pattern[p2] == str[p1]</code>，这时可以选择匹配一个<code>str[p1]</code>并继续向后匹配（不用跳过<code>p2</code>和其后面的<code>*</code>），也可以选择将<code>pattern[p2]</code>和其后面的<code>*</code>作为匹配空串处理，这时要跳过<code>p2</code>和 其后面的<code>*</code></li><li><code>pattern[p2] != str[p1]</code>，只能作为匹配空串处理，跳过<code>p2</code></li></ol></li><li><code>p2</code>后面如果不是<code>*</code>：<ol><li><code>pattern[p2] == str[p1] || pattern[p2] == ‘.’</code>，<code>p1,p2</code>同时后移一个继续匹配</li><li><code>pattern[p2] == str[p1]</code>，直接返回<code>false</code></li></ol></li></ol></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> pattern <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matchCore</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pattern<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//模式串用完了</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">>=</span> pattern<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> p1 <span class="token operator">>=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">>=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">[</span>p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> p2 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果p2的后面是“*”</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p2 <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> pattern<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> pattern<span class="token punctuation">[</span>p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span> <span class="token operator">||</span> pattern<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">==</span> str<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//匹配一个字符，接着还可以向后匹配；或者将当前字符和后面的星合起来做空串</span>            <span class="token keyword">return</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> p2 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p1<span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> p2 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果p2的后面不是*</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span> <span class="token operator">||</span> pattern<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">==</span> str<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">matchCore</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> pattern<span class="token punctuation">,</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><h4 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-51"><a href="#解析-51" class="headerlink" title="解析"></a>解析</h4><p>由题式可得出如下约束：</p><ol><li>正负号只能出现在第一个位置或者<code>e/E</code>后一个位置</li><li><code>e/E</code>后面有且必须有整数</li><li>字符串中只能包含数字、小数点、正负号、<code>e/E</code>，其它的都是非法字符</li><li><code>e/E</code>的前面最多只能出现一次小数点，而<code>e/E</code>的后面不能出现小数点</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isNumeric</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> signed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//标识是否以正负号开头</span>    <span class="token keyword">boolean</span> decimal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//标识是否有小数点</span>    <span class="token keyword">boolean</span> existE <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//是否含有e/E</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//一段连续数字的开头</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//从0开始遍历字符</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">existSignAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        signed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//以下按照index上可能出现的字符进行分支判断</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            start <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> index <span class="token operator">:</span> start<span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//首字符的+-我们已经判断过了，因此+-只可能出现在e/E的后面</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">existEAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//小数点只可能出现在e/E前面，且只可能出现一次</span>            <span class="token comment" spellcheck="true">//如果出现过小数点了，或者小数点前一段连续数字的前面是e/E</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>decimal <span class="token operator">||</span> <span class="token function">existEAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>               <span class="token operator">||</span> <span class="token function">existEAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> start <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            decimal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出现了小数点</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//下一段连续数字的开始</span>            start <span class="token operator">=</span> index<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">existEAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>existE<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//如果已出现过e/E</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            existE <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//由于e/E后面可能是正负号也可能是数字，所以下一段连续数字的开始不确定</span>            start <span class="token operator">=</span> <span class="token operator">!</span><span class="token function">existSignAtIndex</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">?</span> index <span class="token operator">:</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果最后一段连续数字的开始不存在 -> e/E后面没有数字</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>start <span class="token operator">>=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在index上的字符是否是e或者E</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">existEAtIndex</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'e'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'E'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在index上的字符是否是正负号</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">existSignAtIndex</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> str<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h3><h4 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h4 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h4><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><h4 id="解析-52"><a href="#解析-52" class="headerlink" title="解析"></a>解析</h4><p>首先要选取一个容器来保存字符，并且要记录字符进入容器的顺序。如果不考虑中文字符，那么可以使用一张大小为<code>256</code>（对应<code>ASCII</code>码值范围）的表来保存字符，用字符的<code>ASCII</code><strong>码值</strong>作为索引，用字符进入容器的<strong>次序</strong>作为索引对应的记录，表内部维护了一个计数器<code>position</code>，每当有字符进入时以该计数器的值作为该字符的次序（初始时，每个字符对应的次序为-1），如果设置该字符的次序时发现之前已设置过（次序不为-1，而是大于等于0），那么将该字符的次序置为-2，表示以后从容器取第一个只出现一次的字符时不考虑该字符。</p><p>当从容器取第一个只出现一次的字符时，考虑次序大于等于0的字符，在这个前提下找出次序最小的字符并返回。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//不算中文，保存所有ascii码对应的字符只需256字节，记录ascii码为index的字符首次出现的位置</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始时所有字符的首次出现的位置为-1</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Insert one char from stringstream</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> ascii <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ch<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">=</span> position<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>ascii<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//return the first appearence once char in current stringstream</span><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">FirstAppearingOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> minPosi <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">char</span> res <span class="token operator">=</span> <span class="token string">'#'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minPosi<span class="token punctuation">)</span><span class="token punctuation">{</span>            minPosi <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h3><h4 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">deleteDuplication</span><span class="token punctuation">(</span>ListNode pHead<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-53"><a href="#解析-53" class="headerlink" title="解析"></a>解析</h4><p>此题处理起来棘手的有两个地方：</p><ol><li><p>如果某个结点的后继结点与其重复，那么删除该结点的一串连续重复的结点之后如何删除该结点本身，这就要求我们需要保留当前遍历结点的前驱指针。</p><p>但是如果从头结点开始就出现一连串的重复呢？我们又如何删除删除头结点，因此我们需要新建一个辅助结点作为头结点的前驱结点。</p></li><li><p>在遍历过程中如何区分当前结点是不重复的结点，还是在删除了它的若干后继结点之后最后也要删除它本身的重复结点？这就需要我们使用一个布尔变量记录是否开启了删除模式（<code>deleteMode</code>）</p></li></ol><p>经过上述两步分析，我们终于可以安心遍历结点了：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ListNode <span class="token function">deleteDuplication</span><span class="token punctuation">(</span>ListNode pHead<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pHead <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>next <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    ListNode pre <span class="token operator">=</span> node<span class="token punctuation">,</span> p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> deletedMode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>            p<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            deletedMode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>deletedMode<span class="token punctuation">)</span><span class="token punctuation">{</span>            pre<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            p <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            deletedMode <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            pre <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h3><h4 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h4 id="解析-54"><a href="#解析-54" class="headerlink" title="解析"></a>解析</h4><p>由于中序遍历来到某个结点后，首先会接着遍历它的右子树，如果它没有右子树则会回到祖先结点中将它当做左子树上的结点的那一个，因此有如下分析：</p><ol><li>如果当前结点有右子树，那么其后继结点就是其右子树上的最左结点</li><li>如果当前结点没有右子树，那么其后继结点就是其祖先结点中，将它当做左子树上的结点的那一个。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> TreeLinkNode <span class="token function">GetNext</span><span class="token punctuation">(</span>TreeLinkNode pNode<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pNode <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果有右子树，后继结点是右子树上最左的结点</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        TreeLinkNode p <span class="token operator">=</span> pNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果没有右子树，向上查找第一个当前结点是父结点的左孩子的结点</span>        TreeLinkNode p <span class="token operator">=</span> pNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pNode <span class="token operator">!=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>            pNode <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> pNode <span class="token operator">==</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><h4 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">)</span><span class="token punctuation">{</span>｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-55"><a href="#解析-55" class="headerlink" title="解析"></a>解析</h4><p>判断一棵树是否是镜像二叉树，只需将经典的先序遍历序列和变种的<strong>先根再右再左</strong>的先序遍历序列比较，如果相同则为镜像二叉树。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isSymmetrical</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pRoot <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    StringBuffer str1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    StringBuffer str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder2</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> StringBuffer str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder2</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> StringBuffer str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder2</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrder2</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="按之字形打印二叉树"><a href="#按之字形打印二叉树" class="headerlink" title="按之字形打印二叉树"></a>按之字形打印二叉树</h3><h4 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h4 id="解析-56"><a href="#解析-56" class="headerlink" title="解析"></a>解析</h4><p>注意下述代码的第<code>14</code>行，笔者曾写为<code>stack2 = stack1 == empty ? stack1 : stack2</code>，你能发现错误在哪儿吗？</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">Print</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pRoot <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先加左孩子，再加右孩子</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>stack2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> empty <span class="token operator">=</span> stack1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> stack1 <span class="token operator">:</span> stack2<span class="token punctuation">;</span>        stack1 <span class="token operator">=</span> stack1 <span class="token operator">==</span> empty <span class="token operator">?</span> stack2 <span class="token operator">:</span> stack1<span class="token punctuation">;</span>        stack2 <span class="token operator">=</span> empty<span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> row <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode p <span class="token operator">=</span> stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            row<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>        flag <span class="token operator">=</span> <span class="token operator">!</span>flag<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><h4 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h4 id="解析-57"><a href="#解析-57" class="headerlink" title="解析"></a>解析</h4><p>怎么序列化的，就怎么反序列化。这里<code>deserialize</code>反序列化时对于序列化到<code>String[] arr</code>的哪个结点值来了的变量<code>index</code>有两个坑（都是笔者亲自踩的）：</p><ol><li>将<code>index</code>声明为成员的<code>int</code>，<code>Java</code>中函数调用时不会改变基本类型参数的值的，因此不要企图使用<code>int</code>表示当前序列化哪个结点的值来了</li><li>之后笔者想用<code>Integer</code>代替，但是<code>Integer</code>和<code>String</code>一样，都是不可变对象，所有的值更改操作在底层都是拆箱和装箱生成新的<code>Integer</code>，因此也不要使用<code>Integer</code>做序列化到哪一个结点数值来了的计数器</li><li>最好使用数组或者自定义的类（在类中声明一个<code>int</code>变量）</li></ol><pre class="line-numbers language-java"><code class="language-java">String <span class="token function">Serialize</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"#_"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//处理头结点、左子树、右子树</span>    String res <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> <span class="token function">Serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> <span class="token function">Serialize</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span>TreeNode <span class="token function">Deserialize</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>str <span class="token operator">==</span> null <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Integer index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//怎么序列化的，就怎么反序列化</span>TreeNode <span class="token function">deserialize</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//头结点、左子树、右子树</span>    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">deserialize</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><h4 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><pre class="line-numbers language-java"><code class="language-java">TreeNode <span class="token function">KthNode</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-58"><a href="#解析-58" class="headerlink" title="解析"></a>解析</h4><p>二叉搜索树的特点是，它的中序序列是有序的，因此我们可以借助中序遍历在递归体中第二次来到当前结点时更新一下计数器，直到遇到第k个结点保存并返回即可。</p><p>值得注意的地方是：</p><ol><li>由于计数器在递归中传来传去，因此你需要保证每个递归引用的是同一个计数器，这里使用的是一个<code>int[]</code>的第一个元素来保存</li><li>我们写中序遍历是不需要返回值的，可以在找到第k小的结点时将其保存在传入的数组中以返回给调用方</li></ol><pre class="line-numbers language-java"><code class="language-java">TreeNode <span class="token function">KthNode</span><span class="token punctuation">(</span>TreeNode pRoot<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pRoot <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> k <span class="token punctuation">}</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count<span class="token punctuation">,</span> TreeNode<span class="token punctuation">[</span><span class="token punctuation">]</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> count<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    count<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> count<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果可以利用我们熟知的算法，比如本题中的中序遍历。管它三七二十一先将熟知方法写出来，然后再按具体的业务需求对其进行改造（包括返回值、参数列表，但一般不会更改遍历算法的返回值）</p></blockquote><h3 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h3><h4 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>Integer num<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> Double <span class="token function">GetMedian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解析-59"><a href="#解析-59" class="headerlink" title="解析"></a>解析</h4><p>由于中位数只与排序后位于数组中间的一个数或两个数相关，而与数组两边的其它数无关，因此我们可以用一个大根堆保存数组左半边的数的最大值，用一个小根堆保存数组右半边的最小值，插入元素<code>O(logn)</code>，取中位数<code>O(1)</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//小根堆、大根堆</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> minHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MinRootHeadComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PriorityQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MaxRootHeadComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">MaxRootHeadComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//返回值大于0则认为逻辑上i2大于i1（无关对象包装的数值）</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer i1<span class="token punctuation">,</span> Integer i2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> i2<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i1<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">MinRootHeadComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer i1<span class="token punctuation">,</span> Integer i2<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> i1<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i2<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Insert</span><span class="token punctuation">(</span>Integer num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前这个数是第几个进来的</span>        <span class="token comment" spellcheck="true">//编号是奇数就放入小根堆（右半边），否则放入大根堆</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果要放入右半边的数比左半边的最大值要小则需调整左半边的最大值放入右半边并将当前这个数放入左半边，这样才能保证右半边的数都比左半边的大</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">&lt;</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                num <span class="token operator">=</span> maxHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">></span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                minHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                num <span class="token operator">=</span> minHeap<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxHeap<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Double <span class="token function">GetMedian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>minHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> maxHeap<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><h4 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">maxInWindows</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="解析-60"><a href="#解析-60" class="headerlink" title="解析"></a>解析</h4><p>使用一个单调非增队列，队头保存当前窗口的最大值，后面保存在窗口移动过程中导致队头失效（出窗口）后的从而晋升为窗口最大值的候选值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">maxInWindows</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> null <span class="token operator">||</span> num<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> size <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> size <span class="token operator">></span> num<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//用队头元素保存窗口最大值，队列中元素只能是单调递减的，窗口移动可能导致队头元素失效</span>    LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> end <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">addLast</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//移动窗口</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>end <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">addLast</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> num<span class="token punctuation">[</span><span class="token operator">++</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> num<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        start<span class="token operator">++</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span>LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//加元素之前要确保该元素小于等于队尾元素</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">></span> queue<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        queue<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="矩形中的路径"><a href="#矩形中的路径" class="headerlink" title="矩形中的路径"></a>矩形中的路径</h3><h4 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><h4 id="解析-61"><a href="#解析-61" class="headerlink" title="解析"></a>解析</h4><p>定义一个黑盒<code>hasPathCorechar(matrix, rows, cols, int i, int j, str, index)</code>，表示从<code>rows</code>行<code>cols</code>列的矩阵<code>matrix</code>中的<code>(i,j)</code>位置开始走是否能走出一条与<code>str</code>的子串<code>index ~ str.length-1</code>相同的路径。那么对于当前位置<code>(i,j)</code>，需要关心的只有一下三点：</p><ol><li><code>(i,j)</code>是否越界了</li><li><code>(i,j)</code>上的字符是否和<code>str[index]</code>匹配</li><li><code>(i,j)</code>是否已在之前走过的路径上</li></ol><p>如果通过了上面三点检查，那么认为<code>(i,j)</code>这个位置是可以走的，剩下的就是<code>(i,j)</code>上下左右四个方向能否走出<code>str</code>的<code>index+1 ~ str.length-1</code>，这个交给黑盒就好了。</p><p>还有一点要注意，如果确定了可以走当前位置<code>(i,j)</code>，那么需要将该位置的<code>visited</code>标记为<code>true</code>，表示该位置在已走过的路径上，而退出<code>(i,j)</code>的时候（对应下面第<code>32</code>行）又要将他的<code>visited</code>重置为<code>false</code>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPath</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">!=</span> rows <span class="token operator">*</span> cols <span class="token operator">||</span> str <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>matrix<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//以矩阵中的每个点作为起点尝试走出str对应的路径</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">hasPathCore</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//当前在矩阵的(i,j)位置上</span><span class="token comment" spellcheck="true">//index -> 匹配到了str中的第几个字符</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">hasPathCore</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span>                             <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//越界或字符不匹配或该位置已在路径上</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">match</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> str<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> visited<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    visited<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token function">hasPathCore</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">hasPathCore</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">hasPathCore</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">hasPathCore</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//矩阵matrix中的(i,j)位置上是否是c字符</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> rows <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">></span> cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> matrix<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><h4 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h4><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h4 id="解析-62"><a href="#解析-62" class="headerlink" title="解析"></a>解析</h4><p>定义一个黑盒<code>walk(int threshold, int rows, int cols, int i, int j, boolean[] visited)</code>，它表示统计从<code>rows</code>行<code>cols</code>列的矩阵中的<code>(i,j)</code>开始所能到达的格子并返回，对于当前位置<code>(i,j)</code>有如下判断：</p><ol><li><code>(i,j)</code>是否越界矩阵了</li><li><code>(i,j)</code>是否已被统计过了</li><li><code>(i,j)</code>的行坐标和列坐标的数位之和是否大于<code>k</code></li></ol><p>如果通过了上面三重检查，则认为<code>(i,j)</code>是可以到达的（<code>res=1</code>），并标记<code>(i,j)</code>的<code>visited</code>为<code>true</code>表示已被统计过了，然后对<code>(i,j)</code>的上下左右的格子调用黑盒进行统计。</p><p>这里要注意的是，与上一题不同，<code>visited</code>不会在递归计算完子状态后被重置回<code>false</code>，因为每个格子只能被统计一次。<code>visited</code>的含义不一样</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>threshold <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> rows <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> cols <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">boolean</span><span class="token punctuation">[</span>rows <span class="token operator">*</span> cols<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">walk</span><span class="token punctuation">(</span>threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">walk</span><span class="token punctuation">(</span><span class="token keyword">int</span> threshold<span class="token punctuation">,</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isLegalPosition</span><span class="token punctuation">(</span>rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">||</span> visited<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span>       <span class="token operator">||</span> <span class="token function">bitSum</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">bitSum</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">></span> threshold<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    visited<span class="token punctuation">[</span>i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> <span class="token function">walk</span><span class="token punctuation">(</span>threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token function">walk</span><span class="token punctuation">(</span>threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token function">walk</span><span class="token punctuation">(</span>threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span> <span class="token operator">+</span>        <span class="token function">walk</span><span class="token punctuation">(</span>threshold<span class="token punctuation">,</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isLegalPosition</span><span class="token punctuation">(</span><span class="token keyword">int</span> rows<span class="token punctuation">,</span> <span class="token keyword">int</span> cols<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">></span> rows <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> j <span class="token operator">></span> cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">bitSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        res <span class="token operator">+=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发框架</title>
      <link href="//post/%E5%9B%9B%E3%80%81Java%E5%B9%B6%E5%8F%91.html"/>
      <url>//post/%E5%9B%9B%E3%80%81Java%E5%B9%B6%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="四-并发框架"><a href="#四-并发框架" class="headerlink" title="四. 并发框架"></a>四. 并发框架</h1><h2 id="Doug-Lea"><a href="#Doug-Lea" class="headerlink" title="Doug Lea"></a>Doug Lea</h2><p>如果IT的历史，是以人为主体串接起来的话，那么肯定少不了Doug Lea。这个鼻梁挂着眼镜，留着德王威廉二世的胡子，脸上永远挂着谦逊腼腆笑容，服务于纽约州立大学Oswego分校计算机科学系的老大爷。<br>说他是这个世界上对Java影响力最大的个人，一点也不为过。因为两次Java历史上的大变革，他都间接或直接的扮演了举足轻重的角色。2004年所推出的Tiger。Tiger广纳了15项JSRs(Java Specification Requests)的语法及标准，其中一项便是JSR-166。JSR-166是来自于Doug编写的util.concurrent包。<br>值得一提的是:Doug Lea也是JCP (Java社区项目)中的一员。<br>Doug是一个无私的人，他深知分享知识和分享苹果是不一样的，苹果会越分越少，而自己的知识并不会因为给了别人就减少了，知识的分享更能激荡出不一样的火花。《Effective JAVA》这本Java经典之作的作者Joshua Bloch便在书中特别感谢Doug Lea是此书中许多构想的共鸣板，感谢Doug Lea大方分享丰富而又宝贵的知识。</p><h1 id="一-线程"><a href="#一-线程" class="headerlink" title="一.线程"></a>一.线程</h1><h2 id="0-关于线程你需要搞懂这些："><a href="#0-关于线程你需要搞懂这些：" class="headerlink" title="0.关于线程你需要搞懂这些："></a>0.关于线程你需要搞懂这些：</h2><ul><li>线程的状态</li><li>线程的几种实现方式</li><li>三个线程轮流打印ABC十次</li><li>判断线程是否销毁</li><li>yield功能</li><li>给定三个线程t1,t2,t3，如何保证他们依次执行</li></ul><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8734.png" alt=""><br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8735.png" alt=""></p><h2 id="2-线程的启动"><a href="#2-线程的启动" class="headerlink" title="2. 线程的启动"></a>2. 线程的启动</h2><h3 id="2-1-实现Runnable接口"><a href="#2-1-实现Runnable接口" class="headerlink" title="2.1 实现Runnable接口"></a>2.1 实现Runnable接口</h3><ul><li>1.自定义一个线程，实现Runnable接口的run方法<br>run方法就是要执行的内容，会在另一个分支上进行<br>Thread类本身也实现了Runnable接口</li><li>2.主方法中new一个自定义线程对象，然后new一个Thread类对象，其构造方法的参数是自定义线程对象</li><li>3.执行Thread类的start方法，线程开始执行<br>自此产生了分支，一个分支会执行run方法，在主方法中不会等待run方法调用完毕返回才继续执行，而是直接继续执行，是第二个分支。这两个分支并行运行</li></ul><p>这里运用了静态代理模式：<br>Thread类和自定义线程类都实现了Runnable接口<br>Thread类是代理Proxy，自定义线程类是被代理类<br>通过调用Thread的start方法，实际上调用了自定义线程类的start方法（当然除此之外还有其他的代码）</p><h3 id="2-2-继承Thread类"><a href="#2-2-继承Thread类" class="headerlink" title="2.2 继承Thread类"></a>2.2 继承Thread类</h3><ul><li>自定义一个类MyThread，继承Thread类，重写run方法</li><li>在main方法中new一个自定义类，然后直接调用start方法<br>两个方法比较而言第二个方法代码量较少<br>但是第一个方法比较灵活，自定义线程类还可以继承其他的类，而不限于Thread类<h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3></li></ul><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8736.png" alt=""></p><h2 id="3-线程的状态"><a href="#3-线程的状态" class="headerlink" title="3. 线程的状态"></a>3. 线程的状态</h2><h3 id="初始态：NEW"><a href="#初始态：NEW" class="headerlink" title="初始态：NEW"></a>初始态：NEW</h3><p>创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。</p><h3 id="运行态：RUNNABLE"><a href="#运行态：RUNNABLE" class="headerlink" title="运行态：RUNNABLE"></a>运行态：RUNNABLE</h3><p>在Java中，运行态包括就绪态 和 运行态。</p><h3 id="就绪态-READY"><a href="#就绪态-READY" class="headerlink" title="就绪态 READY"></a>就绪态 READY</h3><p>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。<br>所有就绪态的线程存放在就绪队列中。</p><h3 id="运行态-RUNNING"><a href="#运行态-RUNNING" class="headerlink" title="运行态 RUNNING"></a>运行态 RUNNING</h3><p>获得CPU执行权，正在执行的线程。<br>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</p><h3 id="阻塞态-BLOCKED"><a href="#阻塞态-BLOCKED" class="headerlink" title="阻塞态 BLOCKED"></a>阻塞态 BLOCKED</h3><p>阻塞态专指请求排它锁失败时进入的状态。</p><h3 id="等待态-WAITING"><a href="#等待态-WAITING" class="headerlink" title="等待态 WAITING"></a>等待态 WAITING</h3><p>当前线程中调用wait、join、park函数时，当前线程就会进入等待态。<br>进入等待态的线程会释放CPU执行权，并释放资源（如：锁），它们要等待被其他线程显式地唤醒。</p><h3 id="超时等待态-TIME-WAITING"><a href="#超时等待态-TIME-WAITING" class="headerlink" title="超时等待态 TIME_WAITING"></a>超时等待态 TIME_WAITING</h3><p>当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；<br>进入该状态后释放CPU执行权 和 占有的资源。<br>与等待态的区别：无需等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。 </p><h3 id="终止态"><a href="#终止态" class="headerlink" title="终止态"></a>终止态</h3><p>线程执行结束后的状态。</p><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8737.png" alt=""></p><h2 id="4-线程的方法"><a href="#4-线程的方法" class="headerlink" title="4. 线程的方法"></a>4. 线程的方法</h2><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8738.png" alt=""></p><h3 id="getName"><a href="#getName" class="headerlink" title="getName"></a>getName</h3><p>Thread类的构造方法1<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8739.png" alt=""><br>Thread类的构造方法2<br><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8740.png" alt=""></p><ul><li>new 一个子类对象的同时也new了其父类的对象，只是如果不显式调用父类的构造方法super(),那么会自动调用无参数的父类的构造方法。<br>可以在自定义类MyThread中（继承自Thread类）中写一个构造方法，显式调用父类的构造方法，其参数为一个字符串,表示创建一个以该字符串为名字的Thread对象。</li><li>效果是创建了一个MyThread对象，并且其父类Thread对象的名字是给定的字符串。</li><li>如果不显式调用父类的构造方法super(参数)，那么默认父类Thread是没有名字的。<h3 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive"></a>isAlive</h3></li></ul><p><strong>isAlive活着的定义是就绪、运行、阻塞状态</strong><br>线程是有优先级的，优先级高的获得Cpu执行时间长，并不代表优先级低的就得不到执行</p><h3 id="sleep（当前线程-sleep）"><a href="#sleep（当前线程-sleep）" class="headerlink" title="sleep（当前线程.sleep）"></a>sleep（当前线程.sleep）</h3><p>sleep时持有的锁不会自动释放，sleep时可能会抛出InterruptedException。<br>Thread.sleep(long millis)<br>一定是当前线程调用此方法，当前线程进入TIME_WAIT状态，但不释放对象锁，millis后线程自动苏醒进入READY状态。作用：给其它线程执行机会的最佳方式。</p><h3 id="join（其他线程-join）"><a href="#join（其他线程-join）" class="headerlink" title="join（其他线程.join）"></a>join（其他线程.join）</h3><p>t.join()/t.join(long millis)<br>当前线程里调用线程1的join方法，当前线程进入WAIT状态，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。<br>join方法的作用是将分出来的线程合并回去，等待分出来的线程执行完毕后继续执行原有线程。类似于方法调用。（相当于调用thead.run()）</p><h3 id="yield（当前线程-yield）"><a href="#yield（当前线程-yield）" class="headerlink" title="yield（当前线程.yield）"></a>yield（当前线程.yield）</h3><p>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</p><h3 id="interrupt（其他线程-interrupt）"><a href="#interrupt（其他线程-interrupt）" class="headerlink" title="interrupt（其他线程.interrupt）"></a>interrupt（其他线程.interrupt）</h3><ul><li>调用Interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志；<br>中断可以理解为线程的一个标志位属性，表示一个运行中的线程是否被其他线程进行了中断操作。这里提到了其他线程，所以可以认为中断是线程之间进行通信的一种方式，简单来说就是由其他线程通过执行interrupt方法对该线程打个招呼，让起中断标志位为true，从而实现中断线程执行的目的。</li><li>其他线程调用了interrupt方法后，该线程通过检查自身是否被中断进行响应，具体就是该线程需要调用Thread.currentThread().isInterrupted方法进行判断是否被中断或者调用Thread类的静态方法interrupted对当前线程的中断标志位进行复位（变为false）。需要注意的是，如果该线程已经处于终结状态，即使该线程被中断过，那么调用isInterrupted方法返回仍然是false，表示没有被中断。</li><li>那么是不是线程调用了interrupt方法对该线程进行中断，该线程就会被中断呢？答案是否定的。因为<strong>Java虚拟机对会抛出InterruptedException异常的方法进行了特别处理：Java虚拟机会将该线程的中断标志位清除，然后抛出InterruptedException，这个时候调用isInterrupted方法返回的也是false</strong>。</li></ul><p><strong>interrupt一个其他线程t时</strong></p><ul><li>1）如果线程t中调用了可以抛出InterruptedException的方法，那么会在t中抛出InterruptedException并清除中断标志位。</li><li>2）如果t没有调用此类方法，那么会正常地将设置中断标志位。</li></ul><p><strong>如何停止线程？</strong></p><ul><li>1）在catch InterruptedException异常时可以关闭当前线程；</li><li>2）循环调用isInterrupted方法检测是否被中断，如果被中断，要么调用interrupted方法清除中断标志位，要么就关闭当前线程。</li><li>3）无论1）还是2），都可以通过一个volatile的自定义标志位来控制循环是否继续执行</li></ul><p><strong>但是注意！<br>如果线程中有阻塞操作，在阻塞时是无法去检测中断标志位或自定义标志位的，只能使用1）的interrupt方法才能中断线程，并且在线程停止前关闭引起阻塞的资源（比如Socket）。</strong></p><h3 id="wait（对象-wait）"><a href="#wait（对象-wait）" class="headerlink" title="wait（对象.wait）"></a>wait（对象.wait）</h3><ul><li><strong>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。</strong></li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</li><li>调用wait()方法的线程，如果其他线程调用该线程的interrupt()方法，则会重新尝试获取对象锁。只有当获取到对象锁，才开始抛出相应的InterruptedException异常，从wait中返回。</li></ul><h3 id="notify（对象-notify）"><a href="#notify（对象-notify）" class="headerlink" title="notify（对象.notify）"></a>notify（对象.notify）</h3><p>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</p><h3 id="wait-amp-notify-最佳实践"><a href="#wait-amp-notify-最佳实践" class="headerlink" title="wait&amp;notify 最佳实践"></a>wait&amp;notify 最佳实践</h3><p>等待方（消费者）和通知方（生产者）</p><pre><code>等待方：synchronized(obj){    while(条件不满足){     obj.wait();}消费;}通知方：synchonized(obj){    改变条件;    obj.notifyAll();}</code></pre><ul><li><p>1）条件谓词：</p></li><li><p>将与条件队列相关联的条件谓词以及在这些条件谓词上等待的操作都写入文档。</p></li><li><p>在条件等待中存在一种重要的三元关系，包括<strong>加锁、wait方法和一个条件谓词。在条件谓词中包含多个状态变量，而状态变量由一个锁来保护，因此在测试条件谓词之前必须先持有这个锁。锁对象和条件队列对象（即调用wait和notify等方法所在的对象）必须是同一个对象。</strong></p></li><li><p>当线程从wait方法中被唤醒时，它在重新请求锁时不具有任何特殊的优先性，而要去其他尝试进入同步代码块的线程一起正常地在锁上进行竞争。</p></li><li><p>每一次wait调用都会隐式地与特定的条件谓词关联起来。当调用某个特定条件谓词的wait时，调用者必须已经持有与条件队列相关的锁，并且这个锁必须保护着构成条件谓词的状态变量。</p></li><li><p>2）过早唤醒：<br>虽然在锁、条件谓词和条件队列之间的三元关系并不复杂，但wait方法的返回并不一定意味着线程正在等待的条件谓词已经变成真了。<br>当执行控制重新进入调用wait的代码时，它已经重新获取了与条件队列相关联的锁。现在条件谓词是不是已经变为真了？或许。在发出通知的线程调用notifyAll时，条件谓词可能已经变成真，但在重新获取锁时将再次变成假。在线程被唤醒到wait重新获取锁的这段时间里，可能有其他线程已经获取了这个锁，并修改了对象的状态。或者，条件谓词从调用wait起根本就没有变成真。你并不知道另一个线程为什么调用notify或notifyAll，也许是因为与同一条件队列相关的另一个条件谓词变成了真。一个条件队列与多个条件谓词相关是一种很常见的情况。<br>基于所有这些原因，每当线程从wait中唤醒时，都必须再次测试条件谓词。</p></li><li><p>3）notify与notifyAll：<br>由于多个线程可以基于不同的条件谓词在同一个条件队列上等待，因此如果使用notify而不是notifyAll，那么将是一种危险的操作，因为单一的通知很容易导致类似于信号地址（线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词）的问题。</p></li></ul><p>只有同时满足以下两个条件时，才能用单一的notify而不是notifyAll：</p><ul><li>1）所有等待线程的类型都相同。只有一个条件谓词与条件队列相关，并且每个线程在从wait返回后将执行相同的操作。</li><li>2）单进单出：在对象状态上的每次改变，最多只能唤醒一个线程来执行。</li></ul><h3 id="suspend-resume-stop-destroy（废弃方法）"><a href="#suspend-resume-stop-destroy（废弃方法）" class="headerlink" title="suspend resume stop destroy（废弃方法）"></a>suspend resume stop destroy（废弃方法）</h3><ul><li>线程的暂停、恢复、停止对应的就是suspend、resume和stop/destroy。</li><li>suspend会使当前线程进入阻塞状态并不释放占有的资源，容易引起死锁；</li><li>stop在结束一个线程时不会去释放占用的资源。它会直接终止run方法的调用，并且会抛出一个ThreadDeath错误。</li><li>destroy只是抛出一个NoSuchMethodError。</li><li>suspend和resume已被wait、notify取代。</li></ul><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8741.png" alt=""><br>判断当前线程是否正在执行<br>注意优先级是概率而非先后顺序（优先级高可能会执行时间长，但也不一定）</p><p>线程优先级特性：</p><ul><li>继承性<br>比如A线程启动B线程，则B线程的优先级与A是一样的。</li><li>规则性<br>高优先级的线程总是大部分先执行完，但不代表高优先级线程全部先执行完。</li><li>随机性<br>优先级较高的线程不一定每一次都先执行完。</li></ul><p><strong>注意，在不同的JVM以及OS上，线程规划会存在差异，有些OS会忽略对线程优先级的设定。</strong></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><img src="https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8742.png" alt=""></p><ul><li>将线程转换为守护线程</li><li>守护线程的唯一用途是为其他线程提供服务。比如计时线程，它定时发送信号给其他线程；</li><li>当只剩下守护线程时，JVM就退出了。</li><li>守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</li><li>注意！Java虚拟机退出时Daemon线程中的finally块并不一定会被执行。</li></ul><h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>在Runnable的run方法中不能抛出异常，如果某个异常没有被捕获，则会导致线程终止。</p><p>要求异常处理器实现Thread.UncaughtExceptionHandler接口。<br>可以使用setUncaughtExceptionHandler方法为任何一个线程安装一个处理器，<br>也可以使用Thread.setDefaultUncaughtExceptionHandler方法为所有线程安装一个默认的处理器；</p><p>如果不安装默认的处理器，那么默认的处理器为空。如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象<br>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，它的uncaughtException方法做如下操作：</p><ul><li>1）如果该线程组有父线程组，那么父线程组的uncaughtException方法被调用。</li><li>2）否则，如果Thread.getDefaultExceptionHandler方法返回一个非空的处理器，则调用该处理器。</li><li>3）否则，如果Throwable是ThreadDeath的一个实例（ThreadDeath对象由stop方法产生，而该方法已过时），什么都不做。</li><li>4）否则，线程的名字以及Throwable的栈踪迹被输出到System.err上。</li></ul><p>如果是由线程池ThreadPoolExecutor执行任务，只有通过execute提交的任务，才能将它抛出的异常交给UncaughtExceptionHandler，而通过submit提交的任务，无论是抛出的未检测异常还是已检查异常，都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出了异常而结束，那么这个异常将被Future.get封装在ExecutionException中重新抛出。</p><h1 id="二-并发编程的问题"><a href="#二-并发编程的问题" class="headerlink" title="二.并发编程的问题"></a>二.并发编程的问题</h1><h2 id="线程引入开销：上下文切换与内存同步"><a href="#线程引入开销：上下文切换与内存同步" class="headerlink" title="线程引入开销：上下文切换与内存同步"></a>线程引入开销：上下文切换与内存同步</h2><p>使用多线程编程时影响性能的首先是线程的上下文切换。每个线程占有一个CPU的时间片，然后会保存该线程的状态，切换到下一个线程执行。线程的状态的保存与加载就是上下文切换。<br>减少上下文切换的方法有：无锁并发编程、CAS、使用最少线程、协程。</p><ul><li>1）无锁并发：通过某种策略（比如hash分隔任务）使得每个线程不共享资源，避免锁的使用。</li><li>2）CAS：是比锁更轻量级的线程同步方式</li><li>3）避免创建不需要的线程，避免线程一直处于等待状态</li><li>4）协程：单线程实现多任务调度，单线程维持多任务切换</li></ul><p><strong>vmstat可以查看上下文切换次数<br>jstack 可以dump 线程信息，查看一个进程中各个线程的状态</strong></p><ul><li>内存同步：在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，即内存栅栏。内存栅栏可以刷新缓存，使缓存失效，刷新硬件的写缓冲，以及停止执行管道。</li><li>内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制一些编译器优化操作。在内存栅栏中，大多数操作都是不能被重排序。<br>不要担心非竞争同步带来的开销，这个基本的机制已经非常快了，并且JVM还能进行额外的优化以进一步降低或消除开销。因此，我们应该将优化重点放在那些发生锁竞争的地方。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁后会陷入循环等待中。<br>如何避免死锁？</p><ul><li>1）避免一个线程同时获取多个锁</li><li>2）避免一个线程在锁内占用多个资源，尽量保证每个锁只占用一个资源</li><li>3）尝试使用定时锁tryLock替代阻塞式的锁</li><li>4）对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会解锁失败</li></ul><h1 id="线程安全性（原子性-可见性）"><a href="#线程安全性（原子性-可见性）" class="headerlink" title="线程安全性（原子性+可见性）"></a>线程安全性（原子性+可见性）</h1><ul><li><p>1、对象的状态：对象的状态是指存储在状态变量中的数据，对象的状态可能包括其他依赖对象的域。在对象的状态中包含了任何可能影响其外部可见行为的数据。</p></li><li><p>2、一个对象是否是线程安全的，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。同步机制包括synchronized、volatile变量、显式锁、原子变量。</p></li><li><p>3、有三种方式可以修复线程安全问题：</p><ul><li>1）不在线程之间共享该状态变量</li><li>2）将状态变量修改为不可变的变量</li><li>3）在访问状态变量时使用同步</li></ul></li><li><p>4、线程安全性的定义：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p></li><li><p>5、无状态变量一定是线程安全的，比如局部变量。</p></li><li><p>6、读取-修改-写入操作序列，如果是后续操作是依赖于之前读取的值，那么这个序列必须是串行执行的。在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它称为竞态条件（Race Condition）。最常见的竞态条件类型就是先检查后执行的操作，通过一个可能失效的观测结果来决定下一步的操作。</p></li><li><p>7、复合操作：要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。假定有两个操作A和B，如果从执行A的线程看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说就是原子的。原子操作是指，对于访问同一个状态的所有操作来说，这个操作是一个以原子方式执行的操作。<br>为了确保线程安全性，读取-修改-写入序列必须是原子的，将其称为复合操作。复合操作包含了一组必须以原子方式执行的接口以确保线程安全性。</p></li><li><p>8、在无状态的类中添加一个状态时，如果这个状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。（比如原子变量）</p></li><li><p>9、如果多个状态是相关的，需要同时被修改，那么对多个状态的操作必须是串行的，需要进行同步。要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p></li><li><p>10、内置锁：synchronized(object){同步块}<br>Java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等待下去。</p></li><li><p>11、重入：当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作的粒度是线程，而不是调用。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置1。如果一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值会相应递减。当计数值为0时，这个锁将被释放。</p></li><li><p>12、对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。<br>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。<br>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并提供对象的内置锁（this）对所有访问可变状态的代码路径进行同步。在这种情况下，对象状态中的所有变量都由对象的内置锁保护起来。</p></li><li><p>13、不良并发：要保证同步代码块不能过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。</p></li><li><p>14、可见性：为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p></li><li><p>15、加锁与可见性：当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证。加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步。</p></li><li><p>16、volatile变量：当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或其他对处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。volatile的语义不足以确保递增操作的原子性，除非你能确保只有一个线程对变量执行写操作。原子变量提供了“读-改-写”的原子操作，并且常常用做一种更好的volatile变量。</p></li><li><p>17、加锁机制既可以确保可见性，又可以确保原子性，而volatile变量只能确保可见性。</p></li><li><p>18、当且仅当满足以下的所有条件时，才应该使用volatile变量：</p><ul><li>1）对变量的写入操作不依赖变量的当前值（不存在读取-判断-写入序列），或者你能确保只有单个线程更新变量的值。</li><li>2）该变量不会与其他状态变量一起纳入不可变条件中</li><li>3）在访问变量时不需要加锁</li></ul></li><li><p>19、栈封闭：在栈封闭中，只能通过局部变量才能访问对象。维护线程封闭性的一种更规范的方法是使用ThreadLocal，这个类能使线程的某个值与保存值的对象关联起来，ThreadLocal通过了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。</p></li><li><p>20、在并发程序中使用和共享对象时，可以使用一些使用的策略，包括：</p><ul><li>1）线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li><li>2）只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象（从技术上来说是可变的，但其状态在发布之后不会再改变）。</li><li>3）线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。</li><li>4）保护对象。被保护的对象只能通过持有对象的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布并且由某个特定锁保护的对象。</li></ul></li><li><p>21、饥饿：当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿（某线程永远等待）。引发饥饿的最常见资源就是CPU时钟周期。比如线程的优先级问题。在Thread API中定义的线程优先级只是作为线程调度的参考。在Thread API中定义了10个优先级，JVM根据需要将它们映射到操作系统的调度优先级。这种映射是与特定平台相关的，因此在某个操作系统中两个不同的Java优先级可能被映射到同一优先级，而在另一个操作系统中则可能被映射到另一个不同的优先级。<br>当提高某个线程的优先级时，可能不会起到任何作用，或者也可能使得某个线程的调度优先级高于其他线程，从而导致饥饿。<br>通常，我们尽量不要改变线程的优先级，只要改变了线程的优先级，程序的行为就将与平台相关，并且会导致发生饥饿问题的风险。<br>事务T1封锁了数据R,事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T的请求……T2可能永远等待</p></li><li><p>22、活锁<br>活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发生在处理事务消息的应用程序中。如果不能成功处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。虽然处理消息的线程并没有阻塞，但也无法继续执行下去。这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误地将不可修复的错误作为可修复的错误。<br>当多个相互协作的线程都对彼此进行响从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。要解决这种活锁问题，需要在重试机制中引入随机性。在并发应用程序中，通过等待随机长度的时间和回退可以有效地避免活锁的发生。</p></li><li><p>23、当在锁上发生竞争时，竞争失败的线程肯定会阻塞。JVM在实现阻塞行为时，可以采用自旋等待（Spin-Waiting,指通过循环不断地尝试获取锁，直到成功），或者通过操作系统挂起被阻塞的线程。这两种方式的效率高低，取决于上下文切换的开销以及在成功获取锁之前需要等待的时间。如果等待时间较短，则适合采用自旋等待的方式，而如果等待时间较长，则适合采用线程挂起方式。</p></li><li><p>24、有两个因素将影响在锁上发生竞争的可能性：锁的请求频率，以及每次持有该锁的时间。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，会因此在该锁上的竞争不会对可伸缩性造成严重影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程将被阻塞并等待。在极端情况下，即使仍有大量工作等待完成，处理器也会被闲置。<br>有3种方式可以降低锁的竞争程度：</p><ul><li>1）减少锁的持有时间：<br>缩小锁的范围，将与锁无关的代码移出同步代码块，尤其是开销较大的操作以及可能被阻塞的操作（IO操作）。<br>当把一个同步代码块分解为多个同步代码块时，反而会对性能提升产生负面影响。在分解同步代码块时，理想的平衡点将与平台相关，但在实际情况中，仅可以将一些大量的计算或阻塞操作从同步代码块移出时，才应该考虑同步代码块的大小。<br>减小锁的粒度：锁分解和锁分段<br>锁分解是采用多个相互独立的锁来保护独立的状态变量，从而改变这些变量在之前由单个锁来保护的情况。这些技术能减小锁操作的粒度，并能实现更高的可伸缩性，然而，使用的锁越多，那么发生死锁的风险也就越高。<br>锁分段：比如JDK1.7及之前的ConcurrentHashMap采用的方式就是分段锁的方式。<ul><li>2）降低锁的请求频率</li><li>3）使用带有协调机制的独占锁，这些机制允许更高的并发性比如读写锁，并发容器等</li></ul></li></ul></li></ul><h1 id="四-线程间通信-线程同步-工具使用"><a href="#四-线程间通信-线程同步-工具使用" class="headerlink" title="四.线程间通信/线程同步 工具使用"></a>四.线程间通信/线程同步 工具使用</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized锁定的是对象而非代码，所处的位置是代码块或方法</p><h3 id="一种使用方法是对代码块使用synchronized关键字"><a href="#一种使用方法是对代码块使用synchronized关键字" class="headerlink" title="一种使用方法是对代码块使用synchronized关键字"></a>一种使用方法是对代码块使用synchronized关键字</h3><pre><code>public void fun(){    synchronized (this){ }}</code></pre><ul><li>括号中锁定的是普通对象或Class对象</li><li>如果是this，表示在执行该代码块时锁定当前对象，其他线程不能调用该对象的其他锁定代码块，但可以调用其他对象的所有方法(包括锁定的代码块)，也可以调用该对象的未锁定的代码块或方法。</li><li>如果是Object o1，表示执行该代码块的时候锁定该对象，其他线程不能访问该对象（该对象是空的，没有方法，自然不能调用）</li><li>如果是类.class，那么锁住了该类的Class对象，只对静态方法生效。</li></ul><h3 id="另一种写法是将synchronized作为方法的修饰符"><a href="#另一种写法是将synchronized作为方法的修饰符" class="headerlink" title="另一种写法是将synchronized作为方法的修饰符"></a>另一种写法是将synchronized作为方法的修饰符</h3><ul><li>public synchronized void fun() {} //这个方法执行的时候锁定该当前对象</li><li>每个类的对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的一个对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。</li><li>如果synchronized修饰的是静态方法，那么锁住的是这个类的Class对象，没有其他线程可以调用该类的这个方法或其他的同步静态方法。</li><li>实际上，synchronized(this)以及非static的synchronized方法，只能防止多个线程同时执行同一个对象的这个代码段。 synchronized锁住的是括号里的对象，而不是代码。对于非静态的synchronized方法，锁的就是对象本身也就是this。</li><li>获取锁的线程释放锁只会有两种情况：<ul><li>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>2）线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul></li></ul><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>锁是可重入的(reentrant),因为线程可以重复获得已经持有的锁。锁保持一个持有计数（hold count）来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。</p><pre><code>public class TestReentrantLock {   public static void main(String[] args) {      Ticket ticket = new Ticket();      new Thread(ticket, &quot;一号窗口&quot;).start();      new Thread(ticket, &quot;二号窗口&quot;).start();      new Thread(ticket, &quot;三号窗口&quot;).start();   }}class Ticket implements Runnable {   private int tickets = 100;   private Lock lock = new ReentrantLock();   @Override   public void run() {      while (true) {         lock.lock();         try {            Thread.sleep(50);            if(tickets &gt; 0){               System.out.println(Thread.currentThread().getName() + &quot;正在售票，余票为:&quot; + (--tickets));            }         } catch (InterruptedException e) {            e.printStackTrace();         } finally {            lock.unlock();         }      }   }}</code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>（作用是为成员变量的同步访问提供了一种免锁机制，如果声明一个成员变量是volatile的，那么会通知编译器和虚拟机这个成员变量是可能其他线程并发更新的<br>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的。</p><p>Java内存模型简要介绍（后面会详细介绍）：</p><ul><li>多线程环境下，会共享同一份数据（线程公共的内存空间）。为了提高效率，JVM会为每一个线程设置一个线程私有的内存空间（线程工作内存），并将共享数据拷贝过来。写操作实际上写的是线程私有的数据。当写操作完毕后，将线程私有的数据写回到线程公共的内存空间。</li><li>如果在写回之前其他线程读取该数据，那么返回的可能是修改前的数据，视读取线程的执行效率而定。</li><li>jvm运行时刻内存的分配：其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，（从线程内存中读值）</li><li>在修改完之后的某一个时刻（线程退出之前），把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。</li></ul><p>final修饰的变量是线程安全的</p><p>内存可见性问题是，当多个线程操作共享数据时，彼此不可见。<br>解决这个问题有两种方法：</p><ul><li>1、加锁：加锁会保证读取的数据一定是写回之后的，内存刷新。但是效率较低</li><li>2、volatile：会保证数据在读操作之前，上一次写操作必须生效，即写回。<ul><li>1）修改volatile变量时会强制将修改后的值刷新到主内存中。</li><li>2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。相较于synchronized是一种较为轻量级的同步策略，但是volatile不具备互斥性；不能保证修改变量时的原子性。<pre><code>public class TestVolatile {public static void main(String[] args) {MyThread myThread = new MyThread();new Thread(myThread).start();while(true){   synchronized (myThread) {      if(myThread.isFlag()){         System.out.println(&quot;flag被设置为true&quot;);         break;      }   }}}}</code></pre></li></ul></li></ul><p>class MyThread implements Runnable{<br>   private volatile boolean flag = false;<br>   public boolean isFlag() {<br>      return flag;<br>   }<br>   public void setFlag(boolean flag) {<br>      this.flag = flag;<br>   }<br>   @Override<br>   public void run() {<br>      try {<br>         Thread.sleep(200);<br>      } catch (InterruptedException e) {<br>         e.printStackTrace();<br>      }<br>      flag = true;<br>      System.out.println(“flag=”+flag);<br>   }<br>}</p><pre><code>## Atomic原子变量可以实现原子性+可见性# 五.Lock使用 深入## 可重入锁 ReentrantLock在一些内置锁无法满足需求的情况下，ReentrantLock可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，绑定多个条件以及非块结构的锁。否则，还是应该优先使用synchronized。- 1）可中断：lock()适用于锁获取操作不受中断影响的情况，此时可以忽略中断请求正常执行加锁操作，因为该操作仅仅记录了中断状态（通过Thread.currentThread().interrupt()操作，只是恢复了中断状态为true，并没有对中断进行响应)。如果要求被中断线程不能参与锁的竞争操作，则此时应该使用lockInterruptibly方法，一旦检测到中断请求，立即返回不再参与锁的竞争并且取消锁获取操作（即finally中的cancelAcquire操作）。- 2）可定时：tryLock(time)- 3）可轮询：tryLock()- 4）可公平：公平锁与非公平锁- 5）绑定多个条件：一个锁可以对应多个条件，而Object锁只能对应一个条件- 6）非块结构：加锁与解锁不是块结构的## Condition（与wait&amp;notify区别）BlockingQueue就是基于Condition实现的。一个Condition对象和一个Lock关联在一起，就像一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在相关联的Lock上调用Lock.newCondition方法。### Condition与wait&amp;notify区别![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8743.png)- 1）Condition比内置条件等待队列提供了更丰富的功能：在每个锁上可存在 可不响应中断、可等待至某个时间点、可公平的队列操作。wait&amp;notify一定响应中断并抛出遗产；Condition可以响应中断也可以不响应中断- 2）与内置条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。- await() awaitUninterruptibly() await(time) Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会按照FIFO顺序从Condition.await中释放。### await&amp;signal![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8744.png)await被中断会抛出InterruptedException。Condition区分开了不同的条件谓词，更容易满足单次通知的需求。signal比signalAll更高效，它能极大地减少在每次缓存操作中发生的上下文切换与锁请求的次数。线程进入临界区（同步块）时，发现必须要满足一定条件才能执行。要使用一个条件对象来管理那些已经获得一个锁但是不能做有用工作的线程条件对象也称为条件变量一个锁对象可以有多个相关的条件对象，newCondition方法可以获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。当发现条件不满足时，调用Condition对象的await方法此时线程被阻塞，并放弃了锁。等待其他线程的相关操作使得条件达到满足等待获得锁的线程和调用await方法的线程有本质区别。一旦一个线程调用await方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞，相反，它处于阻塞状态，直到另一个线程调用同一个条件的signalAll方法为止await方法和signalAll方法是配套使用的await进入等待，signalAll解除等待signalAll方法会重新激活因为这一条件而等待的所有线程。当这些线程从等待集中移出时，它们再次成为可运行的，线程调度器将再次激活它们。同时它们将试图重新进入该对象。一旦锁可用，它们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行线程应该再次测试该条件。由于无法确保该条件被满足，signalAll方法仅仅是通知正在等待的线程，此时有可能满足条件，值得再次去检测该条件对于await方法的调用应该用在这种形式：</code></pre><p>while(!(ok to continue)){<br>    condition.await();<br>}</p><pre><code>最重要的是需要其他某个线程调用signalAll方法。当一个线程调用await方法，它没有办法去激活自身，只能寄希望于其他线程。如果没有其他线程来激活等待的线程，那么就会一直等待，出现死锁。如果所有其他线程都被阻塞，且最后一个线程也调用了await方法，那么它也被阻塞，此时程序挂起。signalAll方法不会立刻激活一个等待的线程，仅仅是解除等待线程的阻塞，以便这些线程可以在当前线程（调用signalAll方法的线程）退出时，通过竞争来实现对对象的方法这个await和signalAll方法的组合类似于Object对象的wait和notifyAll方法的组合</code></pre><p>public class ConditionBoundedBuffer<T>  {<br>    private static final int BUFFER_SIZE = 20;<br>    protected final Lock lock = new ReentrantLock();<br>    private final Condition notFull = lock.newCondition();</p><pre><code>private final Condition notEmpty = lock.newCondition();private final T[] items = (T[]) new Object[BUFFER_SIZE];private int tail;private int head;private int count;public void put(T t) throws InterruptedException {    lock.lock();    try {        while(count == items.length){            notFull.await();        }        items[tail] = t;        if(++tail == items.length){            tail = 0;        }        ++count;        notEmpty.signal();    } finally {        lock.unlock();    }}public T take() throws InterruptedException {    lock.lock();    try{        while(count == 0){            notEmpty.await();        }        T t = items[head];        items[head] = null;        if(++head == items.length){            head = 0;        }        --count;        notFull.signal();        return t;    }finally {        lock.unlock();    }}</code></pre><p>}</p><pre><code>## 公平锁</code></pre><p>public ReentrantLock(boolean fair) {<br>    sync = fair ? new FairSync() : new NonfairSync();<br>}</p><pre><code>在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。     非公平的ReentrantLock 并不提倡插队行为，但是无法防止某个线程在合适的时候进行插队。非公平锁性能高于公平锁性能的原因：在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。假设线程A持有一个锁，并且线程B请求这个锁。由于锁被A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此B会再次尝试获取这个锁。与此同时，如果线程C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样就是一种双赢的局面：B获得锁的时刻并没有推迟，C更早的获得了锁，并且吞吐量也提高了。当持有锁的时间相对较长或者请求锁的平均时间间隔较长，应该使用公平锁。在这些情况下，插队带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）可能不会出现。非公平锁可能会引起线程饥饿，但是线程切换更少，吞吐量更大## 读写锁 ReentrantReadWriteLock读写锁是一种性能优化措施，在一些特定的情况下能实现更高的并发性。在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读写锁能够提高性能。而在其他情况下，读写锁的性能比独占锁的性能要略差一些，这是因为它们的复杂性更高。如果要判断在某种情况下使用读写锁是否会带来性能提升，最好对程序进行分析。由于ReadWriteLock使用Lock来实现锁的读写部分，因此如果分析结果表明读写锁没有提高性能，那么可以很容易地将读写锁换为独占锁。ReentrantReadWriteLock 如果很多线程从一个数据结构中读取数据而很少线程修改其中数据，那么允许对读的线程共享访问是合适的。读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！特性：- (a).重入方面其内部的写锁可以获取读锁，但是反过来读锁想要获得写锁则永远都不要想。 - (b).写锁可以降级为读锁，顺序是：先获得写锁再获得读锁，然后释放写锁，这时候线程将保持读锁的持有。反过来读锁想要升级为写锁则不可能，为什么？参看(a)- (c) 读锁不能升级为写锁，目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。- (d).读锁可以被多个线程持有并且在作用时排斥任何的写锁，而写锁则是完全的互斥。这一特性最为重要，因为对于高读取频率而相对较低写入的数据结构，使用此类锁同步机制则可以提高并发量。 - (e).不管是读锁还是写锁都支持Interrupt，语义与ReentrantLock一致。 - (f).写锁支持Condition并且与ReentrantLock语义一致，而读锁则不能使用Condition，否则抛出UnsupportedOperationException异常。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8745.png)</code></pre><p>public class TestReadWriteLock {<br>    public static void main(String[] args) {<br>        ReadWriteLockDemo demo = new ReadWriteLockDemo();<br>        for (int i = 0; i &lt; 100; ++i) {<br>            new Thread(new Runnable() {</p><pre><code>            @Override            public void run() {                demo.get();            }        }, &quot;Read&quot; + i).start();    }    new Thread(new Runnable() {        @Override        public void run() {            demo.set(222);        }    }, &quot;Write&quot;).start();}</code></pre><p>}</p><p>class ReadWriteLockDemo {<br>    private ReadWriteLock lock = new ReentrantReadWriteLock();<br>    private int data = 2;</p><pre><code>public void get() {    lock.readLock().lock();    try {        System.out.println(&quot;读操作  &quot; + Thread.currentThread().getName() + &quot;:&quot; + data);    } finally {        lock.readLock().unlock();    }}public void set(int data) {    lock.writeLock().lock();    try {        System.out.println(&quot;写操作  &quot; + Thread.currentThread().getName() + &quot;:&quot; + data);        this.data = data;    } finally {        lock.writeLock().unlock();    }}</code></pre><p>}</p><pre><code>## LockSupport（锁住的是线程，synchronized锁住的是对象）当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(thread)方法来唤醒一个被阻塞的线程。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8745.png)park等方法还可以传入阻塞对象，有阻塞对象的park方法在dump线程时可以给开发人员更多的现场信息。park对于中断只会设置中断标志位，不会抛出InterruptedException。LockSupport是可不重入的，如果一个线程连续2次调用 LockSupport .park()，那么该线程一定会一直阻塞下去unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。LockSupport.park()和unpark()，与object.wait()和notify()的区别？   主要的区别应该说是它们面向的对象不同。阻塞和唤醒是对于线程来说的，LockSupport的park/unpark更符合这个语义，以“线程”作为方法的参数， 语义更清晰，使用起来也更方便。而wait/notify的实现使得“阻塞/唤醒对线程本身来说是被动的，要准确的控制哪个线程、什么时候阻塞/唤醒很困难， 要不随机唤醒一个线程（notify）要不唤醒所有的（notifyAll）。park/unpark模型真正解耦了线程之间的同步。线程之间不再须要一个Object或者其他变量来存储状态。不再须要关心对方的状态。## synchronized与Lock的区别- 1）层次：前者是JVM实现，后者是JDK实现- 2）功能：前者仅能实现互斥与重入，后者可以实现 可中断、可轮询、可定时、可公平、绑定多个条件、非块结构synchronized在阻塞时不会响应中断，Lock会响应中断，并抛出InterruptedException异常。- 3）异常：前者线程中抛出异常时JVM会自动释放锁，后者必须手工释放- 4）性能：synchronized性能已经大幅优化，如果synchronized能够满足需求，则尽量使用synchronized# 六.原子操作类使用- 1、近年来，在并发算法领域的大多数研究都侧重于非阻塞算法，这种算法用底层的原子机器指令（compareAndSwap）代替锁来确保数据在并发访问中的一致性。非阻塞算法被广泛地用于在操作系统和JVM中实现进程/线程调度机制、垃圾回收机制以及锁和其他并发数据结构。非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调，并且极大地减少调度开销。而且，在非阻塞算法中不存在死锁和其他活跃性问题。在基于锁的算法中，如果一个线程在休眠或自旋的同时持有一个锁，那么其他线程都无法执行下去，而非阻塞算法不会受到单个线程失败的影响。非阻塞算法常见应用是原子变量类。即使原子变量没有用于非阻塞算法的开发，它们也可以用作一个更好的volatile类型变量。原子变量提供了与volatile类型变量相同的内存语义，此外还支持原子的更新操作，从而使它们更加适用于实现计数器、序列发生器和统计数据收集等，同时还能比基于锁的方法提供更高的可伸缩性。- 2、锁的缺点：    - 1）在挂起和恢复线程等过程中存在着很大的开销，并且通常存在着较长时间的中断。    - 2）volatile变量同样存在一些局限：虽然它们提供了相似的可见性保证，但不能用于构建原子的操作。    - 3）当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。    - 4）总之，锁定方式对于细粒度的操作（比如递增计数器）来说仍然是一种高开销的机制。在管理线程之间的竞争应该有一种粒度更细的技术，比如CAS。- 3、独占锁是一种悲观技术。对于细粒度的操作，还有另外一个更高效的办法，也是一种乐观的办法，通过这种方法可以在不发生干扰的情况下完成更新操作。这种方法需要借助冲突检查机制来判断在更新过程中是否存在来自其他线程的干扰，如果存在，这个操作将失败，并且可以重试。在针对多处理器操作而设计的处理器中提供了一些特殊的指令，用于管理对共享数据的并发访问。在早期的处理器中支持原子的测试并设置（Test-and-Set），获取并递增（Fetch-and-increment）以及交换（swap）指令。现在几乎所有的现代处理器都包含了某种形式的原子读-改-写指令，比如比较并交换（compare-and-swap）等。- 4、CAS包含了三个操作数——需要读写的内存位置V，进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会以原子方式用新值B来更新V的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值。CAS的含义是：我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8747.png)上面这段代码模拟了CAS操作（但实际上不是基于synchronized实现的原子操作，而是由操作系统支持的）。当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。然而，失败的线程并不会被挂起，而是被告知在这次竞争中失败，并可以再次尝试。由于一个线程在竞争CAS时失败不会被阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何操作。这种灵活性就大大减少了与锁相关的活跃性风险。- 5、基于CAS实现的非阻塞计数器![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8748.png)- 6、初看起来，基于CAS的计数器似乎比基于锁的计数器在性能上更差一些，因为它需要执行更多的操作和更复杂的控制流，并且还依赖看似复杂的CAS操作。但实际上，当竞争程序不高时，基于CAS的计数器在性能上远远超过了基于锁的计数器，而在没有竞争时甚至更高。如果要快速获取无竞争的锁，那么至少需要一次CAS操作再加上与其他锁相关操作，因此基于锁的计数器即使在更好的情况下也会比基于CAS的计数器在一般情况下能执行更多的操作。CAS的主要缺点是，它将使调用者处理竞争问题，而在锁中能自动处理竞争问题。- 7、原子变量比锁的粒度更细，量级更轻，并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的。原子变量将发生竞争的范围缩小到单个变量上，这是你获得的粒度最细的情况。更新原子变量的快速路径不会比获取锁的路径慢，并且通常会更快，而它的慢速路径肯定比锁的慢速路径快，因为它不需要挂起或重新调度线程。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。共用12个原子变量类，可分为4组：标量类、更新器类、数组类以及复合变量类。原子数组类中的元素可以实现原子更新。原子数组类中的元素可以实现原子更新。原子数组类为数组的元素提供了volatile类型的访问语义，这是普通数组锁不具备的特性——volatile类型的数组仅在数组引用上具有volatile语义，而在其元素上则没有。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8749.png)- 8、ABA问题有时候还需要知道“自从上次看到V的值为A以来，这个值是否发生了变化”，在某些算法中，如果V的值首先由A变为B，再由B变为A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。有一个相对简单的解决方案：不是更新某个引用的值，而是更新两个值，包括一个引用和一个版本号。即使这个值由A变为B，然后又变为A，版本号也将是不同的。AtomicStampedReference支持在两个变量上执行原子的条件更新。AtomicStampedReference将更新一个“对象-引用”二元组，通过在引用上加上：“版本号”，从而避免ABA问题。类似地，AtomicMarkableRefernce将更新一个“对象引用-布尔值”二元组，在某些算法中将通过这种二元组使节点保存在链表中同时又将其标记为“已删除的节点”。CAS存在ABA，循环时间长开销大，以及只能保证一个共享变量的原子操作（变量合并，AtomicReference）三个问题。# 七.Java内存模型 线程同步工具原理## JMM Java Memory Model### JMM抽象结构在Java中，堆内存在线程之间共享，线程之间的通信由Java内存模型JMM控制。线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存（并不真实存在），本地内存中存储了线程读写共享变量的副本。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8750.png)如果线程A与线程B之间要通信的话,必须要经历下面2个步骤：- 1)线程A把本地内存A中更新过的共享变量刷新到主内存中去。- 2)线程B到主内存中去读取线程A之前已更新过的共享变量。### 指令重排序- 在执行程序时，为了提高性能，编译器和CPU常常会对指令进行重排序，分为以下3种类型：- 1、编译优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句执行顺序。- 2、指令级并行的重排序。CPU采用了指令级并行技术将多条指令重叠执行。- 3、内存系统的重排序。由于CPU使用cache和读/写缓冲区，因此加载和存储操作可能在乱序执行。![](https://github.com/gzc426/picts/raw/master/%E5%9B%BE%E7%89%8751.png)- 1属于编译器重排序,2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。- 对于编译器,JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。- 对于处理器重排序,JMM的处理器重排序规则会要求Java编译器在生成指令序列时,插入特定类型的内存屏障(Memory Barriers,Intel称之为Memory Fence)指令,通过内存屏障指令来禁止特定类型的处理器重排序。### 内存屏障JMM把内存屏障分为四类：- LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。- StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。- LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。- StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。### happens-before（抽象概念，基于内存屏障）JDK1.5后，Java采用JSR133内存模型，通过happens-before概念来阐述操作之间的内存可见性。在JMM中，**如果一个操作执行的结果要对另一个操作可见，那么这两个操作之间必须要有happens-before关系。**定义：- 1)如果一个操作happens-before另一个操作,那么第一个操作的执行结果将对第二个操作可见,而且第一个操作的执行顺序排在第二个操作之前。- 2)两个操作之间存在happens-before关系,并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果,与按happens-before关系来执行的结果一致,那么这种重排序并不非法(也就是说,JMM允许这种重排序)。- 上面的1)是JMM对程序员的承诺。从程序员的角度来说,可以这样理解happens-before关系:如果A happens-before B,那么Java内存模型将向程序员保证——A操作的结果将对B可见,且A的执行顺序排在B之前。注意,这只是Java内存模型向程序员做出的保证!- 上面的2)是JMM对编译器和处理器重排序的约束原则。正如前面所言,JMM其实是在遵循一个基本原则:只要不改变程序的执行结果(指的是单线程程序和正确同步的多线程程序)编译器和处理器怎么优化都行。JMM这么做的原因是:程序员对于这两个操作是否真的被重排序并不关心,程序员关心的是程序执行时的语义不能被改变(即执行结果不能被改变)。因此,happens-before关系本质上和as-if-serial语义是一回事。与程序员密切相关的happens-before规则如下。- 1）程序顺序规则:一个线程中的每个操作,happens-before于该线程中的任意后续操作。（单线程顺序执行）- 2）监视器锁规则:对一个锁的解锁,happens-before于随后对这个锁的加锁。（先解锁后加锁）比如:    - lock.unlock();    - lock.lock();    - 那么不会重排序，因为重排序后肯定会发生死锁- 3）volatile变量规则:对一个volatile域的写,happens-before于任意后续对这个volatile域的读。（先写后读）- 4）传递性:如果A happens-before B,且B happens-before C,那么A happens-before C。- 5）start规则:如果线程A执行操作ThreadB.start()，那么A线程的ThreadB.start() happens-before于线程B的任意操作。- 6）join规则:如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。**happens-before与JMM的关系如下：**## 指令重排序重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。### 数据依赖性- 对于单个CPU和单个线程中所执行的操作而言，如果两个操作都访问了同一个变量，且两个操作中有写操作，那么这两个操作就具有数据依赖性。- **（RW,WW,WR）这三种操作只要重排序对操作的执行顺序，程序的执行结果就会被改变，因此，编译器和处理器在进行重排序的时候会遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序。**### as-if-serial- as-if-serial：无论如何重排序，（单线程）程序的执行结果不能被改变。编译器，runtime，CPU都必须遵守as-if-serial语义，因此，编译器和CPU不会对存在数据依赖关系的操作进行重排序。- 在单线程中，对存在控制依赖性的操作进行重排序，不会改变执行结果，而在多线程中则可能会改变结果。## 顺序一致性程序未正确同步的时候，就可能存在数据竞争。数据竞争：- 1）在一个线程中写一个变量- 2）在另一个线程中读同一个变量- 3）而且写和读没有通过同步来排序。JMM对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序的顺序一致性内存模型的执行结果相同。顺序一致性模型有两大特性：- 1）一个线程中的所有操作必须按照程序的顺序来执行- 2）不管程序是否同步，所有线程都只能看到单一的操作执行顺序。每个操作都必须原子执行且立即对所有线程可见。JMM中，临界区内的代码可以重排序。而对于未正确同步的多线程程序，JMM只提供最小的安全性：线程执行时所读取到的值，要么是之前某个线程所写入的值，要么是默认值。## volatile原理### 汇编上的实现volatile修饰的共享变量在转换为汇编语言后，会出现Lock前缀指令，该指令在多核处理器下引发了两件事：- 1、将当前处理器缓存行（CPU cache中可以分配的最小存储单位）的数据写回到系统内存。- 2、这个写回内存的操作使得其他CPU里缓存了该内存地址的数据无效。（当前CPU该变量的缓存回写；其他CPU该变量的缓存失效）### 内存语义volatile写的内存语义：- 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存volatile读的内存语义：- 当读一个volatile变量时，JMM会把线程对应的本地内存置为无效，线程接下来将从主内存读取共享变量一个volatile变量的单个读写操作，与一个普通变量的读写操作使用同一个锁来同步，它们的执行效果相同。锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这也意味着对一个volatile变量的读操作，总是能看到任意线程对该变量最后的写入。对于volatile变量本身的单个读写操作具有原子性，但是与锁不同的是，多个对于volatile变量的复合操作不具有原子性。而锁的语义保证了临界区代码的执行具有原子性。JAVA1.5后，JSR-133增强了volatile的内存语义，严格限制编译器和CPU对于volatile变量与普通变量的重排序，从而确保volatile变量的写-读操作可以实现线程之间的通信，提供了一种比锁更轻量级的线程通信机制。从内存语义的角度而言，volatile的写-读与锁的释放-获取有相同的内存效果：写操作=锁的释放；读操作=锁的获取。A线程写一个volatile变量x后，B线程读取x以及其他共享变量。- 1. 当A线程对x进行写操作时，JMM会把该线程A对应的cache中的共享变量值刷新到主存中.（实质上是线程A向接下来要读变量x的线程发出了其对共享变量修改的消息）- 2.当B线程对x进行读取时，JMM会把该线程对应的cache值设置为无效，而从主存中读取x。（实质上是线程B接收了某个线程发出的对共享变量修改的消息）两个步骤综合起来看，在线程B读取一个volatile变量x后，线程A本地cache中在写这个变量x之前所有其他可见的共享变量的值都立即变得对B可见。线程A写volatile变量x，B读x的过程实质上是线程A通过主存向B发送消息。需要注意的是，由于volatile仅仅保证对单个volatile变量的读写操作具有原子性，而锁的互斥则可以确保整个临界区代码执行的原子性。### 内存语义的实现（内存屏障）- 在每个volatile写操作的前面插入一个StoreStore屏障- 在每个volatile写操作的后面插入一个StoreLoad屏障- 在每个volatile读操作的后面插入一个LoadLoad屏障- 在每个volatile读操作的后面插入一个LoadStore屏障StoreStore屏障；（禁止上面的普通写和下面的volatile写重排序，保证上面所有的普通写在volatile写之前刷新到主内存）volatile写；StoreLoad屏障；（禁止上面的volatile写和下面的volatile读/写重排序）volatile读；LoadLoad屏障；LoadStore屏障；**从汇编入手分析volatile多线程问题**- 1、普通方式int i，执行i++：![图片1.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418aov6j30mv03mmxg.jpg)普通方式没有任何与锁有关的指令；其他方式都出现了与锁相关的汇编指令lock。解释指令：其中edi为32位寄存器。如果是long则为64位的rdi寄存器。- 2、volatile方式volatile int i，执行i++：![图片2.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418anvhj30my03lmxe.jpg)指令“lock; addl $0,0(%%esp)”表示加锁，把0加到栈顶的内存单元，该指令操作本身无意义，但这些指令起到内存屏障的作用，让前面的指令执行完成。具有XMM2特征的CPU已有内存屏障指令，就直接使用该指令。volatile字节码为：![图片3.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418bl7dj30fv0shtas.jpg)## synchronized原理### monitor代码块同步是使用monitorenter和monitorexit指令实现。monitorenter和monitorexit指令是在编译后插入到同步代码块开始和结束的的位置。任何一个对象都有一个monitor与之关联，当一个monitor被某个线程持有之后，该对象将处于锁定状态。线程执行到monitorenter指令时，会尝试获取该对象对应的monitor所有权，也即获得对象的锁。monitorenter ：每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：- 1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。- 2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.- 3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。monitorexit：执行monitorexit的线程必须是对象所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。**其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因**在HotSpotJVM实现中，锁有个专门的名字：对象监视器。### 汇编上的实现（cmpxchg）synchronizied方式实现i++字节码：![图片4.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418bfy2j30f50ihq3z.jpg)汇编![图片5.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418ciyij30z90xn42b.jpg)monitorenter与monitorexit包裹了getstatic i及putstatic i，等相关代码执行指令。中间值的交换采用了原子操作lock cmpxchg %rsi,(%rdi)，如果交换成功，则执行goto直接退出当前函数return。如果失败，执行jne跳转指令，继续循环执行，直到成功为止。cmpxchg指令：比较rsi和目的操作数rdi(第一个操作数)的值，如果相同，ZF标志被设置，同时源操作数(第二个操作)的值被写到目的操作数，否则，清ZF标志为0，并且把目的操作数的值写回rsi，则执行jne跳转指令。### Java对象头synchronized用的锁放在java对象头里。有两种情况：数组对象，虚拟机使用3个字宽存储对象头。非数组对象，则使用2个字宽来存储对象头。32位虚拟机中，1个字宽等于4字节，即32字节。 长度  | 内容  |说明  ------------- | -------------  | ------------- 32/64bit | mark word  | 存储对象的hashCode或者锁信息32/64bit  | Class metadata address  |  存储对象描述数据的指针32/64bit  | Array length |  数组的长度Mark Word 的存储结构：![图片6.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418bpmsj30ng06b0u2.jpg)### 锁的分类- synchronized是重量级锁，效率较低。- synchronized所用到的锁是存在Java对象头中。在Java1.6中，锁一共有4种状态，由低到高依次是：无锁，偏向锁，轻量级锁，重量级锁，这几种状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。- monitorenter和monitorexit是上层指令，底层实现可能是偏向锁、轻量级锁、重量级锁等。![图片7.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418covtj30wy0fkq4h.jpg)#### 偏向锁（只有一个线程进入临界区）&gt;引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。- 加锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程（此时会引发竞争，偏向锁会升级为轻量级锁）。- 膨胀过程：当前线程执行CAS获取偏向锁失败（这一步是偏向锁的关键），表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，并从偏向锁所有者的私有Monitor Record列表中获取一个空闲的记录，并将Object设置LightWeight Lock状态并且Mark Word中的LockRecord指向刚才持有偏向锁线程的Monitor record，最后被阻塞在安全点的线程被释放，进入到轻量级锁的执行路径中，同时被撤销偏向锁的线程继续往下执行同步代码。- 偏向锁，顾名思义，它会偏向于第一个获取锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程尝试获取，则持有偏向锁的线程将永远不需要触发同步。在锁对象的对象头中有个偏向锁的线程ID字段，这个字段如果是空的，第一次获取锁的时候，就CAS将自身的线程ID写入到MarkWord的偏向锁线程ID字段内，将MarkWord中的偏向锁的标识置1。这样下次获取锁的时候，直接检查偏向锁线程ID是否和自身线程ID一致，如果一致，则认为当前线程已经获取了锁，因此不需再次获取锁；- 如果不一致，则表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）![图片8.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418euloj30o10qxwg1.jpg)#### 轻量级锁（多个线程交替进入临界区）- 引入背景：轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。- 轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋重试。重试一定次数后膨胀为重量级锁（修改MarkWord，改为指向重量级锁的指针），阻塞当前线程。- 轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示有其他线程尝试获得锁，则释放锁，并唤醒被阻塞的线程。![图片9.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418dvcaj30o10nc407.jpg)#### 重量级锁（多个线程同时进入临界区）在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。### 锁的比较![图片10.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418dkizj30hc0au3zd.jpg)### 锁的优化&gt;Java1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。#### 自旋锁线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。 **何谓自旋锁？**- 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。 - 自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了规定的时间仍然没有获取到锁，则应该被挂起。#### 适应性自旋锁- JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由上一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。- 反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要获得这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。#### 锁消除为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。#### 锁粗化</code></pre><pre><code>public void vectorTest(){    Vector&lt;String&gt; vector = new Vector&lt;String&gt;();    for(int i = 0 ; i &lt; 10 ; i++){        vector.add(i + &quot;&quot;);    }    System.out.println(vector);}</code></pre><pre><code>- 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 - 在大多数的情况下，上述观点是正确的。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗化的概念。 - 锁粗化是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。![图片11.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418dyi2j30o10nc407.jpg)## 原子操作原理CAS操作的意思是比较并交换，它需要两个数值，一个旧值（期望操作前的值）和新值。操作之前比较两个旧值是否变化，如无变化才交换为新值。### CPU如何实现原子操作- **1）在硬件层面，CPU依靠总线加锁和缓存锁定机制来实现原子操作。**    - 使用总线锁保证原子性。如果多个CPU同时对共享变量进行写操作（i++），通常无法得到期望的值。CPU使用总线锁来保证对共享变量写操作的原子性，当CPU在总线上输出LOCK信号时，其他CPU的请求将被阻塞住，于是该CPU可以独占共享内存。    - 使用缓存锁保证原子性。频繁使用的内存地址的数据会缓存于CPU的cache中，那么原子操作只需在CPU内部执行即可，不需要锁住整个总线。缓存锁是指在内存中的数据如果被缓存于CPU的cache中，并且在LOCK操作期间被锁定，那么当它执行锁操作写回到内存时，CPU修改内部的内存地址，并允许它的缓存一致性来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器 缓存的 内存区域数据。当其他CPU回写被锁定的cache行数据时候，会使cache行无效。### Java如何实现原子操作- **2）Java使用了锁和循环CAS的方式来实现原子操作。**    - 使用循环CAS实现原子操作。JVM的CAS操作使用了CPU提供的CMPXCHG指令来实现，自旋式CAS操作的基本思路是循环进行CAS操作直到成功为止。1.5之后的并发包中提供了诸如AtomicBoolean, AtomicInteger等包装类来支持原子操作。CAS存在ABA，循环时间长开销大，以及只能保证一个共享变量的原子操作三个问题。    - cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。    - 使用锁机制实现原子操作。锁机制保证了只有获得锁的线程才能给操作锁定的区域。JVM的内部实现了多种锁机制。除了偏向锁，其他锁的方式都使用了循环CAS，也就是当一个线程想进入同步块的时候，使用循环CAS方式来获取锁，退出时使用CAS来释放锁。### CAS在OpenJDK中的实现以compareAndSwapInt为例：</code></pre><p>UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv <em>env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  UnsafeWrapper(“Unsafe_CompareAndSwapInt”);<br>  oop p = JNIHandles::resolve(obj);<br>  jint</em> addr = (jint *) index_oop_from_field_offset_long(p, offset);<br>  return (jint)( (x, addr, e)) == e;<br>UNSAFE_END</p><pre><code>linux下</code></pre><p>inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {<br>  int mp = os::is_MP();<br>  <strong>asm</strong> volatile (LOCK_IF_MP(%4) “cmpxchgl %1,(%3)”<br>                    : “=a” (exchange_value)<br>                    : “r” (exchange_value), “a” (compare_value), “r” (dest), “r” (mp)<br>                    : “cc”, “memory”);<br>  return exchange_value;<br>}</p><pre><code>程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpchg指令加上lock前缀；如果是在单处理器上运行，就省略lock前缀。Intel对lock前缀的说明如下：- 1）确保对内存的读-改-写操作原子执行（基于总线锁或缓存锁）- 2）禁止该指令，与 之前 和 之后 的读写指令重排序- 3）把写缓冲区中的所有数据刷新到内存中。# 同步容器同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代，跳跃，以及条件运算。## ConcurrentHashMap它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要再迭代过程中对容器加锁。ConcurrentHasMap返回的迭代器具有弱一致性，而并非及时失败。弱一致性的迭代器可以容忍并发的修改，当修改迭代器会遍历已有的元素，并可以在迭代器被构造后将修改操作反映给容器。## CopyOnWriteArrayList- 用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。写入时复制容器返回的迭代器不会抛出- ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。- 显然，每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时，仅当迭代操作远远多于修改操作时，才应该使用写入时复制容器。## BlockingQueue- 阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远都不会充满，因此无界队列上的put方法也永远不会阻塞。- 在构建高可靠的应用程序时，有界队列ArrayBlockingQueue是一种强大的资源管理工具：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变得更加健壮。## ThreadLocal在线程之间共享变量是存在风险的，有时可能要避免共享变量，使用ThreadLocal辅助类为各个线程提供各自的实例。例如有一个静态变量</code></pre><p>public static final SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”);</p><pre><code>如果两个线程同时调用sdf.format(…)那么可能会很混乱，因为sdf使用的内部数据结构可能会被并发的访问所破坏。当然可以使用线程同步，但是开销很大；或者也可以在需要时构造一个局部SImpleDateFormat对象。但这很浪费# 同步工具使用## Semaphore（信号量）- 信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。- Semaphore中管理着一组虚拟的许可permit，许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用作互斥体，并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。- 可以用于实现资源池，当池为空时，请求资源将会阻塞，直至存在资源。将资源返回给池之后会调用release释放许可。</code></pre><p>public class BoundedHashSet<T> {<br>    private final Set<T> set;<br>    private final Semaphore semaphore;</p><pre><code>public BoundedHashSet(int bound) {    this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());    this.semaphore = new Semaphore(bound);}public boolean add(T t) throws InterruptedException {    semaphore.acquire();    boolean wasAdded = false;    try {        wasAdded = set.add(t);        return wasAdded;    } finally {        if(!wasAdded){            semaphore.release();          }    }}public boolean remove(Object o){    boolean wasRemoved = set.remove(o);    if(wasRemoved){        semaphore.release();    }    return wasRemoved;}</code></pre><p>}</p><pre><code>## CyclicBarrier（可循环使用的屏障/栅栏）CountDownLatch  | CyclicBarrier  ------------- | -------------  减计数方式 | 加计数方式计算为0时释放所有等待的线  | 计数达到指定值时释放所有等待线程计算为0时释放所有等待的线程  | 计数达到指定值时释放所有等待线程计数为0时，无法重置 | 计数达到指定值时，计数置为0重新开始调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响  | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞不可重复利用  | 可重复利用- 线程在countDown()之后，会继续执行自己的任务，而CyclicBarrier会在所有线程任务结束之后，才会进行后续任务。- Barrier类似于闭锁，它能阻塞一组线程直到某个线程发生。栅栏与闭锁的关键区别在于，前者未达到条件时每个线程都会阻塞在await上，直至条件满足所有线程解除阻塞，后者未达到条件时countDown不会阻塞，条件满足时会解除await线程的阻塞。- CyclicBarrier可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用；这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都达到栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。- 如果对await方法的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都被终止并抛出BrokenBarrierException。如果成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来选举产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会在一个子任务线程中执行它。- 可以用于多线程计算数据，最后合并计算结果的场景。CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset方法重置。</code></pre><p>/**</p><ul><li><p>通过CyclicBarrier协调细胞自动衍生系统中的计算</p></li><li><p>/<br>public class CellularAutomata {<br>  private final Board mainBoard;<br>  private final CyclicBarrier cyclicBarrier;<br>  private final Worker[] workers;</p><p>  public CellularAutomata(Board board){</p><pre><code>  this.mainBoard = board;  int count = Runtime.getRuntime().availableProcessors();  this.cyclicBarrier = new CyclicBarrier(count, new Runnable() {      public void run() {          mainBoard.commitNewValues();      }  });  this.workers = new Worker[count];  for (int i = 0; i &lt; count; i++) {      workers[i] = new Worker(mainBoard.getSubBoard(count,i));  }</code></pre><p>  }</p><p>  private class Worker implements Runnable{</p><pre><code>  private final Board board;  public Worker(Board board){      this.board = board;  }  public void run() {      while (!board.hasConverged()) {          for (int x = 0; x &lt; board.getMaxX(); x++) {              for (int y = 0; y &lt; board.getMaxY(); y++) {                  board.setNewValue(x, y, computeValue(x, y));              }          }          try {              cyclicBarrier.await();          } catch (InterruptedException e) {              e.printStackTrace();          } catch (BrokenBarrierException e) {              e.printStackTrace();              return;          }      }  }</code></pre><p>  }</p><p>  private int computeValue(int x, int y) {</p><pre><code>  return x+y;</code></pre><p>  }</p></li></ul><pre><code>public void start(){    for (int i = 0; i &lt; workers.length; i++) {        new Thread(workers[i]).start();    }    mainBoard.waitForConvergence();}</code></pre><p>}</p><pre><code>## Exchanger（两个线程交换数据）- 另一种形式的栅栏是Exchanger，它是一种两方栅栏，各方在栅栏位置上交换数据。当两方执行不对称的操作时，Exchanger会非常有用。- Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</code></pre><p>public class TestExchanger {</p><pre><code>private Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;();private ExecutorService threadPool = Executors.newFixedThreadPool(2);public void start() {    threadPool.execute(new Runnable() {        @Override        public void run() {            try {                String A = &quot;银行流水A&quot;;// A录入银行流水数据                exchanger.exchange(A);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    threadPool.execute(new Runnable() {        @Override        public void run() {            try {                String B = &quot;银行流水B&quot;;// B录入银行流水数据                String A = exchanger.exchange(&quot;B&quot;);                System.out.println(&quot;A和B数据是否一致：&quot; + A.equals(B) + &quot;,A录入的是：&quot;                        + A + &quot;,B录入是：&quot; + B);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    });    threadPool.shutdown();}public static void main(String[] args) {    new TestExchanger().start();}</code></pre><p>}</p><pre><code>## CountDownLatch（闭锁）- 闭锁可以延迟线程的进度直到其达到终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。当闭锁达到结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动指导其他活动都完成后才继续执行。- 闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件发生了，而await方法等待计数器达到0，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为0，或者等待中的线程中断，或者等待超时。</code></pre><p>public class TestCountDownLatch {<br>    public static void main(String[] args) {<br>        CountDownLatch latch = new CountDownLatch(5);<br>        LatchDemo latchDemo = new LatchDemo(latch);<br>        long begin = System.currentTimeMillis();<br>        for (int i = 0; i &lt; 5; ++i) {<br>            new Thread(latchDemo).start();<br>        }<br>        try {<br>            latch.await();<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        long end = System.currentTimeMillis();<br>        System.out.println(“总计耗时：” + (end - begin));<br>    }<br>}</p><p>class LatchDemo implements Runnable {<br>    private CountDownLatch latch;</p><pre><code>public LatchDemo(CountDownLatch latch) {    this.latch = latch;}@Overridepublic void run() {    try {        for (int i = 0; i &lt; 50000; i++) {            if (i % 2 == 0) {                System.out.println(i);            }        }    } finally {        latch.countDown();    }}</code></pre><p>}</p><pre><code>## FutureTask（Future实现类）- FurureTask是Future接口的唯一实现类。- FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：等待运行、正在运行和运行完成。- Future.get方法的行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果，否则会阻塞直到任务进入完成状态，然后返回结果或者抛出异常。- --- -- FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。- Callable表示的任务可以抛出受检查的或未受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会被封装到一个ExecutionException中，并在future.get中被重新抛出。- 当get方法抛出ExecutionException，可能是以下三种情况之一：Callable抛出的受检查异常，RuntimeException，以及Error。### FutureFuture接口设计初衷是对将来某个时刻会发生的结果进行建模。它建模了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。 在Future中触发那些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要等待耗时的操作完成。**示例**</code></pre><p>public void future() {<br>    ExecutorService executor = Executors.newCachedThreadPool();<br>    Future<Double> future = executor.submit(new Callable<Double>() {<br>        @Override<br>        public Double call() throws Exception {<br>            return doSomethingComputation();<br>        }<br>    });<br>    // 在另一个线程执行耗时操作的同时，去执行一些其他的任务。<br>    // 这些任务不依赖于future的结果，可以与future并发执行。<br>    // 如果下面的任务马上依赖于future的结果，那异步操作是没有意义的。<br>    doSomethingElse();<br>    try {<br>        // 如果不设置超时时间，那么线程会阻塞在这里。<br>        Double result = future.get(1, TimeUnit.SECONDS);<br>        System.out.println(“result is “ + result);<br>    } catch (InterruptedException e) {<br>        e.printStackTrace();<br>    } catch (ExecutionException e) {<br>        e.printStackTrace();<br>    } catch (TimeoutException e) {<br>        e.printStackTrace();<br>    }<br>}</p><p>private void doSomethingElse() {<br>    System.out.println(“doSomethingElse”);<br>}</p><p>private double doSomethingComputation() {<br>    System.out.println(“doSomethingComputation”);<br>    return 0.1;<br>}</p><pre><code>**局限性**Future无法实现以下的功能。- 1) 将两个异步操作计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的记过- 2）等待Future集合中的所有任务都完成- 3）仅等待Future集合中最快结束的任务完成，并返回它的结果- 4）通过编程方式完成一个Future任务的执行（以手工设定异步操作结果）- 5）应对Future的完成事件（完成回调）## CompletableFuture**实现异步API（将任务交给另一线程完成，该线程与调用方异步，通过回调函数或阻塞的方式取得任务结果）****1）Shop**</code></pre><p>public class Shop {<br>    private ThreadLocalRandom random;<br>    private ExecutorService executorService = Executors.newCachedThreadPool();</p><pre><code>public Future&lt;Double&gt; getPriceAsync(String product){    CompletableFuture&lt;Double&gt; future = new CompletableFuture&lt;&gt;();    // 另一个线程计算    executorService.submit(() -&gt; {        try {            double price = calculatePrice(product);            future.complete(price);        } catch (Exception e) {            // 处理异常            future.completeExceptionally(e);            e.printStackTrace();        }    });    return future;}private double calculatePrice(String product){    random = ThreadLocalRandom.current();    // 模拟耗时操作    delay();    // 随机    return random.nextDouble() * product.charAt(0) + product.charAt(1);}public static void delay(){    try {        Thread.sleep(1000);        throw new RuntimeException(&quot;product is not available&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }}public static void main(String[] args) {    Shop shop = new Shop();    Future&lt;Double&gt; price = shop.getPriceAsync(&quot;my favorite product&quot;);    // 计算price和doSomethingElse是并发执行的    doSomethingElse();    try {        // 如果此时已经计算完毕，则立即返回；如果没有计算完毕，则会阻塞        Double result = price.get();        System.out.println(&quot;result is &quot; + result);    } catch (InterruptedException e) {        e.printStackTrace();    } catch (ExecutionException e) {        e.printStackTrace();    }}private static void doSomethingElse() {    System.out.println(&quot;doSomethingElse&quot;);}</code></pre><p>}</p><pre><code>**2) GracefulShop**</code></pre><p>工厂方法创建的Future自己内部维护了一个线程池。<br>public class GracefulShop {<br>    private ThreadLocalRandom random;<br>    public Future<Double> getPriceAsync(String product){<br>        // 接收一个Supplier，该Supplier会交由ForkJoinPool池中的某个执行线程执行<br>        return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));<br>    }</p><pre><code>private double calculatePrice(String product){    random = ThreadLocalRandom.current();    // 模拟耗时操作    delay();    // 随机    return random.nextDouble() * product.charAt(0) + product.charAt(1);}public static void delay(){    try {        Thread.sleep(1000);        throw new RuntimeException(&quot;product is not available&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }}public static void main(String[] args) {    GracefulShop shop = new GracefulShop();    Future&lt;Double&gt; price = shop.getPriceAsync(&quot;my favorite product&quot;);    // 计算price和doSomethingElse是并发执行的    doSomethingElse();    try {        // 如果此时已经计算完毕，则立即返回；如果没有计算完毕，则会阻塞        Double result = price.get();        System.out.println(&quot;result is &quot; + result);    } catch (InterruptedException e) {        e.printStackTrace();    } catch (ExecutionException e) {        e.printStackTrace();    }}private static void doSomethingElse() {    System.out.println(&quot;doSomethingElse&quot;);}</code></pre><p>}</p><pre><code>### 将批量同步操作转为异步操作（并行流/CompletableFuture）如果原本的getPrice是同步方法的话，那么如果想批量调用getPrice，提高效率的方法要么使用并行流，要么使用CompletableFuture。</code></pre><p>public class SyncShop {<br>    private String name;</p><pre><code>public SyncShop(String name) {    this.name = name;}public static void delay() {    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }}public double getPrice(String product) {    ThreadLocalRandom random = ThreadLocalRandom.current();    delay();    return random.nextDouble() * product.charAt(0) + product.charAt(1);}public String getName() {    return name;}</code></pre><p>}</p><p>public class BestProductPriceCalculator {<br>    private List<SyncShop> shops = Arrays.asList(<br>            new SyncShop(“BestPrice”),<br>            new SyncShop(“LetsSaveBig”),<br>            new SyncShop(“MyFavoriteShop”),<br>            new SyncShop(“BuyItAll”)<br>    );</p><pre><code>public List&lt;String&gt; findPricesWithParallelStream(String product) {    return shops            .parallelStream()            .map(shop -&gt; shop.getName() + &quot;:&quot; + shop.getPrice(product))            .collect(Collectors.toList());}public List&lt;String&gt; findPricesWithCompletableFuture(String product) {    List&lt;CompletableFuture&lt;String&gt;&gt; futures = shops            .stream()            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getName() + &quot;:&quot; + shop.getPrice(product)))            .collect(Collectors.toList());    // join方法和Future的get方法有相同的含义，并且也声明在Future接口中，它们唯一的不同就是join不会抛出任何检测到的异常。    return futures.stream().map(CompletableFuture::join).collect(Collectors.toList());}</code></pre><p>}</p><p>public class FutureTest {<br>    private BestProductPriceCalculator calculator = new BestProductPriceCalculator();<br>    // 1s<br>    @Test<br>    public void testParallelStream(){<br>        calculator.findPricesWithParallelStream(“my favorite product”);<br>    }<br>    //2s<br>    @Test<br>    public void testCompletableFuture(){<br>        calculator.findPricesWithCompletableFuture(“my favorite product”);<br>    }<br>}</p><pre><code>使用并行流还是CompletableFuture？前者是无法调整线程池的大小的（处理器个数），而后者可以。如果是计算密集型应用，且没有IO，那么推荐使用并行流如果是IO密集型，需要等待IO，那么使用CompletableFuture灵活性更高，比如根据《Java并发编程实战》中给出的公式计算线程池合适的大小。### 多个异步任务合并逻辑如下：从每个商店获取price，price以某种格式返回。拿到price后解析price，然后调用远程API根据折扣计算最终price。可以分为三个任务，每个商店都要执行这三个任务。</code></pre><p>public class PipelineShop {<br>    private String name;</p><pre><code>public PipelineShop(String name) {    this.name = name;}public String getName() {    return name;}public String getPrice(String product) {    ThreadLocalRandom random = ThreadLocalRandom.current();    double price = calculatePrice(product);    Discount.DiscountCode code = Discount.DiscountCode.values()[random.nextInt(Discount.DiscountCode.values().length)];    return String.format(&quot;%s:%.2f:%s&quot;, name, price, code);}private double calculatePrice(String product) {    ThreadLocalRandom random = ThreadLocalRandom.current();    // 模拟耗时操作    delay();    // 随机    return random.nextDouble() * product.charAt(0) + product.charAt(1);}public static void delay() {    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p>}</p><p>public class Discount {<br>    public enum DiscountCode{<br>        NONE(0),SILVER(5),GOLD(10),PLATINUM(15),DIAMOND(20);<br>        private int percentage;<br>        DiscountCode(int percentage){<br>            this.percentage = percentage;<br>        }<br>    }</p><pre><code> public static String applyDiscount(Quote quote){    return quote.getShopName()+ &quot; price is &quot; + apply(quote.getPrice(), quote.getDiscountCode()); }private static double apply(double price, DiscountCode discountCode) {    // 模拟调用远程服务的延迟    delay();    return price * ( 100 - discountCode.percentage ) / 100 ; }</code></pre><p>}</p><p>public class Quote {<br>    private String shopName;<br>    private double price;<br>    private Discount.DiscountCode discountCode;</p><pre><code>public Quote(String shopName, double price, Discount.DiscountCode discountCode) {    this.shopName = shopName;    this.price = price;    this.discountCode = discountCode;}public static Quote parse(String str){    String [] slices = str.split(&quot;:&quot;);    return new Quote(slices[0],Double.parseDouble(slices[1]),Discount.DiscountCode.valueOf(slices[2]));}public String getShopName() {    return shopName;}public double getPrice() {    return price;}public Discount.DiscountCode getDiscountCode() {    return discountCode;}</code></pre><p>}</p><p>public class BestProductPriceWithDiscountCalculator {<br>    private List<PipelineShop> shops = Arrays.asList(<br>            new PipelineShop(“BestPrice”),<br>            new PipelineShop(“LetsSaveBig”),<br>            new PipelineShop(“MyFavoriteShop”),<br>            new PipelineShop(“BuyItAll”)<br>    );</p><pre><code>public List&lt;String&gt; findPricesWithPipeline(String product) {    List&lt;CompletableFuture&lt;String&gt;&gt; futures = shops            .stream()            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)))            .map(future -&gt; future.thenApply(Quote::parse))            .map(future -&gt; future.thenCompose(                    quote -&gt; CompletableFuture.supplyAsync(                            () -&gt; Discount.applyDiscount(quote)                    )            ))            .collect(Collectors.toList());    return futures.stream().map(CompletableFuture::join).collect(Collectors.toList());}</code></pre><p>}</p><pre><code>### 回调</code></pre><p>public class CallbackBestProductPriceCalculator {<br>    private List<PipelineShop> shops = Arrays.asList(<br>            new PipelineShop(“BestPrice”),<br>            new PipelineShop(“LetsSaveBig”),<br>            new PipelineShop(“MyFavoriteShop”),<br>            new PipelineShop(“BuyItAll”)<br>    );</p><pre><code>public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) {    return shops            .stream()            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)))            .map(future -&gt; future.thenApply(Quote::parse))            .map(future -&gt; future.thenCompose(                    quote -&gt; CompletableFuture.supplyAsync(                            () -&gt; Discount.applyDiscount(quote)                    )            ));}</code></pre><p>}</p><p>@Test<br>public void testCallback(){<br>    CompletableFuture[] futures = callbackBestProductPriceCalculator.findPricesStream(“my favorite product”).map(<br>            future -&gt; future.thenAccept(System.out::println)<br>    ).toArray(size -&gt; new CompletableFuture[size]);<br>    CompletableFuture.allOf(futures).join();<br>}</p><pre><code>### APICompletableFuture类实现了CompletionStage和Future接口。Future是Java 5添加的类，用来描述一个异步计算的结果，但是获取一个结果时方法较少,要么通过轮询isDone，确认完成后，调用get()获取值，要么调用get()设置一个超时时间。但是这个get()方法会阻塞住调用线程，这种阻塞的方式显然和我们的异步编程的初衷相违背。为了解决这个问题，JDK吸收了guava的设计思想，加入了Future的诸多扩展功能形成了CompletableFuture。CompletionStage是一个接口，从命名上看得知是一个完成的阶段，它里面的方法也标明是在某个运行阶段得到了结果之后要做的事情。、#### supplyAsync 提交任务</code></pre><p>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier);<br>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor);</p><pre><code>#### thenApply 变换（等待前一个任务返回后执行，处于同一个CompletableFuture）</code></pre><p>public <U> CompletionStage<U> thenApply(Function&lt;? super T,? extends U&gt; fn);<br>public <U> CompletionStage<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);<br>public <U> CompletionStage<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn,Executor executor);</p><pre><code>首先说明一下以Async结尾的方法都是可以异步执行的，如果指定了线程池，会在指定的线程池中执行，如果没有指定，默认会在ForkJoinPool.commonPool()中执行，下文中将会有好多类似的，都不详细解释了。关键的入参只有一个Function，它是函数式接口，所以使用Lambda表示起来会更加优雅。它的入参是上一个阶段计算后的结果，返回值是经过转化后结果。不带Async的方法会在和前一个任务相同的线程中处理；以Async的方法会将任务提交到一个线程池，所有每个任务是由不同的线程处理的。</code></pre><p>public void thenApply() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; “hello”).thenApply(s -&gt; s + “ world”).join();<br>    System.out.println(result);<br>}</p><pre><code>#### thenAccept 消耗</code></pre><p>public CompletionStage<Void> thenAccept(Consumer&lt;? super T&gt; action);<br>public CompletionStage<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action);<br>public CompletionStage<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor);</p><p>public void thenAccept() {<br>    CompletableFuture.supplyAsync(() -&gt; “hello”).thenAccept(s -&gt; System.out.println(s + “ world”));<br>}</p><pre><code>#### thenRun 执行下一步操作，不关心上一步结果 </code></pre><p>public CompletionStage<Void> thenRun(Runnable action);<br>public CompletionStage<Void> thenRunAsync(Runnable action);<br>public CompletionStage<Void> thenRunAsync(Runnable action,Executor executor);</p><p>thenRun它的入参是一个Runnable的实例，表示当得到上一步的结果时的操作。<br>public void thenRun() {<br>    CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “hello”;<br>    }).thenRun(() -&gt; System.out.println(“hello world”));<br>}</p><pre><code>#### thenCombine 结合两个CompletionStage的结果，进行转化后返回 </code></pre><p>public &lt;U,V&gt; CompletionStage<V> thenCombine(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);<br>public &lt;U,V&gt; CompletionStage<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn);<br>public &lt;U,V&gt; CompletionStage<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn,Executor executor);</p><pre><code>它需要原来的处理返回值，并且other代表的CompletionStage也要返回值之后，利用这两个返回值，进行转换后返回指定类型的值。</code></pre><p>public void thenCombine() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “hello”;<br>    }).thenCombine(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “world”;<br>    }), (s1, s2) -&gt; s1 + “ “ + s2).join();<br>    System.out.println(result);<br>}</p><pre><code>#### thenCompose（合并多个CompletableFuture，流水线执行，在调用外部接口返回CompletableFuture类型时更方便）</code></pre><p><U> CompletableFuture<U> thenCompose(Function&lt;? super T,CompletableFuture<U>&gt; fn);</p><pre><code>- thenCompose方法允许对两个异步操作（supplyAsync）进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。- 创建两个CompletableFuture，对第一个CompletableFuture对象调用thenCompose，并向其传递一个函数。当第一个CompletableFuture执行完毕后，它的结果将作为该函数的参数，这个函数的返回值是以第一个CompletableFuture的返回做输入计算出的第二个CompletableFuture对象。#### thenAccptBoth 结合两个CompletionStage的结果，进行消耗 </code></pre><p>public <U> CompletionStage<Void> thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action);<br>public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action);<br>public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action,     Executor executor);</p><pre><code>它需要原来的处理返回值，并且other代表的CompletionStage也要返回值之后，利用这两个返回值，进行消耗。</code></pre><p>public void thenAcceptBoth() {<br>    CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “hello”;<br>    }).thenAcceptBoth(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “world”;<br>    }), (s1, s2) -&gt; System.out.println(s1 + “ “ + s2));<br>}</p><pre><code>#### runAfterBoth 在两个CompletionStage都运行完执行，不关心上一步结果</code></pre><p>public CompletionStage<Void> runAfterBoth(CompletionStage<?> other,Runnable action);public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action);<br>public CompletionStage<Void> runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);</p><pre><code>不关心这两个CompletionStage的结果，只关心这两个CompletionStage执行完毕，之后在进行操作（Runnable）。</code></pre><p>public void runAfterBoth() {<br>    CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s1”;<br>    }).runAfterBothAsync(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s2”;<br>    }), () -&gt; System.out.println(“hello world”));<br>}</p><pre><code>#### applyToEither 两个CompletionStage，谁计算的快，我就用那个CompletionStage的结果进行下一步的转化操作 </code></pre><p>public <U> CompletionStage<U> applyToEither(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn);<br>public <U> CompletionStage<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn);<br>public <U> CompletionStage<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other,Function&lt;? super T, U&gt; fn,Executor executor);</p><pre><code>我们现实开发场景中，总会碰到有两种渠道完成同一个事情，所以就可以调用这个方法，找一个最快的结果进行处理。</code></pre><p>public void applyToEither() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s1”;<br>    }).applyToEither(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “hello world”;<br>    }), s -&gt; s).join();<br>    System.out.println(result);<br>}</p><pre><code>#### acceptEither 两个CompletionStage，谁计算的快，我就用那个CompletionStage的结果进行下一步的消耗操作 </code></pre><p>public CompletionStage<Void> acceptEither(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action);<br>public CompletionStage<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action);<br>public CompletionStage<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action,Executor executor);</p><p>public void acceptEither() {<br>    CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s1”;<br>    }).acceptEither(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “hello world”;<br>    }), System.out::println);<br>    while (true) {<br>    }<br>}</p><pre><code>#### runAfterEither 两个CompletionStage，任何一个完成了都会执行下一步的操作，不关心上一步结果</code></pre><p>public CompletionStage<Void> runAfterEither(CompletionStage<?> other,Runnable action);public CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action);<br>public CompletionStage<Void> runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);<br>public void runAfterEither() {<br>    CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s1”;<br>    }).runAfterEither(CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(2000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s2”;<br>    }), () -&gt; System.out.println(“hello world”));<br>}</p><pre><code>#### exceptionally 当运行时出现了异常，可以进行补偿</code></pre><p>public CompletionStage<T> exceptionally(Function&lt;Throwable, ? extends T&gt; fn);<br>public void exceptionally() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        if (1 == 1) {<br>            throw new RuntimeException(“测试一下异常情况”);<br>        }<br>        return “s1”;<br>    }).exceptionally(e -&gt; {<br>        System.out.println(e.getMessage());<br>        return “hello world”;<br>    }).join();<br>    System.out.println(result);<br>}</p><pre><code>#### whenComplete 当运行完成时，若有异常则改变返回值，否则返回原值</code></pre><p>public CompletionStage<T> whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action);<br>public CompletionStage<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action);<br>public CompletionStage<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action,Executor executor);</p><p>public void whenComplete() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        if (1 == 1) {<br>            throw new RuntimeException(“测试一下异常情况”);<br>        }<br>        return “s1”;<br>    }).whenComplete((s, t) -&gt; {<br>        System.out.println(s);<br>        System.out.println(t.getMessage());<br>    }).exceptionally(e -&gt; {<br>        System.out.println(e.getMessage());<br>        return “hello world”;<br>    }).join();<br>    System.out.println(result);<br>}</p><pre><code>nulljava.lang.RuntimeException: 测试一下异常情况java.lang.RuntimeException: 测试一下异常情况hello world这里也可以看出，如果使用了exceptionally，就会对最终的结果产生影响，它无法影响如果没有异常时返回的正确的值，这也就引出下面我们要介绍的handle。#### handle 当运行完成时，无论有无异常均可转换</code></pre><p>public <U> CompletionStage<U> handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);<br>public <U> CompletionStage<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);<br>public <U> CompletionStage<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn,Executor executor);</p><p>public void handle() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        //出现异常<br>        if (1 == 1) {<br>            throw new RuntimeException(“测试一下异常情况”);<br>        }<br>        return “s1”;<br>    }).handle((s, t) -&gt; {<br>        if (t != null) {<br>            return “hello world”;<br>        }<br>        return s;<br>    }).join();<br>    System.out.println(result);<br>}</p><pre><code>hello world</code></pre><p>public void handle() {<br>    String result = CompletableFuture.supplyAsync(() -&gt; {<br>        try {<br>            Thread.sleep(3000);<br>        } catch (InterruptedException e) {<br>            e.printStackTrace();<br>        }<br>        return “s1”;<br>    }).handle((s, t) -&gt; {<br>        if (t != null) {<br>            return “hello world”;<br>        }<br>        return s;<br>    }).join();<br>    System.out.println(result);<br>}</p><pre><code>s1#### allOfallOf工厂方法接收一个由CompletableFuture构成的数组，数组中的所有CompletableFuture对象执行完成之后，它返回一个CompletableFuture&lt;Void&gt;对象。这意味着，如果你需要等待最初Stream中的所有CompletableFuture对象执行完毕，对allOf方法返回的CompletableFuture执行join操作是个不错的注意。#### anyOf只要CompletableFuture对象数组中有一个执行完毕，便不再等待。## ForkJoin双端队列LinkedBlockingDeque适用于另一种相关模式，即工作密取（work stealing）。在生产者——消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列头部秘密地获取工作。密取工作模式比传统的生产者——消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的头部而不是从尾部获取工作，因此进一步降低了队列上的竞争程度。![图片12.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m418h9wxj30s20fedhj.jpg)![图片13.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m7q2pz79j30sa0hudiq.jpg)- 第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。- 第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。Fork/Join使用两个类来完成以上两件事情：- ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承- ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：    - oRecursiveAction：用于没有返回结果的任务。    - oRecursiveTask ：用于有返回结果的任务。- ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。threshold 临界值RecursiveTask有两个方法：fork和joinfork是执行子任务，join是取得子任务的结果，用于合并</code></pre><p>public class TestForkJoin {<br>    public static void main(String[] args) throws InterruptedException, ExecutionException {<br>        ForkJoinPool pool = new ForkJoinPool();<br>        ForkJoinCalculator calculator = new ForkJoinCalculator(0, 10000000L);<br>        Long result = pool.invoke(calculator);<br>        System.out.println(result);<br>        pool.shutdown();<br>    }<br>}</p><p>class ForkJoinCalculator extends RecursiveTask<Long> {</p><pre><code>private static final long serialVersionUID = -6682191224530210391L;private long start;private long end;private static final long THRESHOLD = 10000L;public ForkJoinCalculator(long start, long end) {    this.start = start;    this.end = end;}@Overrideprotected Long compute() {    long length = end - start;    if (length &lt; THRESHOLD) {        long sum = 0L;        for (long i = start; i &lt; end; ++i) {            sum += i;        }        return sum;    } else {        long middle = (start + end) / 2;        ForkJoinCalculator left = new ForkJoinCalculator(start, middle);        left.fork();        ForkJoinCalculator right = new ForkJoinCalculator(middle, end);        right.fork();        return left.join() + right.join();    }}</code></pre><p>} </p><pre><code>### 原理浅析- 1. 每个Worker线程都维护一个任务队列，即ForkJoinWorkerThread中的任务队列。- . 任务队列是双向队列，这样可以同时实现LIFO和FIFO。- . 子任务会被加入到原先任务所在Worker线程的任务队列。- 4. Worker线程用LIFO的方法取出任务，也就后进队列的任务先取出来（子任务总是后加入队列，但是需要先执行）。- 5. Worker线程的任务队列为空，会随机从其他的线程的任务队列中拿走一个任务执行（所谓偷任务：steal work，FIFO的方式）。- 6. 如果一个Worker线程遇到了join操作，而这时候正在处理其他任务，会等到这个任务结束。否则直接返回。- 7. 如果一个Worker线程偷任务失败，它会用yield或者sleep之类的方法休息一会儿，再尝试偷任务（如果所有线程都是空闲状态，即没有任务运行，那么该线程也会进入阻塞状态等待新任务的到来）。### 与MapReduce的区别MapReduce是把大数据集切分成小数据集，并行分布计算后再合并。ForkJoin是将一个问题递归分解成子问题，再将子问题并行运算后合并结果。二者共同点：都是用于执行并行任务的。基本思想都是把问题分解为一个个子问题分别计算，再合并结果。应该说并行计算都是这种思想，彼此独立的或可分解的。从名字上看Fork和Map都有切分的意思，Join和Reduce都有合并的意思，比较类似。区别：- 1）环境差异，分布式 vs 单机多核：ForkJoin设计初衷针对单机多核（处理器数量很多的情况）。MapReduce一开始就明确是针对很多机器组成的集群环境的。也就是说一个是想充分利用多处理器，而另一个是想充分利用很多机器做分布式计算。这是两种不同的的应用场景，有很多差异，因此在细的编程模式方面有很多不同。- 2）编程差异：MapReduce一般是：做较大粒度的切分，一开始就先切分好任务然后再执行，并且彼此间在最后合并之前不需要通信。这样可伸缩性更好，适合解决巨大的问题，但限制也更多。ForkJoin可以是较小粒度的切分，任务自己知道该如何切分自己，递归地切分到一组合适大小的子任务来执行，因为是一个JVM内，所以彼此间通信是很容易的，更像是传统编程方式。# 线程池使用## 引入原因- 1）任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接，使得任务在完成前面的请求之前可以接受新的请求，从而提高响应性。- 2）任务可以并行处理，从而能同时服务多个请求。如果有多个处理器，或者任务由于某种原因被阻塞，程序的吞吐量将得到提高。- 3）任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。**无限制创建线程的不足：**- 1）线程生命周期的开销非常高 2）资源消耗- 3）稳定性解决方式：线程池 Executor框架使用线程池的好处：- 1）降低资源消耗- 2）提高响应速度- 3）提高线程的可管理性## Executor ExecutorService ScheduledExecutorService继承体系![图片14.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr2x9bj30mq0jj0u3.jpg)![图片15.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr4wnlj30wq0awta0.jpg)![图片16.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr23h9j30lu0lhwfl.jpg)### ExecutorService![图片17.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr1xfdj315g0jrgqq.jpg)### ScheduledExecutorService![图片18.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr1a7cj318b09wtbj.jpg)返回值![图片19.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr0e61j30ew095wf0.jpg)示例</code></pre><p>public class QuoteTask implements Callable<TravelQuote> {<br>    private final TravelCompany company;<br>    private final TravelInfo travelInfo;<br>    private ExecutorService exec;<br>    public QuoteTask(TravelCompany company, TravelInfo travelInfo) {<br>        this.company = company;<br>        this.travelInfo = travelInfo;<br>    }</p><pre><code>public TravelQuote call() throws Exception {    return company.solicitQuote(travelInfo);}public List&lt;TravelQuote&gt; getRankedTravelQuotes(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, long time, TimeUnit unit) throws InterruptedException {    //任务    List&lt;QuoteTask&gt; tasks = new ArrayList&lt;QuoteTask&gt;();    for (TravelCompany company : companies) {        tasks.add(new QuoteTask(company,travelInfo));    }    //执行    List&lt;Future&lt;TravelQuote&gt;&gt; futures =  exec.invokeAll(tasks,time,unit);    List&lt;TravelQuote&gt; quotes = new ArrayList&lt;TravelQuote&gt;(tasks.size());    Iterator&lt;QuoteTask&gt; taskIterator = tasks.iterator();    //取出结果    for(Future&lt;TravelQuote&gt; future:futures){        QuoteTask task = taskIterator.next();        try {            quotes.add(future.get());        } catch (ExecutionException e) {            quotes.add(task.getFailureQuote(e.getCause()));            e.printStackTrace();        }catch(CancellationException e){            quotes.add(task.getTimeOutQuote(e));        }    }    Collections.sort(quotes,ranking);    return quotes;}</code></pre><p>}</p><pre><code>## ThreadPoolExecutor创建线程池![图片20.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr0v57j30w8029jrj.jpg)线程动态变化- 1.当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。 - 2.当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行 - 3.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务 - 4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理 - 5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程 - 6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭创建一个线程池时需要以下几个参数：- 1）corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。- 2）runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：    - a）ArrayBlockingQueue：基于数组的有界阻塞队列，FIFO    - b) LinkedBlockingQueue：基于链表的无界阻塞队列，FIFO，吞吐量高于ArrayBlockingQueue，Executors.newFixedThreadPoll()使用了这个队列    - c）SynchronousQueue：一个只存储一个元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入一直处于阻塞状态，吞吐量高于LinkedBlockingQueue，Executors#newCachedThreadPoll()使用了这个队列    - d）PriorityBlockingQueue：具有优先级的无界阻塞队列- 3）maximumPoolSize（线程池的最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果使用了无界队列该参数就没有意义了。- 4）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。- 5）RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，或者当线程池已关闭时，会采用一种策略处理提交的新任务。这个策略默认是AbortPolicy，表示无法处理新任务时抛出异常。有以下四种饱和策略：    - a）AbortPolicy：直接抛出异常    - b）CallerRunsPolicy：使用调用者所在线程来运行任务    - c）DiscardOldestPolicy：丢弃队列中最近的一个任务，并执行当前任务    - d）DiscardPolicy：不处理，直接丢弃也可以自定义饱和策略。- 6）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。出现timeout情况下，而且线程数超过了核心线程数，会销毁销毁线程。保持在corePoolSize数。除非设置了allowCoreThreadTimeOut和超时时间，这种情况线程数可能减少到0，最大可能是Integer.MAX_VALUE。如果任务很多，每个任务执行的时间比较短，可以调大时间，提高线程的利用率。    - allowCoreThreadTimeOut为true该值为true，则线程池数量最后销毁到0个。    - allowCoreThreadTimeOut为false销毁机制：超过核心线程数时，而且（超过最大值或者timeout过），就会销毁。- 7）TimeUnit（线程活动保持时间的单位）### 使用注意- 1、只有当任务都是同类型并且相互独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成拥塞。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成死锁。幸运的是，在基于网络的典型服务器应用程序中——web服务器、邮件服务器、文件服务器等，它们的请求通常都是同类型的并且相互独立的。- 2、设置线程池的大小：基于Runtime.getRuntime().avialableprocessors() 进行动态计算对于计算密集型的任务，在N个处理器的系统上，当线程池为N+1时，通过能实现最优的利用率（缺页故障等暂停时额外的线程也能确保CPU时钟周期不被浪费）。对于包含IO操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大，比如2*N。要正确地设置线程池的大小，你必须估算出任务的等待时间与计算时间的比值。线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。这种估算不需要很精确，而且可以通过一些分析或监控工具来获得。你还可以通过另一种方法来调节线程池的大小：在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察CPU利用率。最佳线程数目 = （线程等待时间与线程计算时间之比 + 1）* CPU数目- 3、线程的创建与销毁基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。线程池的最大大小表示可同时活动的线程数量的上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。- 4、管理队列任务ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交。一种稳妥的资源管理策略是使用有界队列，有界队列有助于避免资源耗尽的情况发生，但又带来了新的问题：当队列填满后，新的任务该怎么办？- 5、饱和策略当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过setRejectedExecutionHandler来修改。JDK提供了几种不同的RejectedExecutionHandler的实现，每种实现都包含有不同的饱和策略：AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy。    - 1）中止策略是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。    - 2）当新提交的任务无法保存到队列中执行时，抛弃策略会悄悄抛弃该任务。    - 3）抛弃最旧的策略则会抛弃下一个将被执行的任务，然后尝试重新提交下一个将被执行的任务（如果工作队列是一个优先级队列，那么抛弃最旧的将抛弃优先级最高的任务）    - 4）调用者运行策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退给调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。为什么好？因为当服务器过载时，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。- 6、线程工厂在许多情况下都需要使用定制的线程工厂方法。例如，你希望为线程池中的线程指定一个UncaughtExceptionHandler，或者实例化一个定制的Thread类用于执行调试信息的记录，你还可能希望修改线程的优先级（虽然不提倡这样做），或者只是给线程取一个更有意义的名字，用来解释线程的转储信息和错误日志。- 7、在调用构造函数后再定制ThreadPoolExecutor### 扩展ThreadPoolExecutor</code></pre><p>public class TimingThreadPool extends ThreadPoolExecutor {<br>    public TimingThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {<br>        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    }<br>    private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();<br>    private final Logger log = Logger.getLogger(“TimingThreadPool”);<br>    private final AtomicLong numTasks = new AtomicLong();<br>    private final AtomicLong totalTime = new AtomicLong();</p><pre><code>@Overrideprotected void beforeExecute(Thread t, Runnable r) {    super.beforeExecute(t,r);    log.fine(String.format(&quot;Thread %s :start %s&quot;,t,r));    startTime.set(System.nanoTime());}@Overrideprotected void afterExecute(Runnable r, Throwable t) {    try{        long endTime = System.nanoTime();        long taskTime = endTime - startTime.get();        numTasks.incrementAndGet();        totalTime.addAndGet(taskTime);        log.fine(String.format(&quot;Thread %s : end %s ,time = %dns&quot;,t,r,taskTime));    }finally {        super.afterExecute(r, t);    }}@Overrideprotected void terminated() {    try {        log.info(String.format(&quot;Terminated : avg time = %dns&quot;,totalTime.get() / numTasks.get()));    } finally {        super.terminated();    }}</code></pre><p>}</p><pre><code>### 任务时限Future的get方法可以限时，如果超时会抛出TimeOutException，那么此时可以通过cancel方法来取消任务。如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多的资源。创建n个任务，将其提交到一个线程池，保留n个Future，并使用限时的get方法通过Future串行地获取每一个结果，这一切都很简单。但还有一个更简单的实现：invokeAll。将多个任务提交到一个ExecutorService并获得结果。invokeAll方法的参数是一组任务，并返回一组Future。这两个集合有着相同的结构。invokeAll按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将各个Future与其表示的Callable关联起来。当所有任务执行完毕时，或者调用线程被中断时，又或者超时，invokeAll将返回。当超时时，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端代码可以调用get或isCancelled来判断究竟是何种情况。</code></pre><p>public class QuoteTask implements Callable<TravelQuote> {<br>    private final TravelCompany company;<br>    private final TravelInfo travelInfo;<br>    private ExecutorService exec;<br>    public QuoteTask(TravelCompany company, TravelInfo travelInfo) {<br>        this.company = company;<br>        this.travelInfo = travelInfo;<br>    }</p><pre><code>public TravelQuote call() throws Exception {    return company.solicitQuote(travelInfo);}public List&lt;TravelQuote&gt; getRankedTravelQuotes(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, long time, TimeUnit unit) throws InterruptedException {    //任务    List&lt;QuoteTask&gt; tasks = new ArrayList&lt;QuoteTask&gt;();    for (TravelCompany company : companies) {        tasks.add(new QuoteTask(company,travelInfo));    }    //执行    List&lt;Future&lt;TravelQuote&gt;&gt; futures =  exec.invokeAll(tasks,time,unit);    List&lt;TravelQuote&gt; quotes = new ArrayList&lt;TravelQuote&gt;(tasks.size());    Iterator&lt;QuoteTask&gt; taskIterator = tasks.iterator();    //取出结果    for(Future&lt;TravelQuote&gt; future:futures){        QuoteTask task = taskIterator.next();        try {            quotes.add(future.get());        } catch (ExecutionException e) {            quotes.add(task.getFailureQuote(e.getCause()));            e.printStackTrace();        }catch(CancellationException e){            quotes.add(task.getTimeOutQuote(e));        }    }    Collections.sort(quotes,ranking);    return quotes;}</code></pre><p>}</p><pre><code>### 任务关闭线程有一个相应的所有者，即创建该线程的类，因此线程池是工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。ExecutorService中提供了shutdown和shutdownNow方法。前者是正常关闭，后者是强行关闭。- 1）它们都会阻止新任务的提交- 2）正常关闭是停止空闲线程，正在执行的任务继续执行并完成所有未执行的任务- 3）强行关闭是停止所有（空闲+工作）线程，关闭当前正在执行的任务，然后返回所有尚未执行的任务。通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。但是我们无法通过常规方法来找出哪些任务已经开始但尚未结束，这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor关闭时哪些任务正在执行。--------------------------------处理非正常的线程终止（只对execute提交的任务有效，submit提交的话会在future.get时将受检异常直接抛出）要为线程池中的所有线程设置一个UncaughtExceptionHandler，需要为ThreadPoolExecutor的构造函数提供一个ThreadFactory。标准线程池允许当发生未捕获异常时结束线程，但由于使用了一个try-finally块来接收通知，因此当线程结束时，将有新的线程来代替它。如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致很大的混乱。如果你希望在任务由于发生异常而失败时获得通知，并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的Runnable或Callable中，或者改写ThreadPoolExecutor的afterExecute方法。只有通过execute提交的任务，才能将它抛出的异常交给未捕获异常处理器。如果一个由submit提交的任务由于抛出了异常而结束，那么这个异常将被Future.get封装在ExecutionException中重新抛出。</code></pre><p>public class QuoteTask implements Callable<TravelQuote> {<br>    private final TravelCompany company;<br>    private final TravelInfo travelInfo;<br>    private ExecutorService exec;<br>    public QuoteTask(TravelCompany company, TravelInfo travelInfo) {<br>        this.company = company;<br>        this.travelInfo = travelInfo;<br>    }</p><pre><code>public TravelQuote call() throws Exception {    return company.solicitQuote(travelInfo);}public List&lt;TravelQuote&gt; getRankedTravelQuotes(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, long time, TimeUnit unit) throws InterruptedException {    //任务    List&lt;QuoteTask&gt; tasks = new ArrayList&lt;QuoteTask&gt;();    for (TravelCompany company : companies) {        tasks.add(new QuoteTask(company,travelInfo));    }    //执行    List&lt;Future&lt;TravelQuote&gt;&gt; futures =  exec.invokeAll(tasks,time,unit);    List&lt;TravelQuote&gt; quotes = new ArrayList&lt;TravelQuote&gt;(tasks.size());    Iterator&lt;QuoteTask&gt; taskIterator = tasks.iterator();    //取出结果    for(Future&lt;TravelQuote&gt; future:futures){        QuoteTask task = taskIterator.next();        try {            quotes.add(future.get());        } catch (ExecutionException e) {            quotes.add(task.getFailureQuote(e.getCause()));            e.printStackTrace();        }catch(CancellationException e){            quotes.add(task.getTimeOutQuote(e));        }    }    Collections.sort(quotes,ranking);    return quotes;}</code></pre><p>}</p><pre><code>## ScheduledThreadPoolExecutor它继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。Timer是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</code></pre><p>public ScheduledThreadPoolExecutor(int corePoolSize,<br>                                   ThreadFactory threadFactory,<br>                                   RejectedExecutionHandler handler) {<br>    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<br>          new DelayedWorkQueue(), threadFactory, handler);<br>}</p><pre><code>内部工作队列是DelayedWorkQueue，它是一个无界队列，maxPoolSize这个参数没有意义。</code></pre><p>static class DelayedWorkQueue extends AbstractQueue<Runnable><br>    implements BlockingQueue<Runnable> </p><p>public class TestScheduledThreadPool {<br>   public static void main(String[] args) throws InterruptedException, ExecutionException {<br>      ScheduledExecutorService pool = Executors.newScheduledThreadPool(5);<br>      for(int i = 0; i &lt; 10 ;++i){<br>         Future<Integer> result = pool.schedule(new ThreadPoolDemo2(), 800, TimeUnit.MILLISECONDS);<br>         System.out.println(result.get());<br>      }<br>      pool.shutdown();<br>   }<br>}</p><p>class ThreadPoolDemo2 implements Callable<Integer> {<br>   @Override<br>   public Integer call() throws Exception {<br>      int sum = 0;<br>      for (int i = 0; i &lt; 100; ++i) {<br>         sum += i;<br>         System.out.println(Thread.currentThread().getName() + “\t” + i);<br>      }<br>      return sum;<br>   }<br>}</p><pre><code>## ExecutorsExecutors是一个工厂类，可以创建3种类型的ThreadPoolExecutor和2种类型的ScheduledThreadPool。![图片21.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jr0gjdj315f0l6tf6.jpg)### FixedThreadPool创建固定线程数的FixedThreadPool，适用于负载比较重的服务器。</code></pre><p>public static ExecutorService newFixedThreadPool(int nThreads) {<br>    return new ThreadPoolExecutor(nThreads, nThreads,<br>                                  0L, TimeUnit.MILLISECONDS,<br>                                  new LinkedBlockingQueue<Runnable>());<br>}</p><pre><code>corePoolSize和maxPoolSize都被设置为创建FixedThreadPoolExecutor时指定的参数nThreads。keepAliveTime为0表示多余的空闲线程将会被立即终止。使用无界队列LinkedBlockingQueue来作为线程池的工作队列，并且默认容量为Integer.MAX_VALUE。使用无界队列会带来以下影响：- 1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize- 2）maximumPoolSize是一个无效的参数- 3）keepAliveTime是一个无效参数- 4）运行中的FixedThreadPool（未执行shutdown或shutdownNow）不会拒绝任务。### SingleThreadExecutor适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程活动的应用场景。</code></pre><p>public static ExecutorService newSingleThreadExecutor() {<br>    return new FinalizableDelegatedExecutorService<br>        (new ThreadPoolExecutor(1, 1,<br>                                0L, TimeUnit.MILLISECONDS,<br>                                new LinkedBlockingQueue<Runnable>()));<br>}</p><pre><code>它也是使用无界队列，corePoolSize和maxPoolSize都为1。### CachedThreadPool大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</code></pre><p>public static ExecutorService newCachedThreadPool() {<br>    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,<br>                                  60L, TimeUnit.SECONDS,<br>                                  new SynchronousQueue<Runnable>());<br>}</p><pre><code>使用没有缓冲区、只能存储一个元素的SynchronousQueue作为工作队列。maxPoolSize是无界的，如果主线程提交任务的速度高于maxPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存。![图片22.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jqzse0j30md0ff0tg.jpg)任务执行过程：- 1）首先执行SynchronousQueue#offer(Runnable) 。如果当前maxPool中有空闲线程正在执行SynchronousQueue#poll，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行；否则执行2）- 2）当初始maxPool为空，或者maxPool中没有空闲线程时，此时CachedThreadPool会创建一个新线程执行任务- 3）在2）中新创建的线程执行任务完毕后，会执行SynchronousQueue#poll，这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒。如果60秒内主线程提交了一个新任务，那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。![图片23.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7m9jqznlsj30mb0cq3z4.jpg)### ScheduledThreadPoolExecutor固定线程个数，适用于多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的梳理的应用场景。### SingleThreadScheduledExecutor</code></pre><p>public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {<br>    return new DelegatedScheduledExecutorService<br>        (new ScheduledThreadPoolExecutor(1, threadFactory));<br>}</p><pre><code>适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。## CompletionServiceCompletionService将Executor和BlockingQueue的概念融合在一起，你可以将Callable任务提交给它来执行，然后使用类似于队列操作的take和poll等方法来获得已完成的结果，而这些结果会在完成时封装为Future。ExecutorCompletionService实现了CompletionService并将计算任务委托给一个Executor。ExecutorCompletionService的实现非常简单，在构造函数中创建一个BlockingQueue来保存计算完成的结果。当计算完成时，调用FutureTask的done方法。当提交某个任务时，该任务将首先包装为一个QueueingFuture，这是FutureTask的一个子类，然后再改写子类的done方法，并将结果放入BlockingQueue中。take和poll方法委托给了BlockingQueue，这些方法会在得出结果之前阻塞。多个ExecutorCompletionService可以共享一个Executor，因此可以创建一个对于特定计算私有，又能共享一个公共Executor的ExecutorCompletionService。</code></pre><p>public class CompletionServiceTest {<br>    public void test() throws InterruptedException, ExecutionException {<br>        ExecutorService exec = Executors.newCachedThreadPool();<br>        CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(exec);<br>        for (int i = 0; i &lt; 10; i++) {<br>            completionService.submit(new Task());<br>        }<br>        int sum = 0;<br>        for (int i = 0; i &lt; 10; i++) {<br>        //检索并移除表示下一个已完成任务的 Future，如果目前不存在这样的任务，则等待。<br>            Future<Integer> future = completionService.take();<br>            sum += future.get();<br>        }<br>        System.out.println(“总数为：” + sum);<br>        exec.shutdown();<br>    }<br>}</p><pre><code># J.U.C 源码解析实现整个并发体系的真正底层是CPU提供的lock前缀+cmpxchg指令和POSIX的同步原语（mutex&amp;condition）synchronized和wait&amp;notify基于JVM的monitor，monitor底层又是基于POSIX同步原语。volatile基于CPU的lock前缀指令实现内存屏障。而J.U.C是基于LockSupport，底层基于POSIX同步原语。## AbstractQueuedSynchronizer（AQS）在ReentrantLock和Semaphore这两个接口之间存在许多共同点，这两个类都可以用作一个阀门，即每次只允许一定数量的线程通过，并当线程到达阀门时，可以通过（在调用lock或acquire时成功返回），也可以等待（在调用lock或acquire时阻塞），还可以取消（在调用tryLock或tryAcquire时返回假，表示在指定的时间内锁是不可用的或无法得到许可）。可以通过锁来实现计数信号量。事实上，它们在实现时都使用了一个共同的基类，即AbstractQueuedSynchronizer（AQS），这个类也是其他许多同步类的基类。AQS是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。不仅ReentrantLock和Semaphore，还包括CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask，都是基于AQS构造的。在基于AQS构建的同步器中，只可能在一个时刻发生阻塞，从而降低上下文切换的开销，并提高吞吐量。在设计AQS时充分考虑了可伸缩性，因此java.util.concurrent中所有基于AQS构建的同步器都能获得这个优势。在基于AQS构建的同步器类中，最基本的操作包括各种形式的获取操作和释放操作。获取操作是一种依赖状态的操作，并且通常会阻塞。当使用锁或信号量时，获取操作的含义就很直观，即获取的是锁或许可，并且调用者可能会一直等待直到同步器类处于可被获取的状态。AQS负责管理同步器类中的状态，它管理了一个整数类型的状态信息，可以通过getState、setState以及compareAndSetState等protected类型方法来进行操作。这个整数可以用于表示任意状态。![图片24.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzddvwj30s60dl0tl.jpg)它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。子类通过继承AQS并实现它的抽象方法来管理同步状态，修改同步状态依赖于AQS的getState、setState、compareAndSetState来进行操作，它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用。AQS既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态。### AQS的接口AQS的设计是基于模板方法模式的，使用者需要继承同步器并重写指定的方法，随后将AQS组合在自定义同步组件的实现中，并调用AQS提供的模板方法，而这些模板方法将会调用使用者重写的方法。同步器可重写的方法：![图片25.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzcx0oj30pt0c6gna.jpg)同步器提供的模板方法：![图片26.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzdomoj30pp0haq5t.jpg)### AQS使用实例（互斥锁，tryAcquire只需一次CAS）</code></pre><p>public class Mutex implements Lock {<br>    private final Sync sync = new Sync();</p><pre><code>@Overridepublic void lock() {    sync.acquire(1);}@Overridepublic void lockInterruptibly() throws InterruptedException {    sync.acquireInterruptibly(1);}@Overridepublic boolean tryLock() {    return sync.tryAcquire(1);}@Overridepublic boolean tryLock(long time, TimeUnit unit) throws InterruptedException {    return sync.tryAcquireNanos(1, unit.toNanos(time));}@Overridepublic void unlock() {    sync.release(1);}@Overridepublic Condition newCondition() {    return sync.newCondition();}private static class Sync extends AbstractQueuedSynchronizer {    @Override    protected boolean tryAcquire(int arg) {        if (super.compareAndSetState(0, 1)) {            super.setExclusiveOwnerThread(Thread.currentThread());            return true;        }        return false;    }    @Override    protected boolean tryRelease(int arg) {        if (super.getState() == 0) {            throw new IllegalMonitorStateException();        }        super.setExclusiveOwnerThread(null);        super.setState(0);        return true;    }    @Override    protected boolean isHeldExclusively() {        return super.getState() == 1;    }    Condition newCondition() {        return new ConditionObject();    }}</code></pre><p>}</p><pre><code>### AQS实现主要工作基于CLH队列，voliate关键字修饰的状态state，线程去修改状态成功了就是获取成功，失败了就进队列等待，等待唤醒。在等待唤醒的时候，很多时候会使用自旋（while（!cas()））的方式，不停的尝试获取锁，直到被其他线程获取成功。#### AQS#state getState setState</code></pre><p>/**</p><ul><li>The synchronization state.</li><li>/<br>private volatile int state;</li></ul><p>/**</p><ul><li>Returns the current value of synchronization state.</li><li>This operation has memory semantics of a {@code volatile} read.</li><li>@return current state value</li><li>/<br>protected final int getState() {<br>  return state;<br>}</li></ul><p>/**</p><ul><li>Sets the value of synchronization state.</li><li>This operation has memory semantics of a {@code volatile} write.</li><li>@param newState the new state value</li><li>/<br>protected final void setState(int newState) {<br>  state = newState;<br>}<pre><code></code></pre></li></ul><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>AQS依赖内部的CLH同步队列（一个FIFO双向队列）来完成同步状态的管理。当前线程获取同步状态失败时，AQS会将当前线程以及等待状态等信息构造为一个Node并将其加入同步队列，并阻塞当前线程。当同步状态释放时，会把后继节点线程唤醒，使其再次尝试获取同步状态。后继节点将会在获取同步状态成功时将自己设置为头节点。</p><h4 id="AQS-Node"><a href="#AQS-Node" class="headerlink" title="AQS#Node"></a>AQS#Node</h4><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzcgvrj30pu0dsac7.jpg" alt="图片27.jpg"></p><pre><code>static final class Node {    /** Marker to indicate a node is waiting in shared mode */    static final Node SHARED = new Node();    /** Marker to indicate a node is waiting in exclusive mode */    static final Node EXCLUSIVE = null;    /** waitStatus value to indicate thread has cancelled */    static final int CANCELLED =  1;    /** waitStatus value to indicate successor&#39;s thread needs unparking */    static final int SIGNAL    = -1;    /** waitStatus value to indicate thread is waiting on condition */    static final int CONDITION = -2;    /**     * waitStatus value to indicate the next acquireShared should     * unconditionally propagate     */    static final int PROPAGATE = -3;    /**     * Status field, taking on only the values:     *   SIGNAL:     The successor of this node is (or will soon be)     *               blocked (via park), so the current node must     *               unpark its successor when it releases or     *               cancels. To avoid races, acquire methods must     *               first indicate they need a signal,     *               then retry the atomic acquire, and then,     *               on failure, block.     *   CANCELLED:  This node is cancelled due to timeout or interrupt.     *               Nodes never leave this state. In particular,     *               a thread with cancelled node never again blocks.     *   CONDITION:  This node is currently on a condition queue.     *               It will not be used as a sync queue node     *               until transferred, at which time the status     *               will be set to 0. (Use of this value here has     *               nothing to do with the other uses of the     *               field, but simplifies mechanics.)     *   PROPAGATE:  A releaseShared should be propagated to other     *               nodes. This is set (for head node only) in     *               doReleaseShared to ensure propagation     *               continues, even if other operations have     *               since intervened.     *   0:          None of the above     *     * The values are arranged numerically to simplify use.     * Non-negative values mean that a node doesn&#39;t need to     * signal. So, most code doesn&#39;t need to check for particular     * values, just for sign.     *     * The field is initialized to 0 for normal sync nodes, and     * CONDITION for condition nodes.  It is modified using CAS     * (or when possible, unconditional volatile writes).     */    volatile int waitStatus;    /**     * Link to predecessor node that current node/thread relies on     * for checking waitStatus. Assigned during enqueuing, and nulled     * out (for sake of GC) only upon dequeuing.  Also, upon     * cancellation of a predecessor, we short-circuit while     * finding a non-cancelled one, which will always exist     * because the head node is never cancelled: A node becomes     * head only as a result of successful acquire. A     * cancelled thread never succeeds in acquiring, and a thread only     * cancels itself, not any other node.     */    volatile Node prev;    /**     * Link to the successor node that the current node/thread     * unparks upon release. Assigned during enqueuing, adjusted     * when bypassing cancelled predecessors, and nulled out (for     * sake of GC) when dequeued.  The enq operation does not     * assign next field of a predecessor until after attachment,     * so seeing a null next field does not necessarily mean that     * node is at end of queue. However, if a next field appears     * to be null, we can scan prev&#39;s from the tail to     * double-check.  The next field of cancelled nodes is set to     * point to the node itself instead of null, to make life     * easier for isOnSyncQueue.     */    volatile Node next;    /**     * The thread that enqueued this node.  Initialized on     * construction and nulled out after use.     */    volatile Thread thread;    /**     * Link to next node waiting on condition, or the special     * value SHARED.  Because condition queues are accessed only     * when holding in exclusive mode, we just need a simple     * linked queue to hold nodes while they are waiting on     * conditions. They are then transferred to the queue to     * re-acquire. And because conditions can only be exclusive,     * we save a field by using special value to indicate shared     * mode.     */    Node nextWaiter;    /**     * Returns true if node is waiting in shared mode.     */    final boolean isShared() {        return nextWaiter == SHARED;    }    /**     * Returns previous node, or throws NullPointerException if null.     * Use when predecessor cannot be null.  The null check could     * be elided, but is present to help the VM.     *     * @return the predecessor of this node     */    final Node predecessor() throws NullPointerException {        Node p = prev;        if (p == null)            throw new NullPointerException();        else            return p;    }    Node() {    // Used to establish initial head or SHARED marker    }    Node(Thread thread, Node mode) {     // Used by addWaiter        this.nextWaiter = mode;        this.thread = thread;    }    Node(Thread thread, int waitStatus) { // Used by Condition        this.waitStatus = waitStatus;        this.thread = thread;    }}</code></pre><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzadvcj30pu09l0th.jpg" alt="图片28.jpg"></p><h4 id="独占式同步状态"><a href="#独占式同步状态" class="headerlink" title="独占式同步状态"></a>独占式同步状态</h4><p>在获取同步状态时，AQS调用tryAcquire获取同步状态。AQS维护一个同步队列，获取同步状态失败的线程都会被加入到队列中并在队列进行自旋（等待）；移出队列的条件是前驱节点是头结点且成功获取了同步状态；</p><p>在释放同步状态时，AQS调用tryRelease释放同步状态，然后唤醒头节点的后继节点，使其尝试获取同步状态。</p><h5 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS#acquire"></a>AQS#acquire</h5><p>acquire(int)可以获取同步状态，对中断不敏感。</p><ul><li>1）调用自定义同步器实现的tryAcquire</li><li>2）如果成功，那么结束</li><li>3）如果失败，那么调用addWaiter加入同步队列尾部，并调用acquireQueued获取同步状态（前提是前驱节点为head）<ul><li>3.1）如果获取到了，那么将自己设置为头节点，返回</li><li>3,2）如果前驱节点不是head或者没有获取到，那么判断前驱节点状态是否为SIGNAL，</li><li>3.2.1) 如果是，那么阻塞当前线程，阻塞解除后仍自旋获取同步状态</li><li>3.2.2) 如果不是，那么删除状态为CANCELLED的前驱节点，将前驱节点状态设置为SIGNAL，继续自旋尝试获取同步状态。 <pre><code>public final void acquire(int arg) {if (!tryAcquire(arg) &amp;&amp;  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  selfInterrupt();}</code></pre></li></ul></li></ul><h6 id="addWaiter（新Node添加到同步队列尾部，初始状态下head是一个空节点）"><a href="#addWaiter（新Node添加到同步队列尾部，初始状态下head是一个空节点）" class="headerlink" title="addWaiter（新Node添加到同步队列尾部，初始状态下head是一个空节点）"></a>addWaiter（新Node添加到同步队列尾部，初始状态下head是一个空节点）</h6><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g7mebza85hj30m30ar3z3.jpg" alt="图片29.jpg"><br>获取同步状态失败的线程会被构造成Node加入到同步队列尾部，这个过程必须是线程安全的，AQS基于CAS来设置同步队列的尾节点compareAndSetTail。</p><pre><code>private Node addWaiter(Node mode) {    Node node = new Node(Thread.currentThread(), mode);    // Try the fast path of enq; backup to full enq on failure    Node pred = tail;    if (pred != null) {        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            return node;        }    }    enq(node);    return node;}</code></pre><p>可能tail为null，或者tail不为null，但CAS添加node至尾部失败，此时会enq</p><p>如果tail为null，则设置head和tail都指向一个空节点</p><p>然后循环CAS添加node至尾部，直至成功。</p><pre><code>private Node enq(final Node node) {    for (;;) {        Node t = tail;        if (t == null) { // Must initialize            if (compareAndSetHead(new Node()))                tail = head;        } else {            node.prev = t;            if (compareAndSetTail(t, node)) {                t.next = node;                return t;            }        }    }}</code></pre><h6 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h6><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g7mebz9h50j30pi07qjru.jpg" alt="图片30.jpg"></p><ul><li>设置首节点是由获取同步状态成功的线程来完成的，因为只有一个线程能够成功获取同步状态，因此设置头节点的方法并不需要CAS的包装。</li><li>如果自己是第二个结点，那么尝试获取同步状态，如果成功，那么将自己设置为头节点，并返回。</li><li>如果自己不是第二个结点或者CAS获取失败，那么判断是否应该阻塞，如果应该，那么阻塞，否则自旋重新尝试获取同步状态。</li></ul><pre><code>final boolean acquireQueued(final Node node, int arg) {    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {    // 如果前驱是head，即该结点是第二个结点，那么便有资格去尝试获取资源（可能是head释放完资源唤醒自己的，当然也可能被interrupt了）            final Node p = node.predecessor();            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);                p.next = null; // help GC                failed = false;                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}/** * Sets head of queue to be node, thus dequeuing. Called only by * acquire methods.  Also nulls out unused fields for sake of GC * and to suppress unnecessary signals and traversals. * * @param node the node */private void setHead(Node node) {    head = node;    node.thread = null;    node.prev = null;}```###### shouldParkAfterFailedAcquire- 1）如果前一个节点状态是SIGNAL，那么表示已经设置了前驱节点在获取到同步状态时会唤醒自己，就可以放心的去阻塞了。- 2）否则会检查前一个节点状态是否是Cancelled- 2.1）如果是，那么就删除前一个节点，直至状态不是Cancelled。- 2.2）如果不是，那么将其状态设置为SIGNAL。```/** * Checks and updates status for a node that failed to acquire. * Returns true if thread should block. This is the main signal * control in all acquire loops.  Requires that pred == node.prev. * * @param pred node&#39;s predecessor holding status * @param node the node * @return {@code true} if thread should block */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {    int ws = pred.waitStatus;    if (ws == Node.SIGNAL)        /*         * This node has already set status asking a release         * to signal it, so it can safely park.         */        return true;    if (ws &gt; 0) {        /*         * Predecessor was cancelled. Skip over predecessors and         * indicate retry.         */        do {            node.prev = pred = pred.prev;        } while (pred.waitStatus &gt; 0);        pred.next = node;    } else {        /*         * waitStatus must be 0 or PROPAGATE.  Indicate that we         * need a signal, but don&#39;t park yet.  Caller will need to         * retry to make sure it cannot acquire before parking.         */        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);    }    return false;}```###### parkAndCheckInterrupt```private final boolean parkAndCheckInterrupt() {    LockSupport.park(this);    return Thread.interrupted();}```为什么只有前驱节点是头节点才能尝试获取同步状态？- 1）头节点是成功获取到同步状态的节点，头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头结点- 2）维护同步队列的FIFO原则。![图片31.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7mebzay7lj30pm0gq40o.jpg)##### AQS#release在释放同步状态之后，会唤醒其后继节点，使后继节点继续尝试获取同步状态。```public final boolean release(int arg) {    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}```######  unparkSuccessor```private void unparkSuccessor(Node node) {    /*     * If status is negative (i.e., possibly needing signal) try     * to clear in anticipation of signalling.  It is OK if this     * fails or if status is changed by waiting thread.     */    int ws = node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);    /*     * Thread to unpark is held in successor, which is normally     * just the next node.  But if cancelled or apparently null,     * traverse backwards from tail to find the actual     * non-cancelled successor.     */    Node s = node.next;    if (s == null || s.waitStatus &gt; 0) {        s = null;        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }    if (s != null)        LockSupport.unpark(s.thread);}```#### 共享式同步状态共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。![图片32.jpg](http://ww1.sinaimg.cn/large/007s8HJUly1g7mebz74cbj30kq0d3gm8.jpg)- 左半部分：共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞- 右半部分：独占式访问资源时，同一时刻其他访问均被阻塞。##### AQS#acquireSharedAQS会调用tryAcquireShared方法尝试获取同步状态，该方法返回值为int，当返回值大于等于0时，表示能够获取到同步状态。如果返回值等于0表示当前线程获取共享锁成功，但它后续的线程是无法继续获取的，也就是不需要把它后面等待的节点唤醒。如果返回值大于0，表示当前线程获取共享锁成功且它后续等待的节点也有可能继续获取共享锁成功，也就是说此时需要把后续节点唤醒让它们去尝试获取共享锁。- 1）调用自定义同步器实现的tryAcquireShared- 2）如果成功，那么结束- 3）如果失败，那么调用addWaiter加入SHARED节点至同步队列尾部，并调用再次尝试获取同步状态（前提是前驱节点为head）- 3.1）如果获取到了，那么将自己设置为头节点，并向后唤醒共享节点（如果还有剩余acquire），返回- 3.2） 如果前驱节点不是head或者没有获取到，那么判断前驱节点状态是否为SIGNAL    - 3.2.1) 如果是，那么阻塞当前线程，阻塞解除后仍自旋获取同步状态    - 3.2.2) 如果不是，那么删除状态为CANCELLED的前驱节点，将前驱节点状态设置为SIGNAL，继续自旋尝试获取同步状态。```public final void acquireShared(int arg) {    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);}```##### doAcquiredShared构造一个当前线程对应的共享节点，如果前驱节点是head并且尝试获取同步状态成功，那么将当前节点设置为head```private void doAcquireShared(int arg) {    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    try {        boolean interrupted = false;        for (;;) {            final Node p = node.predecessor();            if (p == head) {                int r = tryAcquireShared(arg);                if (r &gt;= 0) {                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    if (interrupted)                        selfInterrupt();                    failed = false;                    return;                }            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}```##### setHeadAndPropagate如果获取了同步状态，仍有剩余的acquire，那么继续向后唤醒```/** * Sets head of queue, and checks if successor may be waiting * in shared mode, if so propagating if either propagate &gt; 0 or * PROPAGATE status was set. * * @param node the node * @param propagate the return value from a tryAcquireShared */private void setHeadAndPropagate(Node node, long propagate) {    Node h = head; // Record old head for check below    setHead(node);    /*     * Try to signal next queued node if:     *   Propagation was indicated by caller,     *     or was recorded (as h.waitStatus either before     *     or after setHead) by a previous operation     *     (note: this uses sign-check of waitStatus because     *      PROPAGATE status may transition to SIGNAL.)     * and     *   The next node is waiting in shared mode,     *     or we don&#39;t know, because it appears null     *     * The conservatism in both of these checks may cause     * unnecessary wake-ups, but only when there are multiple     * racing acquires/releases, so most need signals now or soon     * anyway.     */    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||        (h = head) == null || h.waitStatus &lt; 0) {        Node s = node.next;// 如果当前节点的后继节点是共享类型或者没有后继节点，则进行唤醒// 这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒        if (s == null || s.isShared())            doReleaseShared();    }}```#### AQS#releaseShared```public final boolean releaseShared(int arg) {    if (tryReleaseShared(arg)) {        doReleaseShared();        return true;    }    return false;}```##### doReleaseShared```private void doReleaseShared() {    /*     * Ensure that a release propagates, even if there are other     * in-progress acquires/releases.  This proceeds in the usual     * way of trying to unparkSuccessor of head if it needs     * signal. But if it does not, status is set to PROPAGATE to     * ensure that upon release, propagation continues.     * Additionally, we must loop in case a new node is added     * while we are doing this. Also, unlike other uses of     * unparkSuccessor, we need to know if CAS to reset status     * fails, if so rechecking.     */    for (;;) {        Node h = head;        if (h != null &amp;&amp; h != tail) {            int ws = h.waitStatus;// 表示后继节点需要被唤醒            if (ws == Node.SIGNAL) {                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))                    continue;            // loop to recheck cases                unparkSuccessor(h);            }//如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去            else if (ws == 0 &amp;&amp;                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))                continue;                // loop on failed CAS        }//如果头结点没有发生变化，表示设置完成，退出循环//如果头结点发生变化，比如说其他线程获取到了锁，将自己设置为了头节点。为了使自己的唤醒动作可以传递给之后的节点，就需要重新进入循环        if (h == head)                   // loop if head changed            break;    }}</code></pre><h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><h5 id="AQS-tryAcquireNanos"><a href="#AQS-tryAcquireNanos" class="headerlink" title="AQS#tryAcquireNanos"></a>AQS#tryAcquireNanos</h5><pre><code>public final boolean tryAcquireNanos(int arg, long nanosTimeout)        throws InterruptedException {    if (Thread.interrupted())        throw new InterruptedException();    return tryAcquire(arg) ||        doAcquireNanos(arg, nanosTimeout);}</code></pre><ul><li>该方法可以超时获取同步状态，即在指定上的时间段内获取同步状态，如果成功返回true，失败则返回false。</li><li>对比另一个获取同步状态的方法acquireInterruptibly，该方法等待时如果被中断，那么会立即返回并抛出InterruptedException；而synchronized即使被中断也仅仅是设置中断标志位，并不会立即返回。</li><li>而tryAcquireNanos不仅支持响应中断，还增加了超时获取的特性。</li><li>针对超时获取，主要需要计算出需要等待的时间间隔nanosTImeout，为了防止过早通知，nanosTimeout的计算公式为:nanosTimeout -= now – lastTime。now是当前唤醒时间，lastTime为上次唤醒时间。</li><li>如果nanosTimeout大于0，则表示超时时间未到，需要继续等待nanosTimeout纳秒；反之已经超时。</li></ul><h5 id="AQS-doAcquireNanos"><a href="#AQS-doAcquireNanos" class="headerlink" title="AQS#doAcquireNanos"></a>AQS#doAcquireNanos</h5><p><img src="http://ww1.sinaimg.cn/large/007s8HJUly1g7mebz79chj30mw0p7wfx.jpg" alt="图片33.jpg"></p><pre><code>private boolean doAcquireNanos(int arg, long nanosTimeout)        throws InterruptedException {    if (nanosTimeout &lt;= 0L)        return false;    final long deadline = System.nanoTime() + nanosTimeout;    final Node node = addWaiter(Node.EXCLUSIVE);    boolean failed = true;    try {        for (;;) {            final Node p = node.predecessor();            if (p == head &amp;&amp; tryAcquire(arg)) {                setHead(node);                p.next = null; // help GC                failed = false;                return true;            }            nanosTimeout = deadline - System.nanoTime();            if (nanosTimeout &lt;= 0L)                return false;            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                nanosTimeout &gt; spinForTimeoutThreshold)                LockSupport.parkNanos(this, nanosTimeout);            if (Thread.interrupted())                throw new InterruptedException();        }    } finally {        if (failed)            cancelAcquire(node);    }}</code></pre><p>ReentrantLock<br>锁是Java编程中最重要的同步机制，除了让临界区互斥执行之外，还可以让释放锁的线程向获取锁的线程发送消息。当线程释放锁时，JMM会把该线程对应的本地cache中的共享变量刷新到主存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得临界区的代码必须从主存中读取共享变量。</p><p>对比锁和volatile的内存语义可以看出：锁的释放与volatile的写操作有相同的内存语义，锁的获取与volatile的读操作有相同的内存语义。<br>公平锁加锁<br>ReentrantLock#lock<br>public void lock() {<br>    sync.lock();<br>}</p><p>FairSync#lock<br>final void lock() {<br>    acquire(1);<br>}</p><p>FairSync#tryAcquire（重入）<br>状态值在没有线程持有锁时为0，有线程持有锁时大于0</p><p>获取状态<br>1）如果为0，表示是首次获取，判断同步队列中当前节点是否有前驱节点<br>    1.1）如果有前驱节点，那么说明锁已被其他线程占有，返回失败<br>    1.2) 如果没有前驱节点，那么说明当前节点为head，CAS将状态设置为1<br>        1.2.1) 如果设置成功，那么获取锁成功，将独占锁持有者设置为当前线程<br>        1.2.2) 如果设置失败，那么说明锁竞争失败，返回失败<br>2）如果不为0，判断独占锁持有者是否是当前线程<br>    2.1）如果是，那么说明出现了重入，则将状态++<br>    2.2）如果不是，那么说明锁已被其他线程占有，返回失败</p><p>与非公平的tryAcquire相比，多了一个方法调用hasQueuedPredecessors，即加入了同步队列中当前节点是否有前驱节点的判断。如果有前驱节点，那么有线程比当前线程更早地请求锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。<br>protected final boolean tryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();<br>    int c = getState();<br>// 首次获取<br>    if (c == 0) {<br>        if (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(0, acquires)) {<br>            setExclusiveOwnerThread(current);<br>            return true;<br>        }<br>    }<br>// 重入<br>    else if (current == getExclusiveOwnerThread()) {<br>        int nextc = c + acquires;<br>        if (nextc &lt; 0)<br>            throw new Error(“Maximum lock count exceeded”);<br>        setState(nextc);<br>        return true;<br>    }<br>// 已被其他线程占有<br>    return false;<br>}<br>hasQueuedPredecessors<br>public final boolean hasQueuedPredecessors() {<br>    // The correctness of this depends on head being initialized<br>    // before tail and on head.next being accurate if the current<br>    // thread is first in queue.<br>    Node t = tail; // Read fields in reverse initialization order<br>    Node h = head;<br>    Node s;<br>    return h != t &amp;&amp;<br>        ((s = h.next) == null || s.thread != Thread.currentThread());<br>}</p><p>公平锁解锁<br>ReentrantLock#unlock<br>public void unlock() {<br>    sync.release(1);<br>}</p><p>Sync#tryRelease<br>1）如果当前线程不是独占锁持有者，则抛出异常。<br>2）获取状态，将状态值减一，如果减为0，则将独占锁持有者设置为null，表示当前线程不再持有这个锁<br>3）更新状态值</p><p>protected final boolean tryRelease(int releases) {<br>    int c = getState() - releases;<br>    if (Thread.currentThread() != getExclusiveOwnerThread())<br>        throw new IllegalMonitorStateException();<br>    boolean free = false;<br>    if (c == 0) {<br>        free = true;<br>        setExclusiveOwnerThread(null);<br>    }<br>    setState(c);<br>    return free;<br>}</p><p>公平锁总结<br>在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享内存，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</p><p>非公平锁加锁<br>NonfairSync#lock<br>CAS同时具有volatile读和volatile写的内存语义。<br>底层是基于CPU的cmpxchg指令实现的，Intel会规定该指令：禁止该指令与 之前 和 之后 的读写指令重排序；把写缓冲区中的所有数据刷新到内存中。<br>这一点就足以同时实现volatile读和volatile写的内存语义了。</p><p>final void lock() {<br>    if (compareAndSetState(0, 1))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    else<br>        acquire(1);<br>}</p><p>AQS#acquire<br>public final void acquire(int arg) {<br>    if (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>}</p><p>NonfairLock#tryAcquire<br>protected final boolean tryAcquire(int acquires) {<br>    return nonfairTryAcquire(acquires);<br>}<br>NonfairLock#nonfairTryAcquire（重入）<br>final boolean nonfairTryAcquire(int acquires) {<br>    final Thread current = Thread.currentThread();<br>    int c = getState();<br>    if (c == 0) {<br>        if (compareAndSetState(0, acquires)) {<br>            setExclusiveOwnerThread(current);<br>            return true;<br>        }<br>    }<br>    else if (current == getExclusiveOwnerThread()) {<br>        int nextc = c + acquires;<br>        if (nextc &lt; 0) // overflow<br>            throw new Error(“Maximum lock count exceeded”);<br>        setState(nextc);<br>        return true;<br>    }<br>    return false;<br>}</p><p>ReentrantReadWriteLock<br>读写状态的设计<br>读写锁的自定义同步器需要在同步状态上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果在一个整型变量上维护多种状态就需要按位切割使用该变量，读写锁把变量切成了两个部分，高16位表示读，低16位表示写。</p><p>当前同步状态为S，则写状态=S&amp;0x0000FFFF，读状态=S&gt;&gt;&gt;16。<br>写状态加一，就是S+1；读状态加一，就是S+（1&lt;&lt;16）。<br>S不为0时，若写状态为0，则读状态大于0，读锁已被获取。<br>写锁的获取与释放<br>写锁是一个支持重入的排它锁。如果当前线程已经获取了写锁，则增加写状态，如果当前线程在获取写锁时，读锁已经被获取，或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。<br>WriteLock#lock<br>public void lock() {<br>    sync.acquire(1);<br>}<br>Sync#tryAcquire<br>如果存在读锁，那么写锁不能被获取。因为读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都是释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</p><p>获取状态<br>1）如果状态不为0，计算写状态<br>    如果写状态为0（存在读锁）或者独占锁持有者不是当前线程，则返回失败<br>    否则是写线程重入的情况，更新写状态++，返回成功<br>2）如果状态为0，如果是公平锁，那么判断当前节点是否有后继节点<br>    2.1）如果有，则返回失败<br>    2.2）如果没有，或者是非公平锁，则CAS更新写状态++<br>        2.2.1）如果更新失败，则返回失败<br>        2.2.2) 如果更新成功，则将独占锁持有者设置为当前线程，返回成功<br>protected final boolean tryAcquire(int acquires) {<br>    Thread current = Thread.currentThread();<br>    int c = getState();<br>    int w = exclusiveCount(c);<br>    if (c != 0) {<br>        // (Note: if c != 0 and w == 0 then shared count != 0)<br>        if (w == 0 || current != getExclusiveOwnerThread())<br>            return false;<br>        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            throw new Error(“Maximum lock count exceeded”);<br>        // Reentrant acquire<br>        setState(c + acquires);<br>        return true;<br>    }<br>    if (writerShouldBlock() ||<br>        !compareAndSetState(c, c + acquires))<br>        return false;<br>    setExclusiveOwnerThread(current);<br>    return true;<br>}</p><p>writerShouldBlock<br>如果是公平，那么返回当前节点是否有后继节点，即hasQueuedPredecessors；如果是非公平，则直接返回false<br>WriteLock#unlock<br>public void unlock() {<br>    sync.release(1);<br>}</p><p>Sync#tryRelease<br>protected final boolean tryRelease(int releases) {<br>    if (!isHeldExclusively())<br>        throw new IllegalMonitorStateException();<br>    int nextc = getState() - releases;<br>    boolean free = exclusiveCount(nextc) == 0;<br>    if (free)<br>        setExclusiveOwnerThread(null);<br>    setState(nextc);<br>    return free;<br>}<br>读锁的获取与释放（放弃）<br>读锁是一个支持重入的共享锁，它能够被多个线程同时获取，在写状态为0时，读锁总会成功地获取，而所做的也只是线程安全地增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已经被其他线程获取，则进入等待状态。<br>在Java6中除了保存所有线程获取读锁次数的总和（state的高16位），也保存了每个线程各自获取读锁的次数（ThreadLocal）。</p><p>ReadLock#lock<br>public void lock() {<br>    sync.acquireShared(1);<br>}</p><p>Sync#tryAcquireShared</p><p>1）如果有线程持有写锁并且不是当前线程，直接返回失败；<br>2）获取读状态<br>2.1）如果是公平锁，那么判断当前节点是否有后继节点<br>    2.1.1）如果有，则执行fullTryAcquireShared<br>    2.1.2) 如果没有，继续执行<br>2.2）如果是非公平锁，那么判断<br>CAS设置state成功，则设置读锁count的值。这一步并没有检查读锁重入的情况，被延迟到fullTryAcquireShared里了，因为大多数情况下不是重入的；<br>3.如果步骤2失败了，或许是队列策略返回false或许是CAS设置失败了等，则执行fullTryAcquireShared。</p><p>protected final int tryAcquireShared(int unused) {<br>    Thread current = Thread.currentThread();<br>    int c = getState();<br>// 有其他写线程，则失败<br>    if (exclusiveCount(c) != 0 &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        return -1;<br>    int r = sharedCount(c);<br>    if (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br>        compareAndSetState(c, c + SHARED_UNIT)) {<br>        if (r == 0) {<br>            firstReader = current;<br>            firstReaderHoldCount = 1;<br>        } else if (firstReader == current) {<br>            firstReaderHoldCount++;<br>        } else {<br>            HoldCounter rh = cachedHoldCounter;<br>            if (rh == null || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            else if (rh.count == 0)<br>                readHolds.set(rh);<br>            rh.count++;<br>        }<br>        return 1;<br>    }<br>    return fullTryAcquireShared(current);<br>}<br>readerShouldBlock<br>如果是公平，那么返回当前节点是否有后继节点，即hasQueuedPredecessors；如果是非公平，则调用apparentlyFirstQueuedIsExclusive<br>/**</p><ul><li>Returns {@code true} if the apparent first queued thread, if one</li><li>exists, is waiting in exclusive mode.  If this method returns</li><li>{@code true}, and the current thread is attempting to acquire in</li><li>shared mode (that is, this method is invoked from {@link</li><li>#tryAcquireShared}) then it is guaranteed that the current thread</li><li>is not the first queued thread.  Used only as a heuristic in</li><li>ReentrantReadWriteLock.</li><li>/<br>final boolean apparentlyFirstQueuedIsExclusive() {<br>  Node h, s;<br>  return (h = head) != null &amp;&amp;<pre><code>  (s = h.next)  != null &amp;&amp;  !s.isShared()         &amp;&amp;  s.thread != null;</code></pre>}</li></ul><p>fullTryAcquireShared<br>final int fullTryAcquireShared(Thread current) {<br>    /<em>     </em> This code is in part redundant with that in<br>     <em> tryAcquireShared but is simpler overall by not     </em> complicating tryAcquireShared with interactions between<br>     <em> retries and lazily reading hold counts.     </em>/<br>    HoldCounter rh = null;<br>    for (;;) {<br>        int c = getState();<br>        if (exclusiveCount(c) != 0) {<br>// 有线程持有写锁且不是当前线程，直接失败<br>            if (getExclusiveOwnerThread() != current)<br>                return -1;<br>// 如果队列策略不允许，需要检查是否是读锁重入的情况。队列策略是否允许，分两种情况:<br>// 1.公平模式：如果当前AQS队列前面有等待的结点，返回false；2.非公平模式：如果<br>// AQS前面有线程在等待写锁，返回false(这样做的原因是为了防止写饥饿)。<br>        } else if (readerShouldBlock()) {<br>            // 如果当前线程是第一个获取读锁的线程，则有资格获取读锁<br>            if (firstReader == current) {<br>                // assert firstReaderHoldCount &gt; 0;<br>            } else {<br>// 优先赋值成上一次获取读锁成功的cache，如果发现线程tid和当前线程不相等，再从ThreadLocal里获取<br>                if (rh == null) {<br>                    rh = cachedHoldCounter;<br>                    if (rh == null || rh.tid != getThreadId(current)) {<br>                        rh = readHolds.get();<br>                        if (rh.count == 0)<br>                            readHolds.remove();<br>                    }<br>                }<br>// 说明不是读锁重入的情况，直接返回失败了<br>                if (rh.count == 0)<br>                    return -1;<br>            }<br>        }<br>        if (sharedCount(c) == MAX_COUNT)<br>            throw new Error(“Maximum lock count exceeded”);<br>        if (compareAndSetState(c, c + SHARED_UNIT)) {<br>// 设置当前线程为第一个获取读锁的线程<br>            if (sharedCount(c) == 0) {<br>                firstReader = current;<br>                firstReaderHoldCount = 1;<br>// 读锁重入<br>            } else if (firstReader == current) {<br>                firstReaderHoldCount++;<br>            } else {<br>// 其他获取读锁成功的情况<br>                if (rh == null)<br>                    rh = cachedHoldCounter;<br>                if (rh == null || rh.tid != getThreadId(current))<br>                    rh = readHolds.get();<br>                else if (rh.count == 0)<br>                    readHolds.set(rh);<br>                rh.count++;<br>                cachedHoldCounter = rh; // cache for release<br>            }<br>            return 1;<br>        }<br>    }<br>}</p><p>锁降级<br>锁降级是指把持有写锁，再获取到读锁，随后释放写锁的过程。</p><p>锁降级中读锁的获取是否必要？主要是为了保证数据的可见性。如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程T获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞。</p><p>LockSupport<br>public static void park() {<br>    UNSAFE.park(false, 0L);<br>}</p><p>/**</p><ul><li>Block current thread, returning when a balancing</li><li><tt>unpark</tt> occurs, or a balancing <tt>unpark</tt> has</li><li>already occurred, or the thread is interrupted, or, if not</li><li>absolute and time is not zero, the given time nanoseconds have</li><li>elapsed, or if absolute, the given deadline in milliseconds</li><li>since Epoch has passed, or spuriously (i.e., returning for no</li><li>“reason”). Note: This operation is in the Unsafe class only</li><li>because <tt>unpark</tt> is, so it would be strange to place it</li><li>elsewhere.</li><li>/<br>public native void park(boolean isAbsolute, long time);</li></ul><p>Unsafe_Park<br>UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv <em>env, jobject unsafe, jboolean isAbsolute, jlong time))<br>  UnsafeWrapper(“Unsafe_Park”);<br>  EventThreadPark event;<br>#ifndef USDT2<br>  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);<br>#else /</em> USDT2 <em>/<br>   HOTSPOT_THREAD_PARK_BEGIN(<br>                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);<br>#endif /</em> USDT2 <em>/<br>  JavaThreadParkedState jtps(thread, time != 0);<br>  thread-&gt;parker()-&gt;park(isAbsolute != 0, time);<br>#ifndef USDT2<br>  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());<br>#else /</em> USDT2 <em>/<br>  HOTSPOT_THREAD_PARK_END(<br>                          (uintptr_t) thread-&gt;parker());<br>#endif /</em> USDT2 <em>/<br>  if (event.should_commit()) {<br>    oop obj = thread-&gt;current_park_blocker();<br>    event.set_klass((obj != NULL) ? obj-&gt;klass() : NULL);<br>    event.set_timeout(time);<br>    event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop<uintptr_t>(obj) : 0);<br>    event.commit();<br>  }<br>UNSAFE_END<br>Parker<br>定义私有属性_counter：可以理解为是否可以调用park的一个许可证，只有_count &gt; 0的时候才能调用；<br>提供public方法park和unpark支撑阻塞/唤醒线程；<br>Parker继承PlatformParker<br>class Parker : public os::PlatformParker {<br>private:<br>  volatile int _counter ;<br>  Parker </em> FreeNext ;<br>  JavaThread * AssociatedWith ; // Current association</p><p>public:<br>  Parker() : PlatformParker() {<br>    _counter       = 0 ;<br>    FreeNext       = NULL ;<br>    AssociatedWith = NULL ;<br>  }<br>protected:<br>  ~Parker() { ShouldNotReachHere(); }<br>public:<br>  // For simplicity of interface with Java, all forms of park (indefinite,<br>  // relative, and absolute) are multiplexed into one call.<br>  void park(bool isAbsolute, jlong time);<br>  void unpark();</p><p>  // Lifecycle operators<br>  static Parker <em> Allocate (JavaThread </em> t) ;<br>  static void Release (Parker <em> e) ;<br>private:<br>  static Parker </em> volatile FreeList ;<br>  static volatile int ListLock ;</p><p>};</p><p>Linux#PlatformParker<br>linux下的PlatformParker，基于POSIX的线程编写的。<br>POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。Windows操作系统也有其移植版pthreads-win32  <br>class PlatformParker : public CHeapObj<mtInternal> {<br>  protected:<br>    enum {<br>        REL_INDEX = 0,<br>        ABS_INDEX = 1<br>    };<br>    int _cur_index;  // which cond is in use: -1, 0, 1<br>    pthread_mutex_t _mutex [1] ;<br>    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.</p><p>  public:       // TODO-FIXME: make dtor private<br>    ~PlatformParker() { guarantee (0, “invariant”) ; }</p><p>  public:<br>    PlatformParker() {<br>      int status;<br>      status = pthread_cond_init (&amp;_cond[REL_INDEX], os::Linux::condAttr());<br>      assert_status(status == 0, status, “cond_init rel”);<br>      status = pthread_cond_init (&amp;_cond[ABS_INDEX], NULL);<br>      assert_status(status == 0, status, “cond_init abs”);<br>      status = pthread_mutex_init (_mutex, NULL);<br>      assert_status(status == 0, status, “mutex_init”);<br>      _cur_index = -1; // mark as unused<br>    }<br>};<br>Parker#park<br>用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。</p><p>1、先尝试使用Atomic的xchg，CAS查看counter是否大于0，如果是，那么更新为0，返回<br>2、构造一个ThreadBlockInVM，判断如果_counter &gt; 0，可以调用，将_counter置为0，，unlock mutex，返回<br>3、根据等待时间调用不同的等待函数等待，如果等待返回正确，将_counter置为0，unlock mutex，返回，park调用成功。<br>void Parker::park(bool isAbsolute, jlong time) {<br>  // Ideally we’d do something useful while spinning, such<br>  // as calling unpackTime().</p><p>  // Optional fast-path check:<br>  // Return immediately if a permit is available.<br>  // We depend on Atomic::xchg() having full barrier semantics<br>  // since we are doing a lock-free update to _counter.<br>  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</p><p>  Thread<em> thread = Thread::current();<br>  assert(thread-&gt;is_Java_thread(), “Must be JavaThread”);<br>  JavaThread </em>jt = (JavaThread *)thread;</p><p>  // Optional optimization – avoid state transitions if there’s an interrupt pending.<br>  // Check interrupt before trying to wait<br>  if (Thread::is_interrupted(thread, false)) {<br>    return;<br>  }</p><p>  // Next, demultiplex/decode time arguments<br>  timespec absTime;<br>  if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0) ) { // don’t wait at all<br>    return;<br>  }<br>  if (time &gt; 0) {<br>    unpackTime(&amp;absTime, isAbsolute, time);<br>  }</p><p>  // Enter safepoint region<br>  // Beware of deadlocks such as 6317397.<br>  // The per-thread Parker:: mutex is a classic leaf-lock.<br>  // In particular a thread must never block on the Threads_lock while<br>  // holding the Parker:: mutex.  If safepoints are pending both the<br>  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.<br>  ThreadBlockInVM tbivm(jt);</p><p>  // Don’t wait if cannot get lock since interference arises from<br>  // unblocking.  Also. check interrupt before trying wait<br>  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {<br>    return;<br>  }</p><p>  int status ;<br>  if (_counter &gt; 0)  { // no wait needed<br>    _counter = 0;<br>    status = pthread_mutex_unlock(_mutex);<br>    assert (status == 0, “invariant”) ;<br>    // Paranoia to ensure our locked and lock-free paths interact<br>    // correctly with each other and Java-level accesses.<br>    OrderAccess::fence();<br>    return;<br>  }</p><p>#ifdef ASSERT<br>  // Don’t catch signals while blocked; let the running threads have the signals.<br>  // (This allows a debugger to break into the running thread.)<br>  sigset_t oldsigs;<br>  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();<br>  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &amp;oldsigs);<br>#endif</p><p>  OSThreadWaitState osts(thread-&gt;osthread(), false /<em> not Object.wait() </em>/);<br>  jt-&gt;set_suspend_equivalent();<br>  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()</p><p>  assert(_cur_index == -1, “invariant”);<br>  if (time == 0) {<br>    _cur_index = REL_INDEX; // arbitrary choice when not timed<br>    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;<br>  } else {<br>    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;<br>    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;<br>    if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) {<br>      pthread_cond_destroy (&amp;_cond[_cur_index]) ;<br>      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());<br>    }<br>  }<br>  _cur_index = -1;<br>  assert_status(status == 0 || status == EINTR ||<br>                status == ETIME || status == ETIMEDOUT,<br>                status, “cond_timedwait”);</p><p>#ifdef ASSERT<br>  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);<br>#endif</p><p>  _counter = 0 ;<br>  status = pthread_mutex_unlock(_mutex) ;<br>  assert_status(status == 0, status, “invariant”) ;<br>  // Paranoia to ensure our locked and lock-free paths interact<br>  // correctly with each other and Java-level accesses.<br>  OrderAccess::fence();</p><p>  // If externally suspended while waiting, re-suspend<br>  if (jt-&gt;handle_special_suspend_equivalent_condition()) {<br>    jt-&gt;java_suspend_self();<br>  }<br>}</p><p>Parker#unpark<br>将_counter置为1；<br>判断之前_counter的值：<br>小于1时，调用pthread_cond_signal唤醒在park中等待的线程,unlock mutex；<br>等于1时，unlock mutex，返回。<br>void Parker::unpark() {<br>  int s, status ;<br>  status = pthread_mutex_lock(_mutex);<br>  assert (status == 0, “invariant”) ;<br>  s = _counter;<br>  _counter = 1;<br>  if (s &lt; 1) {<br>    // thread might be parked<br>    if (_cur_index != -1) {<br>      // thread is definitely parked<br>      if (WorkAroundNPTLTimedWaitHang) {<br>        status = pthread_cond_signal (&amp;_cond[_cur_index]);<br>        assert (status == 0, “invariant”);<br>        status = pthread_mutex_unlock(_mutex);<br>        assert (status == 0, “invariant”);<br>      } else {<br>        status = pthread_mutex_unlock(_mutex);<br>        assert (status == 0, “invariant”);<br>        status = pthread_cond_signal (&amp;_cond[_cur_index]);<br>        assert (status == 0, “invariant”);<br>      }<br>    } else {<br>      pthread_mutex_unlock(_mutex);<br>      assert (status == 0, “invariant”) ;<br>    }<br>  } else {<br>    pthread_mutex_unlock(_mutex);<br>    assert (status == 0, “invariant”) ;<br>  }<br>}</p><p>wait&amp;notify（忽略）<br>1）使用wait、notify、notifyAll时需要先对调用对象加锁<br>2）调用wait方法后，会放弃对象的锁，线程状态由运行态转为等待态，并将当前线程放置到对象的等待队列<br>3）notify或notifyAll方法调用后，等待线程不会从wait返回，需要调用notify或notifyAll的线程释放锁后，等待线程才有机会从wait返回<br>4）notify方法是将等待队列中的一个等待线程能从等待队列移至同步队列中，notifyAll方法是将等待队列中的所有线程全部移至同步队列中，被移动的线程状态由等待态转为阻塞态<br>5）从wait方法返回的前提是获得了调用对象的锁</p><p>wait&amp;notify前提也是基于monitorenter、monitorexit指令实现的（对应1））。</p><p>WaitThread首先获取了对象的锁，然后调用对象的wait方法，从而放弃了锁，并进入了对象的等待队列WaitQueue中，进入等待状态。<br>由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify方法，将WaitThrad从等待队列WaitQueue移到同步队列SynchronizedQueue中，此时WaitThread状态变为阻塞态。NotifyThread释放了锁之后，WaitThread再次获取到了锁，并从wait方法返回继续执行。<br>ObjectMonitor#wait<br>在HotSpot虚拟机中，monitor采用ObjectMonitor实现。<br>void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {<br>   Thread <em> const Self = THREAD ;<br>   assert(Self-&gt;is_Java_thread(), “Must be Java thread!”);<br>   JavaThread </em>jt = (JavaThread *)THREAD;</p><p>   DeferredInitialize () ;</p><p>   // Throw IMSX or IEX.<br>   CHECK_OWNER();</p><p>   EventJavaMonitorWait event;</p><p>   // check for a pending interrupt<br>   if (interruptible &amp;&amp; Thread::is_interrupted(Self, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {<br>     // post monitor waited event.  Note that this is past-tense, we are done waiting.<br>     if (JvmtiExport::should_post_monitor_waited()) {<br>        // Note: ‘false’ parameter is passed here because the<br>        // wait was not timed out due to thread interrupt.<br>        JvmtiExport::post_monitor_waited(jt, this, false);<br>     }<br>     if (event.should_commit()) {<br>       post_monitor_wait_event(&amp;event, 0, millis, false);<br>     }<br>     TEVENT (Wait - Throw IEX) ;<br>     THROW(vmSymbols::java_lang_InterruptedException());<br>     return ;<br>   }</p><p>   TEVENT (Wait) ;</p><p>   assert (Self-&gt;_Stalled == 0, “invariant”) ;<br>   Self-&gt;_Stalled = intptr_t(this) ;<br>   jt-&gt;set_current_waiting_monitor(this);</p><p>   // create a node to be put into the queue<br>   // Critically, after we reset() the event but prior to park(), we must check<br>   // for a pending interrupt.<br>   ObjectWaiter node(Self);<br>   node.TState = ObjectWaiter::TS_WAIT ;<br>   Self-&gt;_ParkEvent-&gt;reset() ;<br>   OrderAccess::fence();          // ST into Event; membar ; LD interrupted-flag</p><p>   // Enter the waiting queue, which is a circular doubly linked list in this case<br>   // but it could be a priority queue or any data structure.<br>   // _WaitSetLock protects the wait queue.  Normally the wait queue is accessed only<br>   // by the the owner of the monitor <em>except</em> in the case where park()<br>   // returns because of a timeout of interrupt.  Contention is exceptionally rare<br>   // so we use a simple spin-lock instead of a heavier-weight blocking lock.</p><p>   Thread::SpinAcquire (&amp;_WaitSetLock, “WaitSet - add”) ;<br>   AddWaiter (&amp;node) ;<br>   Thread::SpinRelease (&amp;_WaitSetLock) ;</p><p>   if ((SyncFlags &amp; 4) == 0) {<br>      _Responsible = NULL ;<br>   }<br>   intptr_t save = _recursions; // record the old recursion count<br>   _waiters++;                  // increment the number of waiters<br>   _recursions = 0;             // set the recursion level to be 1<br>   exit (true, Self) ;                    // exit the monitor<br>   guarantee (_owner != Self, “invariant”) ;</p><p>   // As soon as the ObjectMonitor’s ownership is dropped in the exit()<br>   // call above, another thread can enter() the ObjectMonitor, do the<br>   // notify(), and exit() the ObjectMonitor. If the other thread’s<br>   // exit() call chooses this thread as the successor and the unpark()<br>   // call happens to occur while this thread is posting a<br>   // MONITOR_CONTENDED_EXIT event, then we run the risk of the event<br>   // handler using RawMonitors and consuming the unpark().<br>   //<br>   // To avoid the problem, we re-post the event. This does no harm<br>   // even if the original unpark() was not consumed because we are the<br>   // chosen successor for this monitor.<br>   if (node._notified != 0 &amp;&amp; _succ == Self) {<br>      node._event-&gt;unpark();<br>   }</p><p>   // The thread is on the WaitSet list - now park() it.<br>   // On MP systems it’s conceivable that a brief spin before we park<br>   // could be profitable.<br>   //<br>   // TODO-FIXME: change the following logic to a loop of the form<br>   //   while (!timeout &amp;&amp; !interrupted &amp;&amp; _notified == 0) park()</p><p>   int ret = OS_OK ;<br>   int WasNotified = 0 ;<br>   { // State transition wrappers<br>     OSThread* osthread = Self-&gt;osthread();<br>     OSThreadWaitState osts(osthread, true);<br>     {<br>       ThreadBlockInVM tbivm(jt);<br>       // Thread is in thread_blocked state and oop access is unsafe.<br>       jt-&gt;set_suspend_equivalent();</p><pre><code>   if (interruptible &amp;&amp; (Thread::is_interrupted(THREAD, false) || HAS_PENDING_EXCEPTION)) {       // Intentionally empty   } else   if (node._notified == 0) {     if (millis &lt;= 0) {        Self-&gt;_ParkEvent-&gt;park () ;     } else {        ret = Self-&gt;_ParkEvent-&gt;park (millis) ;     }   }   // were we externally suspended while we were waiting?   if (ExitSuspendEquivalent (jt)) {      // TODO-FIXME: add -- if succ == Self then succ = null.      jt-&gt;java_suspend_self();   } } // Exit thread safepoint: transition _thread_blocked -&gt; _thread_in_vm // Node may be on the WaitSet, the EntryList (or cxq), or in transition // from the WaitSet to the EntryList. // See if we need to remove Node from the WaitSet. // We use double-checked locking to avoid grabbing _WaitSetLock // if the thread is not on the wait queue. // // Note that we don&#39;t need a fence before the fetch of TState. // In the worst case we&#39;ll fetch a old-stale value of TS_WAIT previously // written by the is thread. (perhaps the fetch might even be satisfied // by a look-aside into the processor&#39;s own store buffer, although given // the length of the code path between the prior ST and this load that&#39;s // highly unlikely).  If the following LD fetches a stale TS_WAIT value // then we&#39;ll acquire the lock and then re-fetch a fresh TState value. // That is, we fail toward safety. if (node.TState == ObjectWaiter::TS_WAIT) {     Thread::SpinAcquire (&amp;_WaitSetLock, &quot;WaitSet - unlink&quot;) ;     if (node.TState == ObjectWaiter::TS_WAIT) {        DequeueSpecificWaiter (&amp;node) ;       // unlink from WaitSet        assert(node._notified == 0, &quot;invariant&quot;);        node.TState = ObjectWaiter::TS_RUN ;     }     Thread::SpinRelease (&amp;_WaitSetLock) ; } // The thread is now either on off-list (TS_RUN), // on the EntryList (TS_ENTER), or on the cxq (TS_CXQ). // The Node&#39;s TState variable is stable from the perspective of this thread. // No other threads will asynchronously modify TState. guarantee (node.TState != ObjectWaiter::TS_WAIT, &quot;invariant&quot;) ; OrderAccess::loadload() ; if (_succ == Self) _succ = NULL ; WasNotified = node._notified ; // Reentry phase -- reacquire the monitor. // re-enter contended monitor after object.wait(). // retain OBJECT_WAIT state until re-enter successfully completes // Thread state is thread_in_vm and oop access is again safe, // although the raw address of the object may have changed. // (Don&#39;t cache naked oops over safepoints, of course). // post monitor waited event. Note that this is past-tense, we are done waiting. if (JvmtiExport::should_post_monitor_waited()) {   JvmtiExport::post_monitor_waited(jt, this, ret == OS_TIMEOUT); } if (event.should_commit()) {   post_monitor_wait_event(&amp;event, node._notifier_tid, millis, ret == OS_TIMEOUT); } OrderAccess::fence() ; assert (Self-&gt;_Stalled != 0, &quot;invariant&quot;) ; Self-&gt;_Stalled = 0 ; assert (_owner != Self, &quot;invariant&quot;) ; ObjectWaiter::TStates v = node.TState ; if (v == ObjectWaiter::TS_RUN) {     enter (Self) ; } else {     guarantee (v == ObjectWaiter::TS_ENTER || v == ObjectWaiter::TS_CXQ, &quot;invariant&quot;) ;     ReenterI (Self, &amp;node) ;     node.wait_reenter_end(this); } // Self has reacquired the lock. // Lifecycle - the node representing Self must not appear on any queues. // Node is about to go out-of-scope, but even if it were immortal we wouldn&#39;t // want residual elements associated with this thread left on any lists. guarantee (node.TState == ObjectWaiter::TS_RUN, &quot;invariant&quot;) ; assert    (_owner == Self, &quot;invariant&quot;) ; assert    (_succ != Self , &quot;invariant&quot;) ;</code></pre><p>   } // OSThreadWaitState()</p><p>   jt-&gt;set_current_waiting_monitor(NULL);</p><p>   guarantee (_recursions == 0, “invariant”) ;<br>   _recursions = save;     // restore the old recursion count<br>   _waiters–;             // decrement the number of waiters</p><p>   // Verify a few postconditions<br>   assert (_owner == Self       , “invariant”) ;<br>   assert (_succ  != Self       , “invariant”) ;<br>   assert (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), “invariant”) ;</p><p>   if (SyncFlags &amp; 32) {<br>      OrderAccess::fence() ;<br>   }</p><p>   // check if the notification happened<br>   if (!WasNotified) {<br>     // no, it could be timeout or Thread.interrupt() or both<br>     // check for interrupt event, otherwise it is timeout<br>     if (interruptible &amp;&amp; Thread::is_interrupted(Self, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {<br>       TEVENT (Wait - throw IEX from epilog) ;<br>       THROW(vmSymbols::java_lang_InterruptedException());<br>     }<br>   }</p><p>   // NOTE: Spurious wake up will be consider as timeout.<br>   // Monitor notify has precedence over thread interrupt.<br>}</p><p>Condition<br>每个Condition对象都包含着一个等待队列，该队列是Condition对象实现等待/通知功能的关键。<br>Condition的实现类是AQS的内部类ConditionObject。<br>ConditionObject<br>/<em>* First node of condition queue. </em>/<br>private transient Node firstWaiter;<br>/<em>* Last node of condition queue. </em>/<br>private transient Node lastWaiter;<br>等待队列<br>等待队列是一个FIFO的队列，在队列的每个节点上都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。<br>Condition拥有等待队列的首节点firstWaiter和尾节点lastWaiter。<br>每个Node都持有同一个队列中下一个Node的引用。</p><p>Condition拥有首尾节点的引用，新增节点时仅需将原有的尾节点的nextWaiter指针指向它， 并更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，因为调用await方法的线程必定时获取了锁的线程。<br>在Object的监视器模型上，一个对象拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。</p><p>Condition是AQS同步器的内部类，所以每个Conditions实例都能访问同步器提供的方法。</p><p>AQS维护了一个同步队列，一个AQS对应多个Condition，每个Condition维护了一个等待队列。</p><p>ConditionObject#await</p><p>public final void await() throws InterruptedException {<br>    if (Thread.interrupted())<br>        throw new InterruptedException();<br>// 当前线程构造为Node，加入到等待队列<br>    Node node = addConditionWaiter();<br>// 释放锁,唤醒同步队列中的后继节点<br>    long savedState = fullyRelease(node);<br>    int interruptMode = 0;<br>// 阻塞，直至被其他线程唤醒或中断<br>    while (!isOnSyncQueue(node)) {<br>        LockSupport.park(this);<br>        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)<br>            break;<br>    }<br>// 重新获取锁<br>    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>// 移出等待队列<br>if (node.nextWaiter != null) // clean up if cancelled<br>        unlinkCancelledWaiters();<br>    if (interruptMode != 0)<br>// 被其他线程中断，抛出InterruptedException异常<br>        reportInterruptAfterWait(interruptMode);<br>}<br>ConditionObject#addConditionWaiter<br>private Node addConditionWaiter() {<br>    Node t = lastWaiter;<br>    // If lastWaiter is cancelled, clean out.<br>    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    }<br>    Node node = new Node(Thread.currentThread(), Node.CONDITION);<br>    if (t == null)<br>        firstWaiter = node;<br>    else<br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    return node;<br>}<br>AQS#fullyRelease<br>/**</p><ul><li>Invokes release with current state value; returns saved state.</li><li>Cancels node and throws exception on failure.</li><li>@param node the condition node for this wait</li><li>@return previous sync state</li><li>/<br>final long fullyRelease(Node node) {<br>  boolean failed = true;<br>  try {<pre><code>  long savedState = getState();  if (release(savedState)) {      failed = false;      return savedState;  } else {      throw new IllegalMonitorStateException();  }</code></pre>  } finally {<pre><code>  if (failed)      node.waitStatus = Node.CANCELLED;</code></pre>  }<br>}<br>AQS#isOnSyncQueue<br>/**</li><li>Returns true if a node, always one that was initially placed on</li><li>a condition queue, is now waiting to reacquire on sync queue.</li><li>@param node the node</li><li>@return true if is reacquiring</li><li>/<br>final boolean isOnSyncQueue(Node node) {<br>  if (node.waitStatus == Node.CONDITION || node.prev == null)<pre><code>  return false;</code></pre>  if (node.next != null) // If has successor, it must be on queue<pre><code>  return true;</code></pre>  /*<ul><li>node.prev can be non-null, but not yet on queue because</li><li>the CAS to place it on queue can fail. So we have to</li><li>traverse from tail to make sure it actually made it.  It</li><li>will always be near the tail in calls to this method, and</li><li>unless the CAS failed (which is unlikely), it will be</li><li>there, so we hardly ever traverse much.</li><li>/<br>return findNodeFromTail(node);<br>}</li></ul></li></ul><p>/**</p><ul><li>Returns true if node is on sync queue by searching backwards from tail.</li><li>Called only when needed by isOnSyncQueue.</li><li>@return true if present</li><li>/<br>private boolean findNodeFromTail(Node node) {<br>  Node t = tail;<br>  for (;;) {<pre><code>  if (t == node)      return true;  if (t == null)      return false;  t = t.prev;</code></pre>  }<br>}</li></ul><p>ConditionObject#checkInterruptWhileWaiting<br>/**</p><ul><li>Checks for interrupt, returning THROW_IE if interrupted</li><li>before signalled, REINTERRUPT if after signalled, or</li><li>0 if not interrupted.</li><li>/<br>private int checkInterruptWhileWaiting(Node node) {<br>  return Thread.interrupted() ?<pre><code>  (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :  0;</code></pre>}</li></ul><p>AQS#acquireQueued<br>/**</p><ul><li>Acquires in exclusive uninterruptible mode for thread already in</li><li>queue. Used by condition wait methods as well as acquire.</li><li></li><li>@param node the node</li><li>@param arg the acquire argument</li><li>@return {@code true} if interrupted while waiting</li><li>/<br>final boolean acquireQueued(final Node node, long arg) {<br>  boolean failed = true;<br>  try {<pre><code>  boolean interrupted = false;  for (;;) {      final Node p = node.predecessor();      if (p == head &amp;&amp; tryAcquire(arg)) {          setHead(node);          p.next = null; // help GC          failed = false;          return interrupted;      }      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;          parkAndCheckInterrupt())          interrupted = true;  }</code></pre>  } finally {<pre><code>  if (failed)      cancelAcquire(node);</code></pre>  }<br>}</li></ul><p>ConditionObject#unlinkCancelledWaiters<br>/**</p><ul><li>Unlinks cancelled waiter nodes from condition queue.</li><li>Called only while holding lock. This is called when</li><li>cancellation occurred during condition wait, and upon</li><li>insertion of a new waiter when lastWaiter is seen to have</li><li>been cancelled. This method is needed to avoid garbage</li><li>retention in the absence of signals. So even though it may</li><li>require a full traversal, it comes into play only when</li><li>timeouts or cancellations occur in the absence of</li><li>signals. It traverses all nodes rather than stopping at a</li><li>particular target to unlink all pointers to garbage nodes</li><li>without requiring many re-traversals during cancellation</li><li>storms.</li><li>/<br>private void unlinkCancelledWaiters() {<br>  Node t = firstWaiter;<br>  Node trail = null;<br>  while (t != null) {<pre><code>  Node next = t.nextWaiter;  if (t.waitStatus != Node.CONDITION) {      t.nextWaiter = null;      if (trail == null)          firstWaiter = next;      else          trail.nextWaiter = next;      if (next == null)          lastWaiter = trail;  }  else      trail = t;  t = next;</code></pre>  }<br>}</li></ul><p>ConditionObject#reportInterruptAfterWait<br>private void reportInterruptAfterWait(int interruptMode)<br>    throws InterruptedException {<br>    if (interruptMode == THROW_IE)<br>        throw new InterruptedException();<br>    else if (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>}</p><p>ConditionObject#signal<br>首先判断当前线程是否获取了锁，然后获取等待队列的首节点，将其移动到同步队列，并使用LockSupport.unpark唤醒节点中的线程。</p><p>public final void signal() {<br>    if (!isHeldExclusively())<br>        throw new IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    if (first != null)<br>        doSignal(first);<br>}</p><p>/**</p><ul><li>Removes and transfers nodes until hit non-cancelled one or</li><li>null. Split out from signal in part to encourage compilers</li><li>to inline the case of no waiters.</li><li>@param first (non-null) the first node on condition queue</li><li>/<br>private void doSignal(Node first) {<br>  do {<pre><code>  if ( (firstWaiter = first.nextWaiter) == null)      lastWaiter = null;  first.nextWaiter = null;</code></pre>  } while (!transferForSignal(first) &amp;&amp;<pre><code>       (first = firstWaiter) != null);</code></pre>}</li></ul><p>AQS#transferForSignal<br>/**</p><ul><li><p>Transfers a node from a condition queue onto sync queue.</p></li><li><p>Returns true if successful.</p></li><li><p>@param node the node</p></li><li><p>@return true if successfully transferred (else the node was</p></li><li><p>cancelled before signal)</p></li><li><p>/<br>final boolean transferForSignal(Node node) {<br>  /*</p><ul><li><p>If cannot change waitStatus, the node has been cancelled.</p></li><li><p>/<br>if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))<br>  return false;</p><p>/*</p></li><li><p>Splice onto queue and try to set waitStatus of predecessor to</p></li><li><p>indicate that thread is (probably) waiting. If cancelled or</p></li><li><p>attempt to set waitStatus fails, wake up to resync (in which</p></li><li><p>case the waitStatus can be transiently and harmlessly wrong).</p></li><li><p>/<br>// 等待队列中的头节点移动到了同步队列<br>Node p = enq(node);<br>int ws = p.waitStatus;<br>if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>// 唤醒该节点的线程<br>  LockSupport.unpark(node.thread);<br>return true;<br>}</p></li></ul></li></ul><p>Semaphore（暂缓）<br>CyclicBarrier（暂缓）<br>CountDownLatch（暂缓）<br>Exchanger（暂缓）<br>AtomicInteger<br>/**</p><ul><li>Atomically increments by one the current value.</li><li></li><li>@return the updated value</li><li>/<br>public final int incrementAndGet() {<br>  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;<br>}</li></ul><p>/**</p><ul><li>Atomically adds the given value to the current value of a field</li><li>or array element within the given object <code>o</code></li><li>at the given <code>offset</code>.</li><li></li><li>@param o object/array to update the field/element in</li><li>@param offset field/element offset</li><li>@param delta the value to add</li><li>@return the previous value</li><li>@since 1.8</li><li>/<br>public final int getAndAddInt(Object o, long offset, int delta) {<br>  int v;<br>  do {<pre><code>  v = getIntVolatile(o, offset);</code></pre>  } while (!compareAndSwapInt(o, offset, v, v + delta));<br>  return v;<br>}</li></ul><p>/<em>* Volatile version of {@link #getInt(Object, long)}  </em>/<br>public native int     getIntVolatile(Object o, long offset);</p><p>/**</p><ul><li>Atomically update Java variable to <tt>x</tt> if it is currently</li><li>holding <tt>expected</tt>.</li><li>@return <tt>true</tt> if successful</li><li>/<br>public final native boolean compareAndSwapInt(Object o, long offset,<pre><code>                                        int expected,                                        int x);</code></pre></li></ul><p>ThreadPoolExeuctor<br>线程池中持有一组Runnable，称为Worker，包装为Thread，调用Thread#start（作为一个线程去启动）。它们的run方法是一个循环，不断获取用户提交的Runnable并调用Runnable#run（不是启动线程，仅仅是方法调用）。<br>状态转换</p><p>成员变量<br>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));<br>private static final int COUNT_BITS = Integer.SIZE - 3;<br>private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</p><p>// runState is stored in the high-order bits<br>private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;<br>private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;<br>private static final int STOP       =  1 &lt;&lt; COUNT_BITS;<br>private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;<br>private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;<br>private final BlockingQueue<Runnable> workQueue;</p><p>private final ReentrantLock mainLock = new ReentrantLock();</p><p>private final HashSet<Worker> workers = new HashSet<Worker>();</p><p>private final Condition termination = mainLock.newCondition();</p><p>private int largestPoolSize;</p><p>private long completedTaskCount;</p><p>private volatile ThreadFactory threadFactory;</p><p>private volatile RejectedExecutionHandler handler;</p><p>private volatile long keepAliveTime;</p><p>private volatile boolean allowCoreThreadTimeOut;</p><p>private volatile int corePoolSize;</p><p>private volatile int maximumPoolSize;</p><p>private static final RejectedExecutionHandler defaultHandler =<br>    new AbortPolicy();<br>private static final RuntimePermission shutdownPerm =<br>    new RuntimePermission(“modifyThread”);</p><p>/<em> The context to be used when executing the finalizer, or null. </em>/<br>private final AccessControlContext acc;</p><p>一个 ctl 变量可以包含两部分信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount). 由于 int 型的变量是由32位二进制的数构成, 所以用 ctl 的高3位来表示线程池的运行状态, 用低29位来表示线程池内有效线程的数量. 由于这两部分信息在该类中很多地方都会使用到, 所以我们也经常会涉及到要获取其中一个信息的操作, 通常来说, 代表这两个信息的变量的名称直接用他们各自英文单词首字母的组合来表示, 所以, 表示线程池运行状态的变量通常命名为 rs, 表示线程池中有效线程数量的变量通常命名为 wc, 另外, ctl 也通常会简写作 c。<br>由于 ctl 变量是由线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)这两个信息组合而成, 所以, 如果知道了这两部分信息各自的数值, 就可以调用下面的 ctlOf() 方法来计算出 ctl 的数值：</p><p>// rs: 表示线程池的运行状态 (rs 是 runState中各单词首字母的简写组合)<br>// wc: 表示线程池内有效线程的数量 (wc 是 workerCount中各单词首字母的简写组合)<br>private static int ctlOf(int rs, int wc) { return rs | wc; }<br>反过来, 如果知道了 ctl 的值, 那么也可以通过如下的 runStateOf() 和 workerCountOf() 两个方法来分别获取线程池的运行状态和线程池内有效线程的数量.<br>private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }<br>private static int workerCountOf(int c)  { return c &amp; CAPACITY; }<br>其中, CAPACITY 等于 (2^29)-1, 也就是高3位是0, 低29位是1的一个int型的数,<br>private static final int COUNT_BITS = Integer.SIZE - 3;     // 29<br>private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;  // COUNT_BITS == 29<br>执行任务</p><p>当提交一个新任务到线程池时，线程池的处理流程如下：<br>1）线程池判断当前运行的线程是否少于corePoolSize（需要获取全局锁），如果不是，则创建一个新的工作线程来执行任务（分配线程）。如果是，则进入2）<br>2）线程池判断工作队列是否已经满了，如果没有满，则将新提交的任务存储到这个工作队列BlockingQueue里。如果满了，则进入3）<br>3）线程池判断创建新的线程是否会使当前运行的线程超过maxPoolSize（需要获取全局锁），如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute方法时，尽可能地避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute方法都是执行步骤2，步骤2不需要获取全局锁。<br>execute（Runnable不进行任何封装）<br>public void execute(Runnable command) {<br>    if (command == null)<br>        throw new NullPointerException();<br>    int c = ctl.get();<br>// 如果当前运行线程数小于corePoolSize<br>    if (workerCountOf(c) &lt; corePoolSize) {<br>// 创建线程并执行当前任务<br>        if (addWorker(command, true))<br>            return;<br>        c = ctl.get();<br>    }<br>// 如果线程池处于运行状态，且（当前运行线程数大于等于corePoolSize或线程创建失败），则将当前任务放入工作队列<br>    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {<br>        int recheck = ctl.get();<br>// 再次检查线程池的状态，如果线程池没有运行，且成功从工作队列中删除任务，则执行reject处理任务<br>        if (!isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        else if (workerCountOf(recheck) == 0)<br>            addWorker(null, false);<br>    }<br>// 如果线程池不处于运行中或任务无法放进队列，并且当前线程数小于maxPoolSize，则创建一个线程执行任务<br>    else if (!addWorker(command, false))<br>// 创建线程失败，则执行reject处理任务<br>        reject(command);<br>}</p><p>1) addWorker<br>addWorker主要负责创建新的线程并执行任务<br>private boolean addWorker(Runnable firstTask, boolean core) {<br>    retry:<br>    for (;;) {<br>        int c = ctl.get();<br>        int rs = runStateOf(c);</p><pre><code>    // Check if queue empty only if necessary.    if (rs &gt;= SHUTDOWN &amp;&amp;        ! (rs == SHUTDOWN &amp;&amp;           firstTask == null &amp;&amp;           ! workQueue.isEmpty()))        return false;    for (;;) {        int wc = workerCountOf(c);        if (wc &gt;= CAPACITY ||            wc &gt;= (core ? corePoolSize : maximumPoolSize))            return false;        if (compareAndIncrementWorkerCount(c))            break retry;        c = ctl.get();  // Re-read ctl        if (runStateOf(c) != rs)            continue retry;        // else CAS failed due to workerCount change; retry inner loop    }}boolean workerStarted = false;boolean workerAdded = false;Worker w = null;try {    w = new Worker(firstTask);    final Thread t = w.thread;    if (t != null) {        final ReentrantLock mainLock = this.mainLock;        mainLock.lock();        try {            // Recheck while holding lock.            // Back out on ThreadFactory failure or if            // shut down before lock acquired.            int rs = runStateOf(ctl.get());            if (rs &lt; SHUTDOWN ||                (rs == SHUTDOWN &amp;&amp; firstTask == null)) {                if (t.isAlive()) // precheck that t is startable                    throw new IllegalThreadStateException();                workers.add(w);                int s = workers.size();                if (s &gt; largestPoolSize)                    largestPoolSize = s;                workerAdded = true;            }        } finally {            mainLock.unlock();        }        if (workerAdded) {            t.start();            workerStarted = true;        }    }} finally {    if (! workerStarted)        addWorkerFailed(w);}return workerStarted;</code></pre><p>}</p><p>1.1) Worker（基于AQS）<br>当addWorker中调用t.start()时，这个t是Worker构造方法中使用ThreadFactory创建出来的Thread，且将this作为Runnable传入，启动t时会调用Worker#run方法。</p><p>private final class Worker<br>    extends AbstractQueuedSynchronizer<br>    implements Runnable<br>{<br>    /<em>*     </em> This class will never be serialized, but we provide a<br>     <em> serialVersionUID to suppress a javac warning.     </em>/<br>    private static final long serialVersionUID = 6138294804551838833L;</p><pre><code>/** Thread this worker is running in.  Null if factory fails. */final Thread thread;/** Initial task to run.  Possibly null. */Runnable firstTask;/** Per-thread task counter */volatile long completedTasks;/** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */Worker(Runnable firstTask) {    setState(-1); // inhibit interrupts until runWorker    this.firstTask = firstTask;    this.thread = getThreadFactory().newThread(this);}/** Delegates main run loop to outer runWorker  */public void run() {    runWorker(this);}// ...</code></pre><p>}</p><p>1.2) Worker#runWorker<br>final void runWorker(Worker w) {<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = null;<br>    w.unlock(); // allow interrupts<br>    boolean completedAbruptly = true;<br>    try {<br>        while (task != null || (task = getTask()) != null) {<br>            w.lock();<br>            // If pool is stopping, ensure thread is interrupted;<br>            // if not, ensure thread is not interrupted.  This<br>            // requires a recheck in second case to deal with<br>            // shutdownNow race while clearing interrupt<br>            if ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            try {<br>                beforeExecute(wt, task);<br>                Throwable thrown = null;<br>                try {<br>                    task.run();<br>                } catch (RuntimeException x) {<br>                    thrown = x; throw x;<br>                } catch (Error x) {<br>                    thrown = x; throw x;<br>                } catch (Throwable x) {<br>                    thrown = x; throw new Error(x);<br>                } finally {<br>                    afterExecute(task, thrown);<br>                }<br>            } finally {<br>                task = null;<br>                w.completedTasks++;<br>                w.unlock();<br>            }<br>        }<br>        completedAbruptly = false;<br>    } finally {<br>        processWorkerExit(w, completedAbruptly);<br>    }<br>}</p><p>1.2.1) ThreadPoolExecutor#getTask<br>1）判断线程池是否已经关闭，如果关闭，则退出循环<br>2）根据当前Worker是否超时，对工作队列调用poll或take方法，进行阻塞。阻塞中的线程就是空闲线程。</p><p>当调用shutdown方法时，首先设置了线程池的状态为ShutDown，此时1阶段的worker进入到状态判断时会返回null，此时Worker退出。<br>因为getTask的时候是不加锁的，所以在shutdown时可以调用worker.Interrupt.此时会中断退出，Loop到状态判断时，同时workQueue为empty。那么抛出中断异常，导致重新Loop，在检测线程池状态时，Worker退出。如果workQueue不为null就不会退出，此处有些疑问，因为没有看见中断标志位清除的逻辑，那么这里就会不停的循环直到workQueue为Empty退出。<br>这里也能看出来SHUTDOWN只是清除一些空闲Worker，并且拒绝新Task加入，对于workQueue中的线程还是继续处理的。<br>对于shutdown中获取mainLock而addWorker中也做了mainLock的获取，这么做主要是因为Works是HashSet类型的，是线程不安全的，我们也看到在addWorker后面也是对线程池状态做了判断，将Worker添加和中断逻辑分离开。</p><p>timed变量主要是标识着当前Worker超时是否要退出。wc &gt; corePoolSize时需要减小空闲的Worker数，那么timed为true，但是wc &lt;= corePoolSize时，不能减小核心线程数timed为false。<br>timedOut初始为false，如果timed为true那么使用poll取线程。如果正常返回，那么返回取到的task。如果超时，证明worker空闲，同时worker超过了corePoolSize，需要删除。返回r=null。则 timedOut = true。此时循环到wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed)时，减小worker数，并返回null，导致worker退出。如果线程数&lt;= corePoolSize，那么此时调用 workQueue.take()，没有线程获取到时将一直阻塞，直到获取到线程或者中断。<br>private Runnable getTask() {<br>    boolean timedOut = false; // Did the last poll() time out?</p><pre><code>for (;;) {    int c = ctl.get();    int rs = runStateOf(c);    // Check if queue empty only if necessary.    if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {        decrementWorkerCount();        return null;    }    int wc = workerCountOf(c);    // Worker是否要减少    // Are workers subject to culling?    boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;    if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))        &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {        if (compareAndDecrementWorkerCount(c))            return null;        continue;    }    // 如果要减少Worker的话，如果在keepAliveTime内没有拿到任务，那么设置为超时，下次循环被会移除；如果不需要减少Worker，那么阻塞获取任务    try {        Runnable r = timed ?            workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :            workQueue.take();        if (r != null)            return r;        timedOut = true;    } catch (InterruptedException retry) {        timedOut = false;    }}</code></pre><p>}</p><p>2) reject<br>final void reject(Runnable command) {<br>    handler.rejectedExecution(command, this);<br>}</p><p>2.1) AbortPolicy#rejectedExecution<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>    throw new RejectedExecutionException(“Task “ + r.toString() +<br>                                         “ rejected from “ +<br>                                         e.toString());<br>}</p><p>2.2) DiscardPolicy#rejectedExecution<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>}</p><p>2.3) DiscardOldestPolicy#rejectedExecution<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>    if (!e.isShutdown()) {<br>        e.getQueue().poll();<br>        e.execute(r);<br>    }<br>}</p><p>2.4) CallerRunsPolicy#rejectedExecution<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>    if (!e.isShutdown()) {<br>        r.run();<br>    }<br>}</p><p>submit（Callable包装为FutureTask）<br>public <T> Future<T> submit(Callable<T> task) {<br>    if (task == null) throw new NullPointerException();<br>    RunnableFuture<T> ftask = newTaskFor(task);<br>    execute(ftask);<br>    return ftask;<br>}</p><p>1) newTaskFor（将Callable包装成Runnable+Future，Runnable可以放在ThreadPoolExecutor中执行）<br>protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {<br>    return new FutureTask<T>(callable);<br>}</p><p>public FutureTask(Callable<V> callable) {<br>    if (callable == null)<br>        throw new NullPointerException();<br>    this.callable = callable;<br>    this.state = NEW;       // ensure visibility of callable<br>}</p><p>1.1) FutureTask#run<br>public void run() {<br>    if (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(this, runnerOffset,<br>                                     null, Thread.currentThread()))<br>        return;<br>    try {<br>        Callable<V> c = callable;<br>        if (c != null &amp;&amp; state == NEW) {<br>            V result;<br>            boolean ran;<br>            try {<br>                result = c.call();<br>                ran = true;<br>            } catch (Throwable ex) {<br>                result = null;<br>                ran = false;<br>                setException(ex);<br>            }<br>            if (ran)<br>                set(result);<br>        }<br>    } finally {<br>        // runner must be non-null until state is settled to<br>        // prevent concurrent calls to run()<br>        runner = null;<br>        // state must be re-read after nulling runner to prevent<br>        // leaked interrupts<br>        int s = state;<br>        if (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    }<br>}<br>1.1.1) FutureTask#set<br>protected void set(V v) {<br>    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {<br>        outcome = v;<br>        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state<br>        finishCompletion();<br>    }<br>}<br>1.1.2) FutureTask#setException<br>protected void setException(Throwable t) {<br>    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {<br>        outcome = t;<br>        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state<br>        finishCompletion();<br>    }<br>}</p><p>1.1.1.1) FutureTask#finishCompletion（唤醒Waiter）<br>private void finishCompletion() {<br>    // assert state &gt; COMPLETING;<br>    for (WaitNode q; (q = waiters) != null;) {<br>        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {<br>            for (;;) {<br>                Thread t = q.thread;<br>                if (t != null) {<br>                    q.thread = null;<br>                    LockSupport.unpark(t);<br>                }<br>                WaitNode next = q.next;<br>                if (next == null)<br>                    break;<br>                q.next = null; // unlink to help gc<br>                q = next;<br>            }<br>            break;<br>        }<br>    }</p><pre><code>done();callable = null;        // to reduce footprint</code></pre><p>}</p><p>2) FutureTask#get<br>public V get() throws InterruptedException, ExecutionException {<br>    int s = state;<br>    if (s &lt;= COMPLETING)<br>// 如果尚未执行完毕，则等待<br>        s = awaitDone(false, 0L);<br>    return report(s);<br>}</p><p>/**</p><ul><li>Simple linked list nodes to record waiting threads in a Treiber</li><li>stack.  See other classes such as Phaser and SynchronousQueue</li><li>for more detailed explanation.</li><li>/<br>static final class WaitNode {<br>  volatile Thread thread;<br>  volatile WaitNode next;<br>  WaitNode() { thread = Thread.currentThread(); }<br>}</li></ul><p>2.1) FutureTask#awaitDone（添加并阻塞Waiter）<br>private int awaitDone(boolean timed, long nanos)<br>    throws InterruptedException {<br>    final long deadline = timed ? System.nanoTime() + nanos : 0L;<br>    WaitNode q = null;<br>    boolean queued = false;<br>    for (;;) {<br>        if (Thread.interrupted()) {<br>            removeWaiter(q);<br>            throw new InterruptedException();<br>        }</p><pre><code>    int s = state;    if (s &gt; COMPLETING) {        if (q != null)            q.thread = null;        return s;    }    else if (s == COMPLETING) // cannot time out yet        Thread.yield();    else if (q == null)        q = new WaitNode();    else if (!queued)</code></pre><p>// 添加Waiter，以待被唤醒<br>            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,<br>                                                 q.next = waiters, q);<br>        else if (timed) {<br>            nanos = deadline - System.nanoTime();<br>            if (nanos &lt;= 0L) {<br>                removeWaiter(q);<br>                return state;<br>            }<br>            LockSupport.parkNanos(this, nanos);<br>        }<br>        else<br>            LockSupport.park(this);<br>    }<br>}</p><p>2.2) FutureTask#report（抛出执行时的异常）<br>private V report(int s) throws ExecutionException {<br>    Object x = outcome;<br>    if (s == NORMAL)<br>        return (V)x;<br>    if (s &gt;= CANCELLED)<br>        throw new CancellationException();<br>    throw new ExecutionException((Throwable)x);<br>}</p><p>3) FutureTask#cancel（实际上还是中断线程）<br>public boolean cancel(boolean mayInterruptIfRunning) {<br>    if (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        return false;<br>    try {    // in case call to interrupt throws exception<br>        if (mayInterruptIfRunning) {<br>            try {<br>                Thread t = runner;<br>                if (t != null)<br>                    t.interrupt();<br>            } finally { // final state<br>                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);<br>            }<br>        }<br>    } finally {<br>        finishCompletion();<br>    }<br>    return true;<br>}</p><p>关闭线程池<br>shutdown方法会遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。<br>shutdownNow方法会首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有在执行任务的线程。<br>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都关闭后，才表示线程池关闭成功，这时调用isTerminated方法会返回true。<br>shutdown</p><p>public void shutdown() {<br>    final ReentrantLock mainLock = this.mainLock;<br>    mainLock.lock();<br>    try {<br>// 判断是否可以操作目标线程<br>        checkShutdownAccess();<br>// 设置线程池状态为SHUTDOWN，以后线程池不会执行新的任务<br>        advanceRunState(SHUTDOWN);<br>// 中断所有的空闲线程<br>        interruptIdleWorkers();<br>        onShutdown(); // hook for ScheduledThreadPoolExecutor<br>    } finally {<br>        mainLock.unlock();<br>    }<br>// 转到Terminate<br>    tryTerminate();<br>}</p><p>1) interruptIdleWorkers<br>private void interruptIdleWorkers() {<br>    interruptIdleWorkers(false);<br>}<br>中断worker，但是中断之前需要先获取锁，这就意味着正在运行的Worker不能中断。但是上面的代码有w.tryLock()，那么获取不到锁就不会中断，shutdown的Interrupt只是对所有的空闲Worker（正在从workQueue中取Task，此时Worker没有加锁）发送中断信号。<br>private void interruptIdleWorkers(boolean onlyOne) {<br>    final ReentrantLock mainLock = this.mainLock;<br>    mainLock.lock();<br>    try {<br>        for (Worker w : workers) {<br>            Thread t = w.thread;<br>            if (!t.isInterrupted() &amp;&amp; w.tryLock()) {<br>//tryLock能获取到的Worker都是空闲的Worker，因为Worker在执行任务时是要拿到Worker的Lock的<br>                try {<br>// 让阻塞在工作队列中的Worker中断<br>                    t.interrupt();<br>                } catch (SecurityException ignore) {<br>                } finally {<br>                    w.unlock();<br>                }<br>            }<br>            if (onlyOne)<br>                break;<br>        }<br>    } finally {<br>        mainLock.unlock();<br>    }<br>}</p><p>shutdownNow<br>public List<Runnable> shutdownNow() {<br>    List<Runnable> tasks;<br>    final ReentrantLock mainLock = this.mainLock;<br>    mainLock.lock();<br>    try {<br>        checkShutdownAccess();<br>        advanceRunState(STOP);<br>        interruptWorkers();<br>// 工作队列中没有执行的任务全部抛弃<br>        tasks = drainQueue();<br>    } finally {<br>        mainLock.unlock();<br>    }<br>    tryTerminate();<br>    return tasks;<br>}</p><p>1) interruptWorkers<br>private void interruptWorkers() {<br>    final ReentrantLock mainLock = this.mainLock;<br>    mainLock.lock();<br>    try {<br>        for (Worker w : workers)<br>            w.interruptIfStarted();<br>    } finally {<br>        mainLock.unlock();<br>    }<br>}</p><p>Worker#interruptIfStarted<br>void interruptIfStarted() {<br>    Thread t;<br>    if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {<br>        try {<br>            t.interrupt();<br>        } catch (SecurityException ignore) {<br>        }<br>    }<br>}</p><p>1.1) drainQueue<br>*/<br>private List<Runnable> drainQueue() {<br>    BlockingQueue<Runnable> q = workQueue;<br>    ArrayList<Runnable> taskList = new ArrayList<Runnable>();<br>    q.drainTo(taskList);<br>    if (!q.isEmpty()) {<br>        for (Runnable r : q.toArray(new Runnable[0])) {<br>            if (q.remove(r))<br>                taskList.add(r);<br>        }<br>    }<br>    return taskList;<br>}</p><p>1.2) tryTerminate（两种关闭都会调用）TIDYING和TERMINATED的转化<br>有几种状态是不能转化到TIDYING（整理中）的:<br>RUNNING状态<br>TIDYING或TERMINATED<br>SHUTDOWN状态，但是workQueue不为空</p><p>也说明了两点：</p><ol><li><p>SHUTDOWN想转化为TIDYING，需要workQueue为空，同时workerCount为0。</p></li><li><p>STOP转化为TIDYING，需要workerCount为0<br>如果满足上面的条件（一般一定时间后都会满足的），那么CAS成TIDYING，TIDYING也只是个过渡状态，最终会转化为TERMINATED。<br>final void tryTerminate() {<br> for (;;) {</p><pre><code> int c = ctl.get(); if (isRunning(c) ||     runStateAtLeast(c, TIDYING) ||     (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))     return; if (workerCountOf(c) != 0) { // Eligible to terminate     interruptIdleWorkers(ONLY_ONE);     return; } final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try {     if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {         try {             terminated();         } finally {             ctl.set(ctlOf(TERMINATED, 0));             termination.signalAll();         }         return;     } } finally {     mainLock.unlock(); } // else retry on failed CAS</code></pre><p> }<br>}</p></li></ol><p>ScheduledThreadPoolExecutor（继承ThreadPoolExecutor）<br>与ThreadPoolExecutor的区别：<br>1）使用DelayedWorkQueue作为任务队列<br>2）获取任务的方式不同<br>3）执行周期任务后，增加了额外的处理<br>成员变量<br>/**</p><ul><li>False if should cancel/suppress periodic tasks on shutdown.</li><li>/<br>private volatile boolean continueExistingPeriodicTasksAfterShutdown;</li></ul><p>/**</p><ul><li>False if should cancel non-periodic tasks on shutdown.</li><li>/<br>private volatile boolean executeExistingDelayedTasksAfterShutdown = true;</li></ul><p>/**</p><ul><li>True if ScheduledFutureTask.cancel should remove from queue</li><li>/<br>private volatile boolean removeOnCancel = false;</li></ul><p>/**</p><ul><li>Sequence number to break scheduling ties, and in turn to</li><li>guarantee FIFO order among tied entries.</li><li>/<br>private static final AtomicLong sequencer = new AtomicLong();</li></ul><p>构造方法<br>/**</p><ul><li>Creates a new {@code ScheduledThreadPoolExecutor} with the</li><li>given core pool size.</li><li></li><li>@param corePoolSize the number of threads to keep in the pool, even</li><li>if they are idle, unless {@code allowCoreThreadTimeOut} is set</li><li>@throws IllegalArgumentException if {@code corePoolSize &lt; 0}</li><li>/<br>public ScheduledThreadPoolExecutor(int corePoolSize) {<br>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<pre><code>    new DelayedWorkQueue());</code></pre>}</li></ul><p>/**</p><ul><li>Creates a new {@code ScheduledThreadPoolExecutor} with the</li><li>given initial parameters.</li><li></li><li>@param corePoolSize the number of threads to keep in the pool, even</li><li>if they are idle, unless {@code allowCoreThreadTimeOut} is set</li><li>@param threadFactory the factory to use when the executor</li><li>creates a new thread</li><li>@throws IllegalArgumentException if {@code corePoolSize &lt; 0}</li><li>@throws NullPointerException if {@code threadFactory} is null</li><li>/<br>public ScheduledThreadPoolExecutor(int corePoolSize,<pre><code>                             ThreadFactory threadFactory) {</code></pre>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<pre><code>    new DelayedWorkQueue(), threadFactory);</code></pre>}</li></ul><p>/**</p><ul><li>Creates a new ScheduledThreadPoolExecutor with the given</li><li>initial parameters.</li><li></li><li>@param corePoolSize the number of threads to keep in the pool, even</li><li>if they are idle, unless {@code allowCoreThreadTimeOut} is set</li><li>@param handler the handler to use when execution is blocked</li><li>because the thread bounds and queue capacities are reached</li><li>@throws IllegalArgumentException if {@code corePoolSize &lt; 0}</li><li>@throws NullPointerException if {@code handler} is null</li><li>/<br>public ScheduledThreadPoolExecutor(int corePoolSize,<pre><code>                             RejectedExecutionHandler handler) {</code></pre>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<pre><code>    new DelayedWorkQueue(), handler);</code></pre>}</li></ul><p>/**</p><ul><li>Creates a new ScheduledThreadPoolExecutor with the given</li><li>initial parameters.</li><li></li><li>@param corePoolSize the number of threads to keep in the pool, even</li><li>if they are idle, unless {@code allowCoreThreadTimeOut} is set</li><li>@param threadFactory the factory to use when the executor</li><li>creates a new thread</li><li>@param handler the handler to use when execution is blocked</li><li>because the thread bounds and queue capacities are reached</li><li>@throws IllegalArgumentException if {@code corePoolSize &lt; 0}</li><li>@throws NullPointerException if {@code threadFactory} or</li><li>{@code handler} is null</li><li>/<br>public ScheduledThreadPoolExecutor(int corePoolSize,<pre><code>                             ThreadFactory threadFactory,                             RejectedExecutionHandler handler) {</code></pre>  super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,<pre><code>    new DelayedWorkQueue(), threadFactory, handler);</code></pre>}</li></ul><p>DelayedWorkQueue（底层是堆，无界阻塞队列，存放RunnableScheduledFuture）<br>static class DelayedWorkQueue extends AbstractQueue<Runnable><br>    implements BlockingQueue<Runnable> {}</p><p>put<br>public void put(Runnable e) {<br>    offer(e);<br>}</p><p>public boolean offer(Runnable x) {<br>    if (x == null)<br>        throw new NullPointerException();<br>    RunnableScheduledFuture<?> e = (RunnableScheduledFuture<?>)x;<br>    final ReentrantLock lock = this.lock;<br>    lock.lock();<br>    try {<br>        int i = size;<br>        if (i &gt;= queue.length)<br>            grow();<br>        size = i + 1;<br>        if (i == 0) {<br>            queue[0] = e;<br>            setIndex(e, 0);<br>        } else {<br>            siftUp(i, e);<br>        }<br>        if (queue[0] == e) {<br>            leader = null;<br>            available.signal();<br>        }<br>    } finally {<br>        lock.unlock();<br>    }<br>    return true;<br>}</p><p>private void siftUp(int k, RunnableScheduledFuture<?> key) {    while (k > 0) {        int parent = (k - 1) >>> 1;        RunnableScheduledFuture<?> e = queue[parent];<br>        if (key.compareTo(e) &gt;= 0)<br>            break;<br>        queue[k] = e;<br>        setIndex(e, k);<br>        k = parent;<br>    }<br>    queue[k] = key;<br>    setIndex(key, k);<br>}</p><p>ScheduledFutureTask是RunnableScheduledFuture的唯一实现类，它实现了Comparable接口。先按照time（下一次运行的时间）比较，然后按seq比较，最后按delay比较。<br>public int compareTo(Delayed other) {<br>    if (other == this) // compare zero if same object<br>        return 0;<br>    if (other instanceof ScheduledFutureTask) {<br>        ScheduledFutureTask<?> x = (ScheduledFutureTask<?>)other;<br>        long diff = time - x.time;<br>        if (diff &lt; 0)<br>            return -1;<br>        else if (diff &gt; 0)<br>            return 1;<br>        else if (sequenceNumber &lt; x.sequenceNumber)<br>            return -1;<br>        else<br>            return 1;<br>    }<br>    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);<br>    return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;<br>}</p><p>take（阻塞获取）<br>public RunnableScheduledFuture<?> take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        for (;;) {            RunnableScheduledFuture<?> first = queue[0];<br>            if (first == null)<br>// 队列为空，则阻塞<br>                available.await();<br>            else {<br>                long delay = first.getDelay(NANOSECONDS);<br>// 已经过期，则移除<br>                if (delay &lt;= 0)<br>                    return finishPoll(first);<br>                first = null; // don’t retain ref while waiting<br>                if (leader != null)<br>                    available.await();<br>                else {<br>                    Thread thisThread = Thread.currentThread();<br>                    leader = thisThread;<br>                    try {<br>// 未过期，则等待相应时间<br>                        available.awaitNanos(delay);<br>                    } finally {<br>                        if (leader == thisThread)<br>                            leader = null;<br>                    }<br>                }<br>            }<br>        }<br>    } finally {<br>        if (leader == null &amp;&amp; queue[0] != null)<br>            available.signal();<br>        lock.unlock();<br>    }<br>}</p><p>定期执行任务<br>执行主要分为两大部分：<br>1）当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或<br>scheduleAtFixedDelay()方法时，会向DelayedWorkQueue添加一个实现了RunnableScheduledFuture接口的ScheduledFutureTask。<br>2）线程池中的线程从DelayedWorkQueue中获取ScheduledFutureTask，然后执行任务。</p><p>scheduleAtFixedRate（Runnable包装为ScheduledFutureTask）<br>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                              long initialDelay,<br>                                              long period,<br>                                              TimeUnit unit) {<br>    if (command == null || unit == null)<br>        throw new NullPointerException();<br>    if (period &lt;= 0)<br>        throw new IllegalArgumentException();<br>// 将Runnable包装成ScheduledFutureTask，它实现了RunnableScheduledFuture接口<br>    ScheduledFutureTask<Void> sft =<br>        new ScheduledFutureTask<Void>(command,<br>                                      null,<br>                                      triggerTime(initialDelay, unit),<br>                                      unit.toNanos(period));<br>    RunnableScheduledFuture<Void> t = decorateTask(command, sft);<br>    sft.outerTask = t;<br>    delayedExecute(t);<br>    return t;<br>}</p><p>1) ScheduledFutureTask<br>private class ScheduledFutureTask<V><br>        extends FutureTask<V> implements RunnableScheduledFuture<V> {}<br>成员变量<br>/<em>* Sequence number to break ties FIFO </em>/<br>private final long sequenceNumber;</p><p>/<em>* The time the task is enabled to execute in nanoTime units </em>/<br>private long time;</p><p>/**</p><ul><li>Period in nanoseconds for repeating tasks.  A positive</li><li>value indicates fixed-rate execution.  A negative value</li><li>indicates fixed-delay execution.  A value of 0 indicates a</li><li>non-repeating task.</li><li>/<br>private final long period;</li></ul><p>/<em>* The actual task to be re-enqueued by reExecutePeriodic </em>/<br>RunnableScheduledFuture<V> outerTask = this;</p><p>/**</p><ul><li>Index into delay queue, to support faster cancellation.</li><li>/<br>int heapIndex;<br>构造方法<br>ScheduledFutureTask(Runnable r, V result, long ns, long period) {<br>  super(r, result);<br>  this.time = ns;<br>  this.period = period;<br>  this.sequenceNumber = sequencer.getAndIncrement();<br>}</li></ul><p>public FutureTask(Runnable runnable, V result) {<br>    this.callable = Executors.callable(runnable, result);<br>    this.state = NEW;       // ensure visibility of callable<br>}</p><p>public static <T> Callable<T> callable(Runnable task, T result) {<br>    if (task == null)<br>        throw new NullPointerException();<br>    return new RunnableAdapter<T>(task, result);<br>}</p><p>static final class RunnableAdapter<T> implements Callable<T> {<br>    final Runnable task;<br>    final T result;<br>    RunnableAdapter(Runnable task, T result) {<br>        this.task = task;<br>        this.result = result;<br>    }<br>    public T call() {<br>        task.run();<br>        return result;<br>    }<br>}</p><p>2) delayedExecute（入队）<br>private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) {<br>    if (isShutdown())<br>        reject(task);<br>    else {<br>// 加入到任务队列中<br>        super.getQueue().add(task);<br>        if (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(false);<br>        else<br>// 确保至少一个线程在处理任务，即使核心线程数corePoolSize为0<br>            ensurePrestart();<br>    }<br>}<br>2.1) ensurePrestart（添加工作线程直至corePoolSize）<br>void ensurePrestart() {<br>    int wc = workerCountOf(ctl.get());<br>    if (wc &lt; corePoolSize)<br>        addWorker(null, true);<br>    else if (wc == 0)<br>        addWorker(null, false);<br>}</p><p>3) ScheduledFutureTask#run<br>public void run() {<br>// 判断是不是定时周期调度的<br>    boolean periodic = isPeriodic();<br>    if (!canRunInCurrentRunState(periodic))<br>        cancel(false);<br>    else if (!periodic)<br>//调用FutureTask的run方法<br>        ScheduledFutureTask.super.run();<br>    else if (ScheduledFutureTask.super.runAndReset()) {<br>//计算下一次执行时间<br>        setNextRunTime();<br>// 重新入队<br>        reExecutePeriodic(outerTask);<br>    }<br>}</p><p>private void setNextRunTime() {<br>    long p = period;<br>    if (p &gt; 0)<br>        time += p;<br>    else<br>        time = triggerTime(-p);<br>}</p><p>void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) {<br>    if (canRunInCurrentRunState(true)) {<br>        super.getQueue().add(task);<br>        if (!canRunInCurrentRunState(true) &amp;&amp; remove(task))<br>            task.cancel(false);<br>        else<br>            ensurePrestart();<br>    }<br>}</p><p>练习题<br>生产者消费者几种实现方式</p><p>wait&amp;notify<br>public class TestProducerConsumer {<br>    public static void main(String[] args) {<br>        SyncStack ss = new SyncStack();<br>        Producer p = new Producer(ss);<br>        Consumer c = new Consumer(ss);<br>        new Thread(p, “A”).start();<br>        new Thread(p, “B”).start();<br>        new Thread(c).start();<br>    }<br>}</p><p>class Food {<br>    private String id;</p><pre><code>public Food(String id) {    this.id = id;}public String toString() {    return &quot;产品&quot; + id;}</code></pre><p>}</p><p>class SyncStack {<br>    private int index = 0;<br>    private Food[] foods = new Food[6];</p><pre><code>public SyncStack() {}public synchronized void push(Food f) {    while (index == foods.length) {        try {            System.out.println(&quot;容器已满&quot;);            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    foods[index] = f;    index++;    this.notifyAll();}public synchronized Food pop() {    while (index == 0) {        try {            System.out.println(&quot;容器已空&quot;);            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    index--;    this.notifyAll();    return foods[index];}</code></pre><p>}</p><p>class Producer implements Runnable {<br>    private SyncStack ss;</p><pre><code>public Producer(SyncStack ss) {    this.ss = ss;}public void run() {    for (int i = 0; i &lt; 10; i++) {        Food f = new Food(Thread.currentThread().getName() + i);        ss.push(f);        System.out.println(&quot;生产者&quot;+Thread.currentThread().getName() + &quot;生产了 &quot; + f);        try {            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>class Consumer implements Runnable {<br>    private SyncStack ss;</p><pre><code>public Consumer(SyncStack ss) {    this.ss = ss;}public void run() {    for (int i = 0; i &lt; 20; i++) {        Food f = ss.pop();        System.out.println(&quot;消费了 &quot; + f);        try {            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>Lock&amp;Condition<br>public class TestProducerConsumer {<br>    public static void main(String[] args) {<br>        SyncStack ss = new SyncStack();<br>Producer p = new Producer(ss);<br>Consumer c = new Consumer(ss);<br>        new Thread(p, “A”).start();<br>        new Thread(p, “B”).start();<br>        new Thread(c, “C”).start();<br>        new Thread(c, “D”).start();<br>    }<br>}</p><p>class Food {<br>    private String id;</p><pre><code>public Food(String id) {    this.id = id;}public String toString() {    return &quot;产品&quot; + id;}</code></pre><p>}</p><p>class SyncStack {<br>    private int index = 0;<br>    private Food[] foods = new Food[6];<br>    private Lock lock = new ReentrantLock();<br>    private Condition condition = lock.newCondition();</p><pre><code>public SyncStack() {}public void push(Food f) {    lock.lock();    try {        while (index == foods.length) {            try {                System.out.println(&quot;容器已满&quot;);                condition.await();                //相当于this.wait()            } catch (InterruptedException e) {                e.printStackTrace();            }        }        foods[index] = f;        index++;        condition.signalAll();        //相当于this.notifyAll()    } finally {        lock.unlock();    }}public Food pop() {    lock.lock();    try {        while (index == 0) {            try {                System.out.println(&quot;容器已空&quot;);                condition.await();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        index--;        condition.signalAll();    } finally {        lock.unlock();    }    return foods[index];}</code></pre><p>}</p><p>class Producer implements Runnable {<br>    private SyncStack ss;</p><pre><code>public Producer(SyncStack ss) {    this.ss = ss;}public void run() {    for (int i = 0; i &lt; 10; i++) {        Food f = new Food(Thread.currentThread().getName() + i);        ss.push(f);        System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;生产了 &quot; + f);        try {            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>class Consumer implements Runnable {<br>    private SyncStack ss;</p><pre><code>public Consumer(SyncStack ss) {    this.ss = ss;}public void run() {    for (int i = 0; i &lt; 10; i++) {        Food f = ss.pop();        System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;消费了 &quot; + f);        try {            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>BlockingQueue<br>public class TestProducerConsumer {<br>    public static void main(String[] args) {<br>        BlockingQueue<Food> queue = new ArrayBlockingQueue<Food>(6);<br>Producer p = new Producer(queue);<br>Consumer c = new Consumer(queue);<br>        new Thread(p, “A”).start();<br>        new Thread(p, “B”).start();<br>        new Thread(c, “C”).start();<br>        new Thread(c, “D”).start();<br>    }<br>}</p><p>class Food {<br>    private String id;</p><pre><code>public Food(String id) {    this.id = id;}public String toString() {    return &quot;产品&quot; + id;}</code></pre><p>}</p><p>class Producer implements Runnable {<br>    private BlockingQueue<Food> foods;</p><pre><code>public Producer(BlockingQueue&lt;Food&gt; foods) {    this.foods = foods;}public void run() {    for (int i = 0; i &lt; 10; i++) {        Food f = new Food(Thread.currentThread().getName() + i);        try {            foods.put(f);            System.out.println(&quot;生产者&quot; + Thread.currentThread().getName() + &quot;生产了 &quot; + f);            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>class Consumer implements Runnable {</p><pre><code>private BlockingQueue&lt;Food&gt; foods;public Consumer(BlockingQueue&lt;Food&gt; foods) {    this.foods = foods;}public void run() {    for (int i = 0; i &lt; 10; i++) {        try {            Food f = foods.take();            System.out.println(&quot;消费者&quot; + Thread.currentThread().getName() + &quot;消费了 &quot; + f);            Thread.sleep((int) (Math.random() * 1000));        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>}</p><p>线程按序交替执行<br>设置3个线程，线程名分别为123，按照123的顺序打印，重复20遍。<br>public class TestAlternate {<br>    public static void main(String[] args) {<br>        int threadNum = 3;<br>        int loopTimes = 20;<br>        AlternativeDemo atomicDemo = new AlternativeDemo(threadNum, loopTimes);<br>        for (int i = 1; i &lt;= threadNum; ++i) {<br>            new Thread(atomicDemo, String.valueOf(i)).start();<br>        }<br>    }<br>    // 所有线程共享lock和conditions<br>    private static class AlternativeDemo implements Runnable {<br>        private int nextThread = 1;<br>        private Lock lock = new ReentrantLock();<br>        private Condition[] conditions;<br>        private int totalTimes;</p><pre><code>    public AlternativeDemo(int threadNum, int totalTimes) {        this.totalTimes = totalTimes;        this.conditions = new Condition[threadNum];        for (int i = 0; i &lt; threadNum; ++i) {            conditions[i] = lock.newCondition();        }    }    public void run() {        for (int i = 1; i &lt;= totalTimes; ++i) {            lock.lock();            // currentThread 取值为1,2,3             // currentThread-1为当前线程对应的Condition            int currentThread = Thread.currentThread().getName().charAt(0) - &#39;0&#39;;            try {</code></pre><p>// 下一个不是自己，则等待<br>                    if (currentThread != nextThread) {<br>                        conditions[currentThread - 1].await();<br>                    }<br>                    System.out.println(“线程” + currentThread + “:” + currentThread);<br>// 计算下一个要打印的线程<br>                    // 3 % 3 + 1 = 1  线程3后面的是线程1<br>                    nextThread = nextThread % conditions.length + 1;<br>// 唤醒下一个要打印的线程<br>                    conditions[nextThread - 1].signal();<br>                } catch (InterruptedException e) {<br>                    e.printStackTrace();<br>                } finally {<br>                    lock.unlock();<br>                }<br>            }<br>        }<br>    }<br>}</p><p>线程同步的基本使用习题<br>public class Test8Questions {</p><pre><code>public static void main(String[] args) {    Number number = new Number();    Number number2 = new Number();    new Thread(new Runnable() {        @Override        public void run() {            number.getOne();        }     }).start();    new Thread(new Runnable() {        @Override        public void run() {</code></pre><p>//                number.getTwo();<br>                number2.getTwo();<br>            }<br>        }).start();</p><pre><code>    /*new Thread(new Runnable() {        @Override        public void run() {            number.getThree();        }    }).start();*/}</code></pre><p>}</p><p>class Number{</p><pre><code>public static synchronized void getOne(){//Number.class    try {        Thread.sleep(3000);    } catch (InterruptedException e) {    }    System.out.println(&quot;one&quot;);}public synchronized void getTwo(){//this    System.out.println(&quot;two&quot;);}public void getThree(){    System.out.println(&quot;three&quot;);}</code></pre><p>}</p><p>1、持有同一个Number对象，并都加了锁，按调用顺序打印<br>2、sleep方法不会释放锁<br>3、普通方法不需要锁定对象，直接调用，最先调用<br>4、两个Number对象，实际上并没有并发访问资源<br>5、静态同步方法锁定的是类的Class对象，非静态同步方法锁定的是类的实例，同4，没有并发访问资源<br>6、两个方法均为静态同步方法，此时构成并发访问，因为它们锁定的是类的同一个Class对象<br>7、同4，没有并发访问资源<br>8、同6，虽然是不同实例，但对应着同一个Class对象</p><p>直击灵魂的Interrupt七问<br>1.Thread.interrupt()方法和InterruptedException异常的关系？是由interrupt触发产生了InterruptedException异常？<br>2.Thread.interrupt()会中断线程什么状态的工作？ RUNNING or BLOCKING？<br>3.一般Thread编程需要关注interrupt中断不？一般怎么处理？可以用来做什么？<br>4.LockSupport.park()和unpark()，与object.wait()和notify()的区别？<br>5.LockSupport.park(Object blocker)传递的blocker对象做什么用？<br>6.LockSupport能响应Thread.interrupt()事件不？会抛出InterruptedException异常？<br>7.Thread.interrupt()处理是否有对应的回调函数？类似于钩子调用？</p><ol><li><p>Thread.interrupt()只是在Object.wait() .Object.join(), Object.sleep()几个方法会主动抛出InterruptedException异常。而在其他的block场景，只是通过设置了Thread的一个标志位信息，需要程序自己进行处理。<br>在J.U.C里面的ReentrantLock、Condition等源码都是自己去检测中断标志位，然后抛出InterruptedException。<br>if (Thread.interrupted())  // Clears interrupted status!<br>throw new InterruptedException();  </p></li><li><p>Thread.interrupt设计的目的主要是用于处理线程处于block状态，比如wait(),sleep()状态就是个例子。但可以在程序设计时为支持task cancel，同样可以支持RUNNING状态。比如Object.join()和一些支持interrupt的一些nio channel设计。</p></li><li><p>interrupt用途： unBlock操作，支持任务cancel， 数据清理等。</p></li><li><p>1)  面向的主体不一样。LockSuport主要是针对Thread进进行阻塞处理，可以指定阻塞队列的目标对象，每次可以指定具体的线程唤醒。Object.wait()是以对象为纬度，阻塞当前的线程和唤醒单个(随机)或者所有线程。<br>2)  实现机制不同。虽然LockSuport可以指定monitor的object对象，但和object.wait()，两者的阻塞队列并不交叉。可以看下测试例子。object.notifyAll()不能唤醒LockSupport的阻塞Thread.</p></li><li><p>对应的blcoker会记录在Thread的一个parkBlocker属性中,通过jstack命令可以非常方便的监控具体的阻塞对象.</p></li><li><p>能响应interrupt事件，但不会抛出InterruptedException异常</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化看这一篇就够了</title>
      <link href="//post/MySQL%E4%BC%98%E5%8C%96%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html"/>
      <url>//post/MySQL%E4%BC%98%E5%8C%96%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文概要"><a href="#本文概要" class="headerlink" title="本文概要"></a>本文概要</h1><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-30/53535419.jpg" alt=""></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h2><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><ul><li>设计数据库时：数据库表、字段的设计，存储引擎</li><li>利用好MySQL自身提供的功能，如索引等</li><li>横向扩展：MySQL集群、负载均衡、读写分离</li><li>SQL语句的优化（收效甚微）</li></ul><h1 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h1><blockquote><p>字段类型的选择，设计规范，范式，常见设计案例</p></blockquote><h2 id="原则：尽量使用整型表示字符串"><a href="#原则：尽量使用整型表示字符串" class="headerlink" title="原则：尽量使用整型表示字符串"></a>原则：尽量使用整型表示字符串</h2><h3 id="存储IP"><a href="#存储IP" class="headerlink" title="存储IP"></a>存储IP</h3><p><code>INET_ATON(str)</code>，address to number</p><p><code>INET_NTOA(number)</code>，number to address</p><h3 id="MySQL内部的枚举类型（单选）和集合（多选）类型"><a href="#MySQL内部的枚举类型（单选）和集合（多选）类型" class="headerlink" title="MySQL内部的枚举类型（单选）和集合（多选）类型"></a>MySQL内部的枚举类型（单选）和集合（多选）类型</h3><p>但是因为维护成本较高因此不常使用，使用<strong>关联表</strong>的方式来替代<code>enum</code>    </p><h2 id="原则：定长和非定长数据类型的选择"><a href="#原则：定长和非定长数据类型的选择" class="headerlink" title="原则：定长和非定长数据类型的选择"></a>原则：定长和非定长数据类型的选择</h2><blockquote><p>decimal不会损失精度，存储空间会随数据的增大而增大。double占用固定空间，较大数的存储会损失精度。非定长的还有varchar、text</p></blockquote><h3 id="金额"><a href="#金额" class="headerlink" title="金额"></a>金额</h3><blockquote><p>对数据的精度要求较高，小数的运算和存储存在精度问题（不能将所有小数转换成二进制）</p></blockquote><h3 id="定点数decimal"><a href="#定点数decimal" class="headerlink" title="定点数decimal"></a>定点数decimal</h3><p><code>price decimal(8,2)</code>有2位小数的定点数，定点数支持很大的数（甚至是超过<code>int,bigint</code>存储范围的数）</p><h3 id="小单位大数额避免出现小数"><a href="#小单位大数额避免出现小数" class="headerlink" title="小单位大数额避免出现小数"></a>小单位大数额避免出现小数</h3><p>元-&gt;分</p><h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>定长<code>char</code>，非定长<code>varchar、text</code>（上限65535，其中<code>varchar</code>还会消耗1-3字节记录长度，而<code>text</code>使用额外空间记录长度）</p><h2 id="原则：尽可能选择小的数据类型和指定短的长度"><a href="#原则：尽可能选择小的数据类型和指定短的长度" class="headerlink" title="原则：尽可能选择小的数据类型和指定短的长度"></a>原则：尽可能选择小的数据类型和指定短的长度</h2><h2 id="原则：尽可能使用-not-null"><a href="#原则：尽可能使用-not-null" class="headerlink" title="原则：尽可能使用 not null"></a>原则：尽可能使用 not null</h2><p>非<code>null</code>字段的处理要比<code>null</code>字段的处理高效些！且不需要判断是否为<code>null</code>。</p><p><code>null</code>在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如<code>select null = null</code>和<code>select null &lt;&gt; null</code>（<code>&lt;&gt;</code>为不等号）有着同样的结果，只能通过<code>is null</code>和<code>is not null</code>来判断字段是否为<code>null</code>。</p><p>如何存储？MySQL中每条记录都需要额外的存储空间，表示每个字段是否为<code>null</code>。因此通常使用特殊的数据进行占位，比如<code>int not null default 0</code>、<code>string not null default ‘’</code></p><h2 id="原则：字段注释要完整，见名知意"><a href="#原则：字段注释要完整，见名知意" class="headerlink" title="原则：字段注释要完整，见名知意"></a>原则：字段注释要完整，见名知意</h2><h2 id="原则：单表字段不宜过多"><a href="#原则：单表字段不宜过多" class="headerlink" title="原则：单表字段不宜过多"></a>原则：单表字段不宜过多</h2><p>二三十个就极限了</p><h2 id="原则：可以预留字段"><a href="#原则：可以预留字段" class="headerlink" title="原则：可以预留字段"></a>原则：可以预留字段</h2><blockquote><p>在使用以上原则之前首先要满足业务需求</p></blockquote><h1 id="关联表的设计"><a href="#关联表的设计" class="headerlink" title="关联表的设计"></a>关联表的设计</h1><blockquote><p>外键<code>foreign key</code>只能实现一对一或一对多的映射</p></blockquote><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>使用外键</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>单独新建一张表将多对多拆分成两个一对多</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>如商品的基本信息（<code>item</code>）和商品的详细信息（<code>item_intro</code>），通常使用相同的主键或者增加一个外键字段（<code>item_id</code>）</p><h1 id="范式-Normal-Format"><a href="#范式-Normal-Format" class="headerlink" title="范式 Normal Format"></a>范式 Normal Format</h1><blockquote><p>数据表的设计规范，一套越来越严格的规范体系（如果需要满足N范式，首先要满足N-1范式）。N</p></blockquote><h2 id="第一范式1NF：字段原子性"><a href="#第一范式1NF：字段原子性" class="headerlink" title="第一范式1NF：字段原子性"></a>第一范式1NF：字段原子性</h2><p>字段原子性，字段不可再分割。</p><blockquote><p>关系型数据库，默认满足第一范式</p></blockquote><p>注意比较容易出错的一点，在一对多的设计中使用逗号分隔多个外键，这种方法虽然存储方便，但不利于维护和索引（比如查找带标签<code>java</code>的文章）</p><h2 id="第二范式：消除对主键的部分依赖"><a href="#第二范式：消除对主键的部分依赖" class="headerlink" title="第二范式：消除对主键的部分依赖"></a>第二范式：消除对主键的部分依赖</h2><blockquote><p>即在表中加上一个与业务逻辑无关的字段作为主键</p></blockquote><p>主键：可以唯一标识记录的字段或者字段集合。</p><table><thead><tr><th>course_name</th><th>course_class</th><th>weekday（周几）</th><th>course_teacher</th></tr></thead><tbody><tr><td>MySQL</td><td>教育大楼1525</td><td>周一</td><td>张三</td></tr><tr><td>Java</td><td>教育大楼1521</td><td>周三</td><td>李四</td></tr><tr><td>MySQL</td><td>教育大楼1521</td><td>周五</td><td>张三</td></tr></tbody></table><p>依赖：A字段可以确定B字段，则B字段依赖A字段。比如知道了下一节课是数学课，就能确定任课老师是谁。于是<strong>周几</strong>和<strong>下一节课</strong>和就能构成复合主键，能够确定去哪个教室上课，任课老师是谁等。但我们常常增加一个<code>id</code>作为主键，而消除对主键的部分依赖。</p><p>对主键的部分依赖：某个字段依赖复合主键中的一部分。</p><p>解决方案：新增一个独立字段作为主键。</p><h2 id="第三范式：消除对主键的传递依赖"><a href="#第三范式：消除对主键的传递依赖" class="headerlink" title="第三范式：消除对主键的传递依赖"></a>第三范式：消除对主键的传递依赖</h2><p>传递依赖：B字段依赖于A，C字段又依赖于B。比如上例中，任课老师是谁取决于是什么课，是什么课又取决于主键<code>id</code>。因此需要将此表拆分为两张表日程表和课程表（独立数据独立建表）：</p><table><thead><tr><th>id</th><th>weekday</th><th>course_class</th><th>course_id</th></tr></thead><tbody><tr><td>1001</td><td>周一</td><td>教育大楼1521</td><td>3546</td></tr></tbody></table><table><thead><tr><th>course_id</th><th>course_name</th><th>course_teacher</th></tr></thead><tbody><tr><td>3546</td><td>Java</td><td>张三</td></tr></tbody></table><p>这样就减少了数据的冗余（即使周一至周日每天都有Java课，也只是<code>course_id:3546</code>出现了7次）</p><h1 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h1><blockquote><p>早期问题：如何选择MyISAM和Innodb？</p><p>现在不存在这个问题了，Innodb不断完善，从各个方面赶超MyISAM，也是MySQL默认使用的。</p></blockquote><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><h2 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h2><p><code>show engines</code></p><table><thead><tr><th>Engine</th><th>Support</th><th>Comment</th></tr></thead><tbody><tr><td>InnoDB</td><td>DEFAULT</td><td><strong>Supports transactions, row-level locking, and foreign keys</strong></td></tr><tr><td>MyISAM</td><td>YES</td><td><strong>MyISAM storage engine</strong></td></tr></tbody></table><h2 id="存储差异"><a href="#存储差异" class="headerlink" title="存储差异"></a>存储差异</h2><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>文件能否移动</td><td>能，一张表就对应<code>.frm</code>、<code>MYD</code>、<code>MYI</code>3个文件</td><td>否，因为关联的还有<code>data</code>下的其它文件</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>空间碎片（删除记录并<code>flush table 表名</code>之后，表文件大小不变）</td><td>产生。定时整理：使用命令<code>optimize table 表名</code>实现</td><td>不产生</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr></tbody></table><blockquote><p>锁扩展 </p><p>表级锁（<code>table-level lock</code>）：<code>lock tables &lt;table_name1&gt;,&lt;table_name2&gt;... read/write</code>，<code>unlock tables &lt;table_name1&gt;,&lt;table_name2&gt;...</code>。其中<code>read</code>是共享锁，一旦锁定任何客户端都不可读；<code>write</code>是独占/写锁，只有加锁的客户端可读可写，其他客户端既不可读也不可写。锁定的是一张表或几张表。</p><p>行级锁（<code>row-level lock</code>）：锁定的是一行或几行记录。共享锁：<code>select * from &lt;table_name&gt; where &lt;条件&gt; LOCK IN SHARE MODE;</code>，对查询的记录增加共享锁；<code>select * from &lt;table_name&gt; where &lt;条件&gt; FOR UPDATE;</code>，对查询的记录增加排他锁。这里<strong>值得注意</strong>的是：<code>innodb</code>的行锁，其实是一个子范围锁，依据条件锁定部分范围，而不是就映射到具体的行上，因此还有一个学名：间隙锁。比如<code>select * from stu where id &lt; 20 LOCK IN SHARE MODE</code>会锁定<code>id</code>在<code>20</code>左右以下的范围，你可能无法插入<code>id</code>为<code>18</code>或<code>22</code>的一条新纪录。</p></blockquote><h2 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h2><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键保证数据完整性。比如OA自动化办公系统。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote><p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p></blockquote><h2 id="索引检索为什么快？"><a href="#索引检索为什么快？" class="headerlink" title="索引检索为什么快？"></a>索引检索为什么快？</h2><ul><li>关键字相对于数据本身，==数据量小==</li><li>关键字是==有序==的，二分查找可快速确定位置</li></ul><p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p><h2 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h2><blockquote><p><strong>普通索引</strong>（<code>key</code>），<strong>唯一索引</strong>（<code>unique key</code>），<strong>主键索引</strong>（<code>primary key</code>），<strong>全文索引</strong>（<code>fulltext key</code>）</p></blockquote><p>三种索引的索引方式是一样的，只不过对索引的关键字有不同的限制：</p><ul><li>普通索引：对关键字没有限制</li><li>唯一索引：要求记录提供的关键字不能重复</li><li>主键索引：要求关键字唯一且不为null</li></ul><h2 id="索引管理语法"><a href="#索引管理语法" class="headerlink" title="索引管理语法"></a>索引管理语法</h2><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p><code>show create table 表名</code>：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/51457246.jpg" alt=""></p><p><code>desc 表名</code></p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/97005334.jpg" alt=""></p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表之后建立索引"><a href="#创建表之后建立索引" class="headerlink" title="创建表之后建立索引"></a>创建表之后建立索引</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">TABLE</span> user_index<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>    first_name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    last_name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    id_card <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    information <span class="token keyword">text</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 更改表结构</span><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index<span class="token comment" spellcheck="true">-- 创建一个first_name和last_name的复合索引，并命名为name</span><span class="token keyword">add</span> <span class="token keyword">key</span> name <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span>last_name<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">-- 创建一个id_card的唯一索引，默认以字段名作为索引名</span><span class="token keyword">add</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id_card<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">-- 鸡肋，全文索引不支持中文</span><span class="token keyword">add</span> FULLTEXT <span class="token keyword">KEY</span> <span class="token punctuation">(</span>information<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>show create table user_index</code>：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/87637544.jpg" alt=""></p><h4 id="创建表时指定索引"><a href="#创建表时指定索引" class="headerlink" title="创建表时指定索引"></a>创建表时指定索引</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> user_index2 <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token keyword">auto_increment</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    first_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    last_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    id_card <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    information <span class="token keyword">text</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> name <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">,</span>    FULLTEXT <span class="token keyword">KEY</span> <span class="token punctuation">(</span>information<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id_card<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> name<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> id_card<span class="token punctuation">;</span><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index <span class="token keyword">drop</span> <span class="token keyword">KEY</span> information<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/22392054.jpg" alt=""></p><p>需要取消自增长再行删除：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> user_index<span class="token comment" spellcheck="true">-- 重新定义字段</span><span class="token keyword">MODIFY</span> id <span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">drop</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h2 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h2><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> innodb1 <span class="token punctuation">(</span>    id <span class="token keyword">INT</span> <span class="token keyword">auto_increment</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    first_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    last_name <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    id_card <span class="token keyword">VARCHAR</span> <span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    information <span class="token keyword">text</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> name <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span> last_name<span class="token punctuation">)</span><span class="token punctuation">,</span>    FULLTEXT <span class="token keyword">KEY</span> <span class="token punctuation">(</span>information<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id_card<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">insert</span> <span class="token keyword">into</span> innodb1 <span class="token punctuation">(</span>first_name<span class="token punctuation">,</span>last_name<span class="token punctuation">,</span>id_card<span class="token punctuation">,</span>information<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'张'</span><span class="token punctuation">,</span><span class="token string">'三'</span><span class="token punctuation">,</span><span class="token string">'1001'</span><span class="token punctuation">,</span><span class="token string">'华山派'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过<code>explain selelct</code>来分析SQL语句执行前的执行计划：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/66167137.jpg" alt=""></p><p>由上图可看出此SQL语句是按照主键索引来检索的。</p><p>执行计划是：当执行SQL语句时，首先会分析、优化，形成执行计划，在按照执行计划执行。</p><h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/4492079.jpg" alt=""></p><p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 增加一个没有建立索引的字段</span><span class="token keyword">alter</span> <span class="token keyword">table</span> innodb1 <span class="token keyword">add</span> sex char<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 按sex检索时可选的索引为null</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb1 <span class="token keyword">where</span> sex<span class="token operator">=</span><span class="token string">'男'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/33916825.jpg" alt=""></p><blockquote><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p></blockquote><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote><p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p></blockquote><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后==只写必要的查询字段==，以增加索引覆盖的几率。</p><p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><h2 id="语法细节（要点）"><a href="#语法细节（要点）" class="headerlink" title="语法细节（要点）"></a>语法细节（要点）</h2><blockquote><p>在满足索引使用的场景下（<code>where/order by/join on</code>或索引覆盖），索引也不一定被使用</p></blockquote><h3 id="字段要独立出现"><a href="#字段要独立出现" class="headerlink" title="字段要独立出现"></a>字段要独立出现</h3><p>比如下面两条SQL语句在语义上相同，但是第一条会使用主键索引而第二条不会。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="like查询，不能以通配符开头"><a href="#like查询，不能以通配符开头" class="headerlink" title="like查询，不能以通配符开头"></a><code>like</code>查询，不能以通配符开头</h3><p>比如搜索标题包含<code>mysql</code>的文章：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> article <span class="token keyword">where</span> title <span class="token operator">like</span> <span class="token string">'%mysql%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种SQL的执行计划用不了索引（<code>like</code>语句匹配表达式以通配符开头），因此只能做全表扫描，效率极低，在实际工程中几乎不被采用。而一般会使用第三方提供的支持中文的全文索引来做。</p><p>但是 <strong>关键字查询</strong> 热搜提醒功能还是可以做的，比如键入<code>mysql</code>之后提醒<code>mysql 教程</code>、<code>mysql 下载</code>、<code>mysql 安装步骤</code>等。用到的语句是：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> article <span class="token keyword">where</span> title <span class="token operator">like</span> <span class="token string">'mysql%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种<code>like</code>是可以利用索引的（当然前提是<code>title</code>字段建立过索引）。</p><h3 id="复合索引只对第一个字段有效"><a href="#复合索引只对第一个字段有效" class="headerlink" title="复合索引只对第一个字段有效"></a>复合索引只对第一个字段有效</h3><p>建立复合索引：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> person <span class="token keyword">add</span> <span class="token keyword">index</span><span class="token punctuation">(</span>first_name<span class="token punctuation">,</span>last_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其原理就是将索引先按照从<code>first_name</code>中提取的关键字排序，如果无法确定先后再按照从<code>last_name</code>提取的关键字排序，也就是说该索引表只是按照记录的<code>first_name</code>字段值有序。</p><p>因此<code>select * from person where first_name = ?</code>是可以利用索引的，而<code>select * from person where last_name = ?</code>无法利用索引。  </p><blockquote><p>那么该复合索引的应用场景是什么？==组合查询==</p></blockquote><p>比如对于<code>select * person from first_name = ? and last_name = ?</code>，复合索引就比对<code>first_name</code>和<code>last_name</code>单独建立索引要高效些。很好理解，复合索引首先二分查找与<code>first_name = ?</code>匹配的记录，再在这些记录中二分查找与<code>last_name</code>匹配的记录，只涉及到一张索引表。而分别单独建立索引则是在<code>first_name</code>索引表中二分找出与<code>first_name = ?</code>匹配的记录，再在<code>last_name</code>索引表中二分找出与<code>last_name = ?</code>的记录，两者取交集。</p><h3 id="or，两边条件都有索引可用"><a href="#or，两边条件都有索引可用" class="headerlink" title="or，两边条件都有索引可用"></a>or，两边条件都有索引可用</h3><blockquote><p>一但有一边无索引可用就会导致整个SQL语句的全表扫描</p></blockquote><h3 id="状态值，不容易使用到索引"><a href="#状态值，不容易使用到索引" class="headerlink" title="状态值，不容易使用到索引"></a>状态值，不容易使用到索引</h3><p>如性别、支付状态等状态值字段往往只有极少的几种取值可能，这种字段即使建立索引，也往往利用不上。这是因为，一个状态值可能匹配大量的记录，这种情况MySQL会认为利用索引比全表扫描的效率低，从而弃用索引。索引是随机访问磁盘，而全表扫描是顺序访问磁盘，这就好比有一栋20层楼的写字楼，楼底下的索引牌上写着某个公司对应不相邻的几层楼，你去公司找人，与其按照索引牌的提示去其中一层楼没找到再下来看索引牌再上楼，不如从1楼挨个往上找到顶楼。</p><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><ul><li>建立基础索引：在<code>where、order by、join</code>字段上建立索引。</li><li>优化，组合索引：基于业务逻辑<ul><li>如果条件经常性出现在一起，那么可以考虑将多字段索引升级为==复合索引==</li><li>如果通过增加个别字段的索引，就可以出现==索引覆盖==，那么可以考虑为该字段建立索引</li><li>查询时，不常用到的索引，应该删除掉</li></ul></li></ul><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>==实操的难度==：在于前缀截取的长度。</p><p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p><h2 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h2><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p>btree（多路平衡查找树）是一种广泛应用于==磁盘上实现索引功能==的一种数据结构，也是大多数数据库索引表的实现。</p><p>以<code>add index(first_name,last_name)</code>为例：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/14728955.jpg" alt=""></p><p>BTree的一个node可以存储多个关键字，node的大小取决于计算机的文件系统，因此我们可以通过减小索引字段的长度使结点存储更多的关键字。如果node中的关键字已满，那么可以通过每个关键字之间的子节点指针来拓展索引表，但是不能破坏结构的有序性，比如按照<code>first_name</code>第一有序、<code>last_name</code>第二有序的规则，新添加的<code>韩香</code>就可以插到<code>韩康</code>之后。<code>白起 &lt; 韩飞 &lt; 韩康 &lt; 李世民 &lt; 赵奢 &lt; 李寻欢 &lt; 王语嫣 &lt; 杨不悔</code>。这与二叉搜索树的思想是一样的，只不过二叉搜索树的查找效率是<code>log(2,N)</code>（以2为底N的对数），而BTree的查找效率是<code>log(x,N)</code>（其中x为node的关键字数量，可以达到1000以上）。</p><p>从<code>log(1000+,N)</code>可以看出，少量的磁盘读取即可做到大量数据的遍历，这也是btree的设计目的。</p><h3 id="B-Tree聚簇结构"><a href="#B-Tree聚簇结构" class="headerlink" title="B+Tree聚簇结构"></a>B+Tree聚簇结构</h3><p>聚簇结构（也是在BTree上升级改造的）中，关键字和记录是存放在一起的。</p><p>在MySQL中，仅仅只有<code>Innodb</code>的==主键索引为聚簇结构==，其它的索引包括<code>Innodb</code>的非主键索引都是典型的BTree结构。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>在索引被载入内存时，使用哈希结构来存储。</p><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><blockquote><p>缓存<code>select</code>语句的查询结果</p></blockquote><h2 id="在配置文件中开启缓存"><a href="#在配置文件中开启缓存" class="headerlink" title="在配置文件中开启缓存"></a>在配置文件中开启缓存</h2><p>windows上是<code>my.ini</code>，linux上是<code>my.cnf</code></p><p>在<code>[mysqld]</code>段中配置<code>query_cache_type</code>：</p><ul><li>0：不开启</li><li>1：开启，默认缓存所有，需要在SQL语句中增加<code>select sql-no-cache</code>提示来放弃缓存</li><li>2：开启，默认都不缓存，需要在SQL语句中增加<code>select sql-cache</code>来主动缓存（==常用==）</li></ul><p>更改配置后需要重启以使配置生效，重启后可通过<code>show variables like ‘query_cache_type’;</code>来查看：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'query_cache_type'</span><span class="token punctuation">;</span>query_cache_type    DEMAND<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="在客户端设置缓存大小"><a href="#在客户端设置缓存大小" class="headerlink" title="在客户端设置缓存大小"></a>在客户端设置缓存大小</h2><p>通过配置项<code>query_cache_size</code>来设置：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'query_cache_size'</span><span class="token punctuation">;</span>query_cache_size    <span class="token number">0</span><span class="token keyword">set</span> <span class="token keyword">global</span> query_cache_size<span class="token operator">=</span><span class="token number">64</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'query_cache_size'</span><span class="token punctuation">;</span>query_cache_size    <span class="token number">67108864</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将查询结果缓存"><a href="#将查询结果缓存" class="headerlink" title="将查询结果缓存"></a>将查询结果缓存</h2><p><code>select sql_cache * from user;</code></p><h2 id="重置缓存"><a href="#重置缓存" class="headerlink" title="重置缓存"></a>重置缓存</h2><p><code>reset query cache;</code></p><h2 id="缓存失效问题（大问题）"><a href="#缓存失效问题（大问题）" class="headerlink" title="缓存失效问题（大问题）"></a>缓存失效问题（大问题）</h2><p>当数据表改动时，基于该数据表的任何缓存都会被删除。（表层面的管理，不是记录层面的管理，因此失效率较高）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>应用程序，不应该关心<code>query cache</code>的使用情况。可以尝试使用，但不能由<code>query cache</code>决定业务逻辑，因为<code>query cache</code>由DBA来管理。</li><li>缓存是以SQL语句为key存储的，因此即使SQL语句功能相同，但如果多了一个空格或者大小写有差异都会导致匹配不到缓存。</li></ol><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，==保证其单个文件的执行效率==。</p><p>最常见的分区方案是按<code>id</code>分区，如下将<code>id</code>的哈希值对10取模将数据均匀分散到10个<code>.ibd</code>存储文件中：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> article<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    title <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    content <span class="token keyword">text</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">by</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> PARTITIONS <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看<code>data</code>目录：</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/92311249.jpg" alt=""></p><blockquote><p>==服务端的表分区对于客户端是透明的==，客户端还是照常插入数据，但服务端会按照分区算法分散存储数据。</p></blockquote><h2 id="MySQL提供的分区算法"><a href="#MySQL提供的分区算法" class="headerlink" title="MySQL提供的分区算法"></a>MySQL提供的分区算法</h2><blockquote><p>==分区依据的字段必须是主键的一部分==，分区是为了快速定位数据，因此该字段的搜索频次较高应作为强检索字段，否则依照该字段分区毫无意义</p></blockquote><h3 id="hash-field"><a href="#hash-field" class="headerlink" title="hash(field)"></a>hash(field)</h3><p>相同的输入得到相同的输出。输出的结果跟输入是否具有规律无关。==仅适用于整型字段==</p><h3 id="key-field"><a href="#key-field" class="headerlink" title="key(field)"></a>key(field)</h3><p>和<code>hash(field)</code>的性质一样，只不过<code>key</code>是==处理字符串==的，比<code>hash()</code>多了一步从字符串中计算出一个整型在做取模操作。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> article_key<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    title <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    content <span class="token keyword">text</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>title<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 要求分区依据字段必须是主键的一部分</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">by</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span> PARTITIONS <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="range算法"><a href="#range算法" class="headerlink" title="range算法"></a>range算法</h3><p>是一种==条件分区==算法，按照数据大小范围分区（将数据使用某种条件，分散到不同的分区中）。</p><p>如下，按文章的发布时间将数据按照2018年8月、9月、10月分区存放：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> article_range<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    title <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    content <span class="token keyword">text</span><span class="token punctuation">,</span>    created_time <span class="token keyword">int</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- 发布时间到1970-1-1的毫秒数</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span>created_time<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 要求分区依据字段必须是主键的一部分</span><span class="token punctuation">)</span><span class="token keyword">charset</span><span class="token operator">=</span>utf8<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span>created_time<span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> p201808 <span class="token keyword">VALUES</span> less than <span class="token punctuation">(</span><span class="token number">1535731199</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- select UNIX_TIMESTAMP('2018-8-31 23:59:59')</span>    <span class="token keyword">PARTITION</span> p201809 <span class="token keyword">VALUES</span> less than <span class="token punctuation">(</span><span class="token number">1538323199</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- 2018-9-30 23:59:59</span>    <span class="token keyword">PARTITION</span> p201810 <span class="token keyword">VALUES</span> less than <span class="token punctuation">(</span><span class="token number">1541001599</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 2018-10-31 23:59:59</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/89312692.jpg" alt=""></p><p>注意：条件运算符只能使用==less than==，这以为着较小的范围要放在前面，比如上述<code>p201808,p201819,p201810</code>分区的定义顺序依照<code>created_time</code>数值范围从小到大，不能颠倒。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> article_range <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">'MySQL优化'</span><span class="token punctuation">,</span><span class="token string">'内容示例'</span><span class="token punctuation">,</span><span class="token number">1535731180</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flush <span class="token keyword">tables</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">-- 使操作立即刷新到磁盘文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/54910879.jpg" alt=""></p><p>由于插入的文章的发布时间<code>1535731180</code>小于<code>1535731199</code>（<code>2018-8-31 23:59:59</code>），因此被存储到<code>p201808</code>分区中，这种算法的存储到哪个分区取决于数据状况。</p><h3 id="list算法"><a href="#list算法" class="headerlink" title="list算法"></a>list算法</h3><p>也是一种条件分区，按照列表值分区（<code>in (值列表)</code>）。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> article_list<span class="token punctuation">(</span>    id <span class="token keyword">int</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>    title <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    content <span class="token keyword">text</span><span class="token punctuation">,</span>    <span class="token keyword">status</span> <span class="token keyword">TINYINT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- 文章状态：0-草稿，1-完成但未发布，2-已发布</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 要求分区依据字段必须是主键的一部分</span><span class="token punctuation">)</span><span class="token keyword">charset</span><span class="token operator">=</span>utf8<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> list<span class="token punctuation">(</span><span class="token keyword">status</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    <span class="token keyword">PARTITION</span> writing <span class="token keyword">values</span> <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- 未发布的放在一个分区    </span>    <span class="token keyword">PARTITION</span> published <span class="token keyword">values</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- 已发布的放在一个分区</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> article_list <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">'mysql优化'</span><span class="token punctuation">,</span><span class="token string">'内容示例'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flush <span class="token keyword">tables</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/54240876.jpg" alt=""></p><h2 id="分区管理语法"><a href="#分区管理语法" class="headerlink" title="分区管理语法"></a>分区管理语法</h2><h3 id="range-list"><a href="#range-list" class="headerlink" title="range/list"></a>range/list</h3><h4 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h4><p>前文中我们尝试使用<code>range</code>对文章按照月份归档，随着时间的增加，我们需要增加一个月份：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> article_range <span class="token keyword">add</span> <span class="token keyword">partition</span><span class="token punctuation">(</span>    <span class="token keyword">partition</span> p201811 <span class="token keyword">values</span> less than <span class="token punctuation">(</span><span class="token number">1543593599</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">-- select UNIX_TIMESTAMP('2018-11-30 23:59:59')</span>    <span class="token comment" spellcheck="true">-- more</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/17160012.jpg" alt=""></p><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> article_range <span class="token keyword">drop</span> <span class="token keyword">PARTITION</span> p201808<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：==删除分区后，分区中原有的数据也会随之删除！==</p><h3 id="key-hash"><a href="#key-hash" class="headerlink" title="key/hash"></a>key/hash</h3><h4 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> article_key <span class="token keyword">add</span> <span class="token keyword">partition</span> partitions <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-26/83089746.jpg" alt=""></p><h4 id="销毁分区"><a href="#销毁分区" class="headerlink" title="销毁分区"></a>销毁分区</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> article_key <span class="token keyword">coalesce</span> <span class="token keyword">partition</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>key/hash</code>分区的管理不会删除数据，但是每一次调整（新增或销毁分区）都会将所有的数据重写分配到新的分区上。==效率极低==，最好在设计阶段就考虑好分区策略。</p><h2 id="分区的使用"><a href="#分区的使用" class="headerlink" title="分区的使用"></a>分区的使用</h2><p>当数据表中的数据量很大时，分区带来的效率提升才会显现出来。</p><p>只有检索字段为分区字段时，分区带来的效率提升才会比较明显。因此，==分区字段的选择很重要==，并且==业务逻辑要尽可能地根据分区字段做相应调整==（尽量使用分区字段作为查询条件）。</p><h1 id="水平分割和垂直分割"><a href="#水平分割和垂直分割" class="headerlink" title="水平分割和垂直分割"></a>水平分割和垂直分割</h1><blockquote><p>水平分割：通过建立结构相同的几张表分别存储数据</p><p>垂直分割：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系。</p></blockquote><h2 id="分表原因"><a href="#分表原因" class="headerlink" title="分表原因"></a>分表原因</h2><ul><li>为数据库减压</li><li>分区算法局限</li><li>数据库支持不完善（<code>5.1</code>之后<code>mysql</code>才支持分区操作）</li></ul><h2 id="id重复的解决方案"><a href="#id重复的解决方案" class="headerlink" title="id重复的解决方案"></a>id重复的解决方案</h2><ul><li>借用第三方应用如<code>memcache、redis</code>的<code>id</code>自增器</li><li>单独建一张只包含<code>id</code>一个字段的表，每次自增该字段作为数据记录的<code>id</code></li></ul><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><blockquote><p>横向扩展：从根本上（单机的硬件处理能力有限）提升数据库性能 。由此而生的相关技术：==读写分离、负载均衡==</p></blockquote><h2 id="安装和配置主从复制"><a href="#安装和配置主从复制" class="headerlink" title="安装和配置主从复制"></a>安装和配置主从复制</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><code>Red Hat Enterprise Linux Server release 7.0 (Maipo)</code>（虚拟机）</li><li><code>mysql5.7</code>（<a href="https://mirrors.163.com/mysql/Downloads/MySQL-5.7/mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="noopener">下载地址</a>）</li></ul><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>解压到对外提供的服务的目录（我自己专门创建了一个<code>/export/server</code>来存放）</p><pre class="line-numbers language-shell"><code class="language-shell">tar xzvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz -C /export/servercd /export/servermv mysql-5.7.23-linux-glibc2.12-x86_64 mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加<code>mysql</code>目录的所属组和所属者：</p><pre class="line-numbers language-shell"><code class="language-shell">groupadd mysqluseradd -r -g mysql mysqlcd /export/serverchown -R mysql:mysql mysql/chmod -R 755 mysql/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建<code>mysql</code>数据存放目录（其中<code>/export/data</code>是我创建专门用来为各种服务存放数据的目录）</p><pre class="line-numbers language-shell"><code class="language-shell">mkdir /export/data/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化<code>mysql</code>服务</p><pre class="line-numbers language-shell"><code class="language-shell">cd /export/server/mysql./bin/mysqld --basedir=/export/server/mysql --datadir=/export/data/mysql --user=mysql --pid-file=/export/data/mysql/mysql.pid --initialize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果成功会显示<code>mysql</code>的<code>root</code>账户的初始密码，记下来以备后续登录。如果报错缺少依赖，则使用<code>yum instally</code>依次安装即可</p></blockquote><p>配置<code>my.cnf</code></p><pre class="line-numbers language-shell"><code class="language-shell">vim /etc/my.cnf[mysqld]basedir=/export/server/mysqldatadir=/export/data/mysqlsocket=/tmp/mysql.sockuser=mysqlserver-id=10 # 服务id，在集群时必须唯一，建议设置为IP的第四段port=3306# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemd[mysqld_safe]log-error=/export/data/mysql/error.logpid-file=/export/data/mysql/mysql.pid## include all files from the config directory#!includedir /etc/my.cnf.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将服务添加到开机自动启动</p><pre class="line-numbers language-shell"><code class="language-shell">cp /export/server/mysql/support-files/mysql.server /etc/init.d/mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务</p><pre class="line-numbers language-shell"><code class="language-shell">service mysqld start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置环境变量，在<code>/etc/profile</code>中添加如下内容</p><pre class="line-numbers language-shell"><code class="language-shell"># mysql envMYSQL_HOME=/export/server/mysqlMYSQL_PATH=$MYSQL_HOME/binPATH=$PATH:$MYSQL_PATHexport PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使配置即可生效</p><pre class="line-numbers language-shell"><code class="language-shell">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>root</code>登录</p><pre class="line-numbers language-shell"><code class="language-shell">mysql -uroot -p# 这里填写之前初始化服务时提供的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录上去之后，更改<code>root</code>账户密码（我为了方便将密码改为root），否则操作数据库会报错</p><pre class="line-numbers language-mysql"><code class="language-mysql">set password=password('root');flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置服务可被所有远程客户端访问</p><pre class="line-numbers language-mysql"><code class="language-mysql">use mysql;update user set host='%' where user='root';flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这样就可以在宿主机使用<code>navicat</code>远程连接虚拟机linux上的mysql了</p></blockquote><h3 id="配置主从节点"><a href="#配置主从节点" class="headerlink" title="配置主从节点"></a>配置主从节点</h3><h4 id="配置master"><a href="#配置master" class="headerlink" title="配置master"></a>配置master</h4><p>以<code>linux</code>（<code>192.168.10.10</code>）上的<code>mysql</code>为<code>master</code>，宿主机（<code>192.168.10.1</code>）上的<code>mysql</code>为<code>slave</code>配置主从复制。</p><p>修改<code>master</code>的<code>my.cnf</code>如下</p><pre class="line-numbers language-shell"><code class="language-shell">[mysqld]basedir=/export/server/mysqldatadir=/export/data/mysqlsocket=/tmp/mysql.sockuser=mysqlserver-id=10port=3306# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemdlog-bin=mysql-bin    # 开启二进制日志expire-logs-days=7  # 设置日志过期时间，避免占满磁盘binlog-ignore-db=mysql    # 不使用主从复制的数据库binlog-ignore-db=information_schemabinlog-ignore-db=performation_schemabinlog-ignore-db=sysbinlog-do-db=test    #使用主从复制的数据库[mysqld_safe]log-error=/export/data/mysql/error.logpid-file=/export/data/mysql/mysql.pid## include all files from the config directory#!includedir /etc/my.cnf.d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启<code>master</code></p><pre class="line-numbers language-shell"><code class="language-shell">service mysqld restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录<code>master</code>查看配置是否生效（<code>ON</code>即为开启，默认为<code>OFF</code>）：</p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> show variables like 'log_bin';+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin       | ON    |+---------------+-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>master</code>的数据库中建立备份账号：<code>backup</code>为用户名，<code>%</code>表示任何远程地址，用户<code>back</code>可以使用密码<code>1234</code>通过任何远程客户端连接<code>master</code></p><pre class="line-numbers language-mysql"><code class="language-mysql">grant replication slave on *.* to 'backup'@'%' identified by '1234'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看<code>user</code>表可以看到我们刚创建的用户：</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">use</span> mysqlmysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token keyword">user</span><span class="token punctuation">,</span>authentication_string<span class="token punctuation">,</span>host <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------------------------------------------+-----------+</span><span class="token operator">|</span> <span class="token keyword">user</span>          <span class="token operator">|</span> authentication_string                     <span class="token operator">|</span> host      <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------------------------------------------+-----------+</span><span class="token operator">|</span> root          <span class="token operator">|</span> <span class="token operator">*</span>81F5E21E35407D884A6CD4A731AEBFB6AF209E1B <span class="token operator">|</span> <span class="token operator">%</span>         <span class="token operator">|</span><span class="token operator">|</span> mysql<span class="token punctuation">.</span><span class="token keyword">session</span> <span class="token operator">|</span> <span class="token operator">*</span>THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE <span class="token operator">|</span> localhost <span class="token operator">|</span><span class="token operator">|</span> mysql<span class="token punctuation">.</span>sys     <span class="token operator">|</span> <span class="token operator">*</span>THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE <span class="token operator">|</span> localhost <span class="token operator">|</span><span class="token operator">|</span> <span class="token keyword">backup</span>        <span class="token operator">|</span> <span class="token operator">*</span>A4B6157319038724E3560894F7F932C8886EBFCF <span class="token operator">|</span> <span class="token operator">%</span>         <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------------------------------------------+-----------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建<code>test</code>数据库，创建一个<code>article</code>表以备后续测试</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>article<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>title<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>content<span class="token punctuation">`</span> <span class="token keyword">text</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启服务并刷新数据库状态到存储文件中（<code>with read lock</code>表示在此过程中，客户端只能读数据，以便获得一个一致性的快照）</p><pre class="line-numbers language-shell"><code class="language-shell">[root@zhenganwen ~]# service mysqld restartShutting down MySQL.... SUCCESS! Starting MySQL. SUCCESS! [root@zhenganwen mysql]# mysql -uroot -prootmysql> flush tables with read lock;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看<code>master</code>上当前的二进制日志和偏移量（记一下其中的<code>File</code>和<code>Position</code>）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> master <span class="token keyword">status</span> \G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>             <span class="token keyword">File</span>: mysql<span class="token operator">-</span>bin<span class="token number">.000002</span>         Position: <span class="token number">154</span>     Binlog_Do_DB: test Binlog_Ignore_DB: mysql<span class="token punctuation">,</span>information_schema<span class="token punctuation">,</span>performation_schema<span class="token punctuation">,</span>sysExecuted_Gtid_Set: <span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-29/90485140.jpg" alt=""></p><p><code>File</code>表示实现复制功能的日志，即上图中的<code>Binary log</code>；<code>Position</code>则表示<code>Binary log</code>日志文件的偏移量之后的都会同步到<code>slave</code>中，那么在偏移量之前的则需要我们手动导入。</p><p>主服务器上面的任何修改都会保存在二进制日志Binary log里面，从服务器上面启动一个I/O thread（实际上就是一个主服务器的客户端进程），连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log里面。从服务器上面开启一个SQL thread定时检查Realy log，如果发现有更改立即把更改的内容在本机上面执行一遍。</p><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些</p><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-29/37162547.jpg" alt=""></p><p>手动导入，从<code>master</code>中导出数据</p><pre class="line-numbers language-shell"><code class="language-shell">mysqldump -uroot -proot -hlocalhost test > /export/data/test.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>test.sql</code>中的内容在<code>slave</code>上执行一遍。</p><h4 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h4><p>修改<code>slave</code>的<code>my.ini</code>文件中的<code>[mysqld]</code>部分</p><pre class="line-numbers language-ini"><code class="language-ini"><span class="token constant">log-bin</span><span class="token attr-value"><span class="token punctuation">=</span>mysql</span><span class="token constant">server-id</span><span class="token attr-value"><span class="token punctuation">=</span>1 #192.168.10.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>保存修改后重启<code>slave</code>，<code>WIN+R</code>-&gt;<code>services.msc</code>-&gt;<code>MySQL5.7</code>-&gt;重新启动</p><p>登录<code>slave</code>检查<code>log_bin</code>是否以被开启：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">show</span> VARIABLES <span class="token operator">like</span> <span class="token string">'log_bin'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置与<code>master</code>的同步复制：</p><pre class="line-numbers language-sql"><code class="language-sql">stop slave<span class="token punctuation">;</span> change master <span class="token keyword">to</span>    master_host<span class="token operator">=</span><span class="token string">'192.168.10.10'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">-- master的IP</span>    master_user<span class="token operator">=</span><span class="token string">'backup'</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">-- 之前在master上创建的用户</span>    master_password<span class="token operator">=</span><span class="token string">'1234'</span><span class="token punctuation">,</span>    master_log_file<span class="token operator">=</span><span class="token string">'mysql-bin.000002'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">-- master上 show master status \G 提供的信息</span>    master_log_pos<span class="token operator">=</span><span class="token number">154</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启用<code>slave</code>节点并查看状态</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">start</span> slave<span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> slave <span class="token keyword">status</span> \G<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>               Slave_IO_State: Waiting <span class="token keyword">for</span> master <span class="token keyword">to</span> send event                  Master_Host: <span class="token number">192.168</span><span class="token punctuation">.</span><span class="token number">10.10</span>                  Master_User: <span class="token keyword">backup</span>                  Master_Port: <span class="token number">3306</span>                Connect_Retry: <span class="token number">60</span>              Master_Log_File: mysql<span class="token operator">-</span>bin<span class="token number">.000002</span>          Read_Master_Log_Pos: <span class="token number">154</span>               Relay_Log_File: DESKTOP<span class="token operator">-</span>KUBSPE0<span class="token operator">-</span>relay<span class="token operator">-</span>bin<span class="token number">.000002</span>                Relay_Log_Pos: <span class="token number">320</span>        Relay_Master_Log_File: mysql<span class="token operator">-</span>bin<span class="token number">.000002</span>             Slave_IO_Running: Yes            Slave_SQL_Running: Yes              Replicate_Do_DB:          Replicate_Ignore_DB:           Replicate_Do_Table:       Replicate_Ignore_Table:      Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:                   Last_Errno: <span class="token number">0</span>                   Last_Error:                 Skip_Counter: <span class="token number">0</span>          Exec_Master_Log_Pos: <span class="token number">154</span>              Relay_Log_Space: <span class="token number">537</span>              Until_Condition: None               Until_Log_File:                Until_Log_Pos: <span class="token number">0</span>           Master_SSL_Allowed: <span class="token keyword">No</span>           Master_SSL_CA_File:           Master_SSL_CA_Path:              Master_SSL_Cert:            Master_SSL_Cipher:               Master_SSL_Key:        Seconds_Behind_Master: <span class="token number">0</span>Master_SSL_Verify_Server_Cert: <span class="token keyword">No</span>                Last_IO_Errno: <span class="token number">0</span>                Last_IO_Error:               Last_SQL_Errno: <span class="token number">0</span>               Last_SQL_Error:  Replicate_Ignore_Server_Ids:             Master_Server_Id: <span class="token number">10</span>                  Master_UUID: <span class="token number">f68774b7</span><span class="token operator">-</span><span class="token number">0b28</span><span class="token operator">-</span><span class="token number">11e9</span><span class="token operator">-</span><span class="token number">a925</span><span class="token operator">-</span><span class="token number">000c290abe05</span>             Master_Info_File: C:\ProgramData\MySQL\MySQL Server <span class="token number">5.7</span>\<span class="token keyword">Data</span>\master<span class="token punctuation">.</span>info                    SQL_Delay: <span class="token number">0</span>          SQL_Remaining_Delay: <span class="token boolean">NULL</span>      Slave_SQL_Running_State: Slave has <span class="token keyword">read</span> <span class="token keyword">all</span> relay log<span class="token punctuation">;</span> waiting <span class="token keyword">for</span> more updates           Master_Retry_Count: <span class="token number">86400</span>                  Master_Bind:      Last_IO_Error_Timestamp:     Last_SQL_Error_Timestamp:               Master_SSL_Crl:           Master_SSL_Crlpath:           Retrieved_Gtid_Set:            Executed_Gtid_Set:                Auto_Position: <span class="token number">0</span>         Replicate_Rewrite_DB:                 Channel_Name:           Master_TLS_Version:<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意查看第4、14、15三行，若与我一致，表示<code>slave</code>配置成功</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>关闭<code>master</code>的读取锁定</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> unlock <span class="token keyword">tables</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>向<code>master</code>中插入一条数据</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">use</span> testmysql<span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> article <span class="token punctuation">(</span>title<span class="token punctuation">,</span>content<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'mysql master and slave'</span><span class="token punctuation">,</span><span class="token string">'record the cluster building succeed!:)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看<code>slave</code>是否自动同步了数据</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> article <span class="token punctuation">(</span>title<span class="token punctuation">,</span>content<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'mysql master and slave'</span><span class="token punctuation">,</span><span class="token string">'record the cluster building succeed!:)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此，主从复制的配置成功！：)</p><p><a href="https://blog.csdn.net/xlgen157387/article/details/52452394" target="_blank" rel="noopener">使用mysqlreplicate命令快速搭建 Mysql 主从复制</a></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p><h3 id="方案一、定义两种连接"><a href="#方案一、定义两种连接" class="headerlink" title="方案一、定义两种连接"></a>方案一、定义两种连接</h3><p>就像我们在学JDBC时定义的<code>DataBase</code>一样，我们可以抽取出<code>ReadDataBase,WriteDataBase implements DataBase</code>，但是这种方式无法利用优秀的线程池技术如<code>DruidDataSource</code>帮我们管理连接，也无法利用<code>Spring AOP</code>让连接对<code>DAO</code>层透明。</p><h3 id="方案二、使用Spring-AOP"><a href="#方案二、使用Spring-AOP" class="headerlink" title="方案二、使用Spring  AOP"></a>方案二、使用Spring  AOP</h3><p>如果能够使用<code>Spring AOP</code>解决数据源切换的问题，那么就可以和<code>Mybatis</code>、<code>Druid</code>整合到一起了。</p><p>我们在整合<code>Spring1</code>和<code>Mybatis</code>时，我们只需写DAO接口和对应的<code>SQL</code>语句，那么DAO实例是由谁创建的呢？实际上就是<code>Spring</code>帮我们创建的，它通过我们注入的数据源，帮我们完成从中获取数据库连接、使用连接执行 <code>SQL</code> 语句的过程以及最后归还连接给数据源的过程。</p><p>如果我们能在调用DAO接口时根据接口方法命名规范（增<code>addXXX/createXXX</code>、删<code>deleteXX/removeXXX</code>、改<code>updateXXXX</code>、查<code>selectXX/findXXX/getXX/queryXXX</code>）动态地选择数据源（读数据源对应连接<code>master</code>而写数据源对应连接<code>slave</code>），那么就可以做到读写分离了。</p><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://zanwenblog.oss-cn-beijing.aliyuncs.com/18-12-29/71747137.jpg" alt=""></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>其中，为了方便访问数据库引入了<code>mybatis</code>和<code>druid</code>，实现数据源动态切换主要依赖<code>spring-aop</code>和<code>spring-aspects</code></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>6.0.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-context<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-aspects<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.16.22<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>entity<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>AllArgsConstructor<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>NoArgsConstructor<span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Article</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h4><p>其中<code>RoutingDataSourceImpl</code>是实现动态切换功能的核心类，稍后介绍。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>property-placeholder</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>property-placeholder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slaveDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${db.driverClass}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${master.db.url}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${master.db.username}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${master.db.password}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>masterDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.alibaba.druid.pool.DruidDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driverClassName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${db.driverClass}<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${slave.db.url}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${slave.db.username}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${slave.db.password}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSourceRouting<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize.dataSource.RoutingDataSourceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>defaultTargetDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>masterDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>targetDataSources<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">key-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javax.sql.DataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slaveDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>masterDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>methodType<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">key-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>query,find,select,get,load,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>update,add,create,delete,remove,modify<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Mybatis文件 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.SqlSessionFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>configLocation<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>classpath:mybatis-config.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSourceRouting<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapperLocations<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapper/*.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.mybatis.spring.mapper.MapperScannerConfigurer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>basePackage<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize.mapper<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactoryBeanName<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sqlSessionFactory<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dp.properties</code></p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">master.db.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><span class="token attr-name">master.db.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">master.db.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">slave.db.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://192.168.10.10:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><span class="token attr-name">slave.db.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">slave.db.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">db.driverClass</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mybatis-config.xml</code></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize.entity.Article<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Article<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="mapper接口和配置文件"><a href="#mapper接口和配置文件" class="headerlink" title="mapper接口和配置文件"></a>mapper接口和配置文件</h4><p><code>ArticleMapper.java</code></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>mapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Repository<span class="token punctuation">;</span><span class="token keyword">import</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>Article<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token annotation punctuation">@Repository</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ArticleMapper</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Article<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Article article<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ArticleMapper.xml</code></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" ></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize.mapper.ArticleMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from article    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>add<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into article (title,content) values (#{title},#{content})    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>delete<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        delete from article where id=#{id}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="RoutingDataSourceImpl"><a href="#RoutingDataSourceImpl" class="headerlink" title="RoutingDataSourceImpl"></a>RoutingDataSourceImpl</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>dataSource<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>lookup<span class="token punctuation">.</span>AbstractRoutingDataSource<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * RoutingDataSourceImpl class * 数据源路由 * * @author zhenganwen, blog:zhenganwen.top * @date 2018/12/29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoutingDataSourceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractRoutingDataSource</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * key为read或write     * value为DAO方法的前缀     * 什么前缀开头的方法使用读数据员，什么开头的方法使用写数据源     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> METHOD_TYPE_MAP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 由我们指定数据源的id，由Spring切换数据源     *     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">determineCurrentLookupKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据源为："</span><span class="token operator">+</span>DataSourceHandler<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> DataSourceHandler<span class="token punctuation">.</span><span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMethodType</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String type <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String methodPrefixList <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>methodPrefixList <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                METHOD_TYPE_MAP<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>methodPrefixList<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的主要功能是，本来我们只配置一个数据源，因此<code>Spring</code>动态代理DAO接口时直接使用该数据源，现在我们有了读、写两个数据源，我们需要加入一些自己的逻辑来告诉调用哪个接口使用哪个数据源（读数据的接口使用<code>slave</code>，写数据的接口使用<code>master</code>。这个告诉<code>Spring</code>该使用哪个数据源的类就是<code>AbstractRoutingDataSource</code>，必须重写的方法<code>determineCurrentLookupKey</code>返回数据源的标识，结合<code>spring</code>配置文件（下段代码的5，6两行）</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSourceRouting<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top.zhenganwen.mysqloptimize.dataSource.RoutingDataSourceImpl<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>defaultTargetDataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>masterDataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>targetDataSources<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">key-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javax.sql.DataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slaveDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token attr-name">value-ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>masterDataSource<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>methodType<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span> <span class="token attr-name">key-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span> <span class="token attr-name">value-type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.String<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>query,find,select,get,load,<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>write<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>update,add,create,delete,remove,modify<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果<code>determineCurrentLookupKey</code>返回<code>read</code>那么使用<code>slaveDataSource</code>，如果返回<code>write</code>就使用<code>masterDataSource</code>。</p><h5 id="DataSourceHandler"><a href="#DataSourceHandler" class="headerlink" title="DataSourceHandler"></a>DataSourceHandler</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>dataSource<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * DataSourceHandler class * &lt;p> * 将数据源与线程绑定，需要时根据线程获取 * * @author zhenganwen, blog:zhenganwen.top * @date 2018/12/29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 绑定的是read或write，表示使用读或写数据源     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setDataSource</span><span class="token punctuation">(</span>String dataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"设置了数据源类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"获取了数据源类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="DataSourceAspect"><a href="#DataSourceAspect" class="headerlink" title="DataSourceAspect"></a>DataSourceAspect</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>dataSource<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>JoinPoint<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Aspect<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Before<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Pointcut<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableAspectJAutoProxy<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>dataSource<span class="token punctuation">.</span>RoutingDataSourceImpl<span class="token punctuation">.</span>METHOD_TYPE_MAP<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * DataSourceAspect class * * 配置切面，根据方法前缀设置读、写数据源 * 项目启动时会加载该bean，并按照配置的切面（哪些切入点、如何增强）确定动态代理逻辑 * @author zhenganwen,blog:zhenganwen.top * @date 2018/12/29 */</span><span class="token annotation punctuation">@Component</span><span class="token comment" spellcheck="true">//声明这是一个切面，这样Spring才会做相应的配置，否则只会当做简单的bean注入</span><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceAspect</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 配置切入点：DAO包下的所有类的所有方法     */</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* top.zhenganwen.mysqloptimize.mapper.*.*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">aspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 配置前置增强，对象是aspect()方法上配置的切入点     */</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"aspect()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span>JoinPoint point<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String className <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String invokedMethod <span class="token operator">=</span> point<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对 "</span><span class="token operator">+</span>className<span class="token operator">+</span><span class="token string">"$"</span><span class="token operator">+</span>invokedMethod<span class="token operator">+</span><span class="token string">" 做了前置增强，确定了要使用的数据源类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> dataSourceType <span class="token operator">=</span> METHOD_TYPE_MAP<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String type <span class="token operator">:</span> dataSourceType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> prefixList <span class="token operator">=</span> METHOD_TYPE_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String prefix <span class="token operator">:</span> prefixList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>invokedMethod<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    DataSourceHandler<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据源为："</span><span class="token operator">+</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="测试读写分离"><a href="#测试读写分离" class="headerlink" title="测试读写分离"></a>测试读写分离</h4><blockquote><p>如何测试读是从<code>slave</code>中读的呢？可以将写后复制到<code>slave</code>中的数据更改，再读该数据就知道是从<code>slave</code>中读了。==注意==，一但对<code>slave</code>做了写操作就要重新手动将<code>slave</code>与<code>master</code>同步一下，否则主从复制就会失效。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>dataSource<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ContextConfiguration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringJUnit4ClassRunner<span class="token punctuation">;</span><span class="token keyword">import</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>Article<span class="token punctuation">;</span><span class="token keyword">import</span> top<span class="token punctuation">.</span>zhenganwen<span class="token punctuation">.</span>mysqloptimize<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>ArticleMapper<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringJUnit4ClassRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span>locations <span class="token operator">=</span> <span class="token string">"classpath:spring-mybatis.xml"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoutingDataSourceTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    ArticleMapper articleMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>articleMapper<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Article article <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Article</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"我是新插入的文章"</span><span class="token punctuation">,</span> <span class="token string">"测试是否能够写到master并且复制到slave中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        articleMapper<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>article<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        articleMapper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul><li>轮询</li><li>加权轮询：按照处理能力来加权</li><li>负载分配：依据当前的空闲状态（但是测试每个节点的内存使用率、CPU利用率等，再做比较选出最闲的那个，效率太低）</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>在服务器架构时，为了保证服务器7x24不宕机在线状态，需要为每台单点服务器（由一台服务器提供服务的服务器，如写服务器、数据库中间件）提供冗余机。</p><p>对于写服务器来说，需要提供一台同样的写-冗余服务器，当写服务器健康时（写-冗余通过心跳检测），写-冗余作为一个从机的角色复制写服务器的内容与其做一个同步；当写服务器宕机时，写-冗余服务器便顶上来作为写服务器继续提供服务。对外界来说这个处理过程是透明的，即外界仅通过一个IP访问服务。</p><h1 id="典型SQL"><a href="#典型SQL" class="headerlink" title="典型SQL"></a>典型SQL</h1><h2 id="线上DDL"><a href="#线上DDL" class="headerlink" title="线上DDL"></a>线上DDL</h2><p>DDL(Database Definition Language)是指数据库表结构的定义（<code>create table</code>）和维护（<code>alter table</code>）的语言。在线上执行DDL，在低于<code>MySQL5.6</code>版本时会导致全表被独占锁定，此时表处于维护、不可操作状态，这会导致该期间对该表的所有访问无法响应。但是在<code>MySQL5.6</code>之后，支持<code>Online DDL</code>，大大缩短了锁定时间。</p><p>优化技巧是采用的维护表结构的DDL（比如增加一列，或者增加一个索引），是==copy==策略。思路：创建一个满足新结构的新表，将旧表数据==逐条==导入（复制）到新表中，以保证==一次性锁定的内容少==（锁定的是正在导入的数据），同时旧表上可以执行其他任务。导入的过程中，将对旧表的所有操作以日志的形式记录下来，导入完毕后，将更新日志在新表上再执行一遍（确保一致性）。最后，新表替换旧表（在应用程序中完成，或者是数据库的rename，视图完成）。</p><p>但随着MySQL的升级，这个问题几乎淡化了。</p><h2 id="数据库导入语句"><a href="#数据库导入语句" class="headerlink" title="数据库导入语句"></a>数据库导入语句</h2><p>在恢复数据时，可能会导入大量的数据。此时为了快速导入，需要掌握一些技巧：</p><ol><li>导入时==先禁用索引和约束==：</li></ol><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">table</span><span class="token operator">-</span>name <span class="token keyword">disable</span> <span class="token keyword">keys</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>待数据导入完成之后，再开启索引和约束，一次性创建索引</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">table</span><span class="token operator">-</span>name <span class="token keyword">enable</span> <span class="token keyword">keys</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>数据库如果使用的引擎是<code>Innodb</code>，那么它==默认会给每条写指令加上事务==（这也会消耗一定的时间），因此建议先手动开启事务，再执行一定量的批量导入，最后手动提交事务。</li><li>如果批量导入的SQL指令格式相同只是数据不同，那么你应该先<code>prepare</code>==预编译==一下，这样也能节省很多重复编译的时间。</li></ol><h2 id="limit-offset-rows"><a href="#limit-offset-rows" class="headerlink" title="limit offset,rows"></a>limit offset,rows</h2><p>尽量保证不要出现大的<code>offset</code>，比如<code>limit 10000,10</code>相当于对已查询出来的行数弃掉前<code>10000</code>行后再取<code>10</code>行，完全可以加一些条件过滤一下（完成筛选），而不应该使用<code>limit</code>跳过已查询到的数据。这是一个==<code>offset</code>做无用功==的问题。对应实际工程中，要避免出现大页码的情况，尽量引导用户做条件过滤。</p><h2 id="select-要少用"><a href="#select-要少用" class="headerlink" title="select * 要少用"></a>select * 要少用</h2><p>即尽量选择自己需要的字段<code>select</code>，但这个影响不是很大，因为网络传输多了几十上百字节也没多少延时，并且现在流行的ORM框架都是用的<code>select *</code>，只是我们在设计表的时候注意将大数据量的字段分离，比如商品详情可以单独抽离出一张商品详情表，这样在查看商品简略页面时的加载速度就不会有影响了。</p><h2 id="order-by-rand-不要用"><a href="#order-by-rand-不要用" class="headerlink" title="order by rand()不要用"></a>order by rand()不要用</h2><p>它的逻辑就是随机排序（为每条数据生成一个随机数，然后根据随机数大小进行排序）。如<code>select * from student order by rand() limit 5</code>的执行效率就很低，因为它为表中的每条数据都生成随机数并进行排序，而我们只要前5条。</p><p>解决思路：在应用程序中，将随机的主键生成好，去数据库中利用主键检索。</p><h2 id="单表和多表查询"><a href="#单表和多表查询" class="headerlink" title="单表和多表查询"></a>单表和多表查询</h2><p>多表查询：<code>join</code>、子查询都是涉及到多表的查询。如果你使用<code>explain</code>分析执行计划你会发现多表查询也是一个表一个表的处理，最后合并结果。因此可以说单表查询将计算压力放在了应用程序上，而多表查询将计算压力放在了数据库上。</p><p>现在有ORM框架帮我们解决了单表查询带来的对象映射问题（查询单表时，如果发现有外键自动再去查询关联表，是一个表一个表查的）。</p><h2 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h2><p>在<code>MyISAM</code>存储引擎中，会自动记录表的行数，因此使用<code>count(*)</code>能够快速返回。而<code>Innodb</code>内部没有这样一个计数器，需要我们手动统计记录数量，解决思路就是单独使用一张表：</p><table><thead><tr><th>id</th><th>table</th><th>count</th></tr></thead><tbody><tr><td>1</td><td>student</td><td>100</td></tr></tbody></table><h2 id="limit-1"><a href="#limit-1" class="headerlink" title="limit 1"></a>limit 1</h2><p>如果可以确定仅仅检索一条，建议加上<code>limit 1</code>，其实ORM框架帮我们做到了这一点（查询单条的操作都会自动加上<code>limit 1</code>）。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><h2 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h2><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><h2 id="设置临界时间"><a href="#设置临界时间" class="headerlink" title="设置临界时间"></a>设置临界时间</h2><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h1 id="profile信息"><a href="#profile信息" class="headerlink" title="profile信息"></a>profile信息</h1><p>配置项：<code>profiling</code></p><h2 id="开启profile"><a href="#开启profile" class="headerlink" title="开启profile"></a>开启profile</h2><p><code>set profiling=on</code></p><p>开启后，所有的SQL执行的详细信息都会被自动记录下来</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'profiling'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token operator">|</span> profiling     <span class="token operator">|</span> <span class="token keyword">OFF</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">set</span> profiling<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected<span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看profile信息"><a href="#查看profile信息" class="headerlink" title="查看profile信息"></a>查看profile信息</h2><p><code>show profiles</code></p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'profiling'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token operator">|</span> profiling     <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> article <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">'test profile'</span><span class="token punctuation">,</span><span class="token string">':)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.15</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">></span> <span class="token keyword">show</span> profiles<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+------------+-------------------------------------------------------+</span><span class="token operator">|</span> Query_ID <span class="token operator">|</span> Duration   <span class="token operator">|</span> Query                                                 <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+------------+-------------------------------------------------------+</span><span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0.00086150</span> <span class="token operator">|</span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'profiling'</span>                       <span class="token operator">|</span><span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">0.15027550</span> <span class="token operator">|</span> <span class="token keyword">insert</span> <span class="token keyword">into</span> article <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token boolean">null</span><span class="token punctuation">,</span><span class="token string">'test profile'</span><span class="token punctuation">,</span><span class="token string">':)'</span><span class="token punctuation">)</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----------+------------+-------------------------------------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过Query-ID查看某条SQL所有详细步骤的时间"><a href="#通过Query-ID查看某条SQL所有详细步骤的时间" class="headerlink" title="通过Query_ID查看某条SQL所有详细步骤的时间"></a>通过Query_ID查看某条SQL所有详细步骤的时间</h2><p><code>show profile for query Query_ID</code></p><p>上面<code>show profiles</code>的结果中，每个SQL有一个<code>Query_ID</code>，可以通过它查看执行该SQL经过了哪些步骤，各消耗了多场时间</p><pre class="line-numbers language-sql"><code class="language-sql"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="典型的服务器配置"><a href="#典型的服务器配置" class="headerlink" title="典型的服务器配置"></a>典型的服务器配置</h1><blockquote><p>以下的配置全都取决于实际的运行环境</p></blockquote><ul><li><p><code>max_connections</code>，最大客户端连接数</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'max_connections'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-------+</span><span class="token operator">|</span> Variable_name   <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-------+</span><span class="token operator">|</span> max_connections <span class="token operator">|</span> <span class="token number">151</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>table_open_cache</code>，表文件句柄缓存（表数据是存储在磁盘上的，缓存磁盘文件的句柄方便打开文件读取数据）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'table_open_cache'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span><span class="token operator">|</span> Variable_name    <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span><span class="token operator">|</span> table_open_cache <span class="token operator">|</span> <span class="token number">2000</span>  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>key_buffer_size</code>，索引缓存大小（将从磁盘上读取的索引缓存到内存，可以设置大一些，有利于快速检索）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'key_buffer_size'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+---------+</span><span class="token operator">|</span> Variable_name   <span class="token operator">|</span> <span class="token keyword">Value</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+---------+</span><span class="token operator">|</span> key_buffer_size <span class="token operator">|</span> <span class="token number">8388608</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+---------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>innodb_buffer_pool_size</code>，<code>Innodb</code>存储引擎缓存池大小（对于<code>Innodb</code>来说最重要的一个配置，如果所有的表用的都是<code>Innodb</code>，那么甚至建议将该值设置到物理内存的80%，<code>Innodb</code>的很多性能提升如索引都是依靠这个）</p><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'innodb_buffer_pool_size'</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-------------------------+---------+</span><span class="token operator">|</span> Variable_name           <span class="token operator">|</span> <span class="token keyword">Value</span>   <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-------------------------+---------+</span><span class="token operator">|</span> innodb_buffer_pool_size <span class="token operator">|</span> <span class="token number">8388608</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">-------------------------+---------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>innodb_file_per_table</code>（<code>innodb</code>中，表数据存放在<code>.ibd</code>文件中，如果将该配置项设置为<code>ON</code>，那么一个表对应一个<code>ibd</code>文件，否则所有<code>innodb</code>共享表空间）</p></li></ul><h1 id="压测工具mysqlslap"><a href="#压测工具mysqlslap" class="headerlink" title="压测工具mysqlslap"></a>压测工具mysqlslap</h1><p>安装MySQL时附带了一个压力测试工具<code>mysqlslap</code>（位于<code>bin</code>目录下）</p><h2 id="自动生成sql测试"><a href="#自动生成sql测试" class="headerlink" title="自动生成sql测试"></a>自动生成sql测试</h2><pre class="line-numbers language-shell"><code class="language-shell">C:\Users\zaw>mysqlslap --auto-generate-sql -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 1.219 seconds        Minimum number of seconds to run all queries: 1.219 seconds        Maximum number of seconds to run all queries: 1.219 seconds        Number of clients running queries: 1        Average number of queries per client: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h2><pre class="line-numbers language-shell"><code class="language-shell">C:\Users\zaw>mysqlslap --auto-generate-sql --concurrency=100 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 3.578 seconds        Minimum number of seconds to run all queries: 3.578 seconds        Maximum number of seconds to run all queries: 3.578 seconds        Number of clients running queries: 100        Average number of queries per client: 0C:\Users\zaw>mysqlslap --auto-generate-sql --concurrency=150 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.718 seconds        Minimum number of seconds to run all queries: 5.718 seconds        Maximum number of seconds to run all queries: 5.718 seconds        Number of clients running queries: 150        Average number of queries per client: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多轮测试"><a href="#多轮测试" class="headerlink" title="多轮测试"></a>多轮测试</h2><pre class="line-numbers language-shell"><code class="language-shell">C:\Users\zaw>mysqlslap --auto-generate-sql --concurrency=150 --iterations=10 -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Average number of seconds to run all queries: 5.398 seconds        Minimum number of seconds to run all queries: 4.313 seconds        Maximum number of seconds to run all queries: 6.265 seconds        Number of clients running queries: 150        Average number of queries per client: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="存储引擎测试"><a href="#存储引擎测试" class="headerlink" title="存储引擎测试"></a>存储引擎测试</h2><pre class="line-numbers language-shell"><code class="language-shell">C:\Users\zaw>mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=innodb -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Running for engine innodb        Average number of seconds to run all queries: 5.911 seconds        Minimum number of seconds to run all queries: 5.485 seconds        Maximum number of seconds to run all queries: 6.703 seconds        Number of clients running queries: 150        Average number of queries per client: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">C:\Users\zaw>mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=myisam -uroot -prootmysqlslap: [Warning] Using a password on the command line interface can be insecure.Benchmark        Running for engine myisam        Average number of seconds to run all queries: 53.104 seconds        Minimum number of seconds to run all queries: 46.843 seconds        Maximum number of seconds to run all queries: 60.781 seconds        Number of clients running queries: 150        Average number of queries per client: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
